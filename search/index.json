[{"content":"OS lab syscall æ—¶éš”ä¸€å¤©ï¼Œå±…ç„¶åˆè±¡å¾æ€§çš„å®Œæˆäº†ä¸€ä¸ªå®éªŒğŸ˜‹\næœ¬æ¬¡å®éªŒéœ€è¦åœ¨xv6ç³»ç»Ÿå†…é¢å¤–æ·»åŠ ä¸¤ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œåˆ†åˆ«æ˜¯traceå’Œsysinfoï¼Œtraceç”¨äºè·Ÿè¸ªæŸä¸ªè¿›ç¨‹ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨çš„æƒ…å†µï¼Œsysinfoç”¨äºæŸ¥çœ‹ç³»ç»Ÿå†…ç©ºé—²å†…å­˜å’Œè¿›ç¨‹ä¸ªæ•°ã€‚\nå®éªŒçš„å®˜æ–¹æŒ‡å¯¼è§ https://pdos.csail.mit.edu/6.828/2020/labs/syscall.html ã€‚\nå‡†å¤‡ å®˜æ–¹æŒ‡å¯¼ä¸­çš„å‰ç½®è¦æ±‚æ˜¯\nBefore you start coding, read Chapter 2 of the xv6 book, and Sections 4.3 and 4.4 of Chapter 4, and related source files:\nThe user-space code for systems calls is in user/user.h and user/usys.pl. The kernel-space code is kernel/syscall.h, kernel/syscall.c. The process-related code is kernel/proc.h and kernel/proc.c. æŒ‡å¯¼ä¹¦ä¸­çš„Chapter 2æè¿°äº†æ“ä½œç³»ç»Ÿçš„ç»„ç»‡ç»“æ„ï¼Œå†…å®¹å¤§æ¦‚æ˜¯ç®€å•è®²äº†ä¸€ä¸‹æ“ä½œç³»ç»Ÿçš„åŠŸèƒ½ä½œç”¨ã€æ“ä½œç³»ç»Ÿä¸ºä»€ä¹ˆé‡è¦ã€æœ‰å“ªäº›ç»„ç»‡æ“ä½œç³»ç»Ÿå„ä¸ªéƒ¨åˆ†çš„æ–¹æ³•ç­‰ç­‰ã€‚\nåœ¨Chapter 2çš„æœ€åå¤§æ¦‚è®²äº†è®²xv6çš„å¯åŠ¨è¿‡ç¨‹ã€‚\nå¯åŠ¨æµç¨‹æ¦‚è¿° qemuæ¨¡æ‹Ÿçš„æœºå™¨å¯åŠ¨æ—¶é¦–å…ˆæ‰§è¡ŒROMä¸­çš„ç¨‹åºï¼Œè¿™ä¸ªç¨‹åºçš„ä½œç”¨åº”è¯¥å°±æ˜¯å°†å¯åŠ¨åŒºçš„ä¸€éƒ¨åˆ†ä»£ç è½½å…¥å†…å­˜å¹¶è½¬äº¤CPUä½¿ç”¨æƒåˆ°è½½å…¥çš„ä»£ç ï¼Œxv6æœ€åˆçš„ä»£ç è§kernel/entry.S:6\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # qemu -kernel loads the kernel at 0x80000000 # and causes each CPU to jump there. # kernel.ld causes the following code to # be placed at 0x80000000. .section .text _entry: # set up a stack for C. # stack0 is declared in start.c, # with a 4096-byte stack per CPU. # sp = stack0 + (hartid * 4096) la sp, stack0 li a0, 1024*4 csrr a1, mhartid addi a1, a1, 1 mul a0, a0, a1 add sp, sp, a0 # jump to start() in start.c call start spin: j spin ä¸Šé¢çš„æ±‡ç¼–ä»£ç è®¾ç½®å¥½æ ˆé¡¶å¯„å­˜å™¨åå°†è·³è½¬åˆ° kernel/start.cä¸­çš„startå‡½æ•°ï¼Œæ³¨æ„åœ¨æœºå™¨åˆšå¯åŠ¨æ—¶å¤„åœ¨machine modeï¼Œè¯¥æ¨¡å¼ä¸‹æ‹¥æœ‰æ‰€æœ‰çš„æƒé™ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // entry.S jumps here in machine mode on stack0. void start() { // set M Previous Privilege mode to Supervisor, for mret. unsigned long x = r_mstatus(); x \u0026amp;= ~MSTATUS_MPP_MASK; x |= MSTATUS_MPP_S; w_mstatus(x); // set M Exception Program Counter to main, for mret. // requires gcc -mcmodel=medany w_mepc((uint64)main); // disable paging for now. w_satp(0); // delegate all interrupts and exceptions to supervisor mode. w_medeleg(0xffff); w_mideleg(0xffff); w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE); // ask for clock interrupts. timerinit(); // keep each CPU\u0026#39;s hartid in its tp register, for cpuid(). int id = r_mhartid(); w_tp(id); // switch to supervisor mode and jump to main(). asm volatile(\u0026#34;mret\u0026#34;); } ä¸Šé¢çš„ä»£ç å¯¹æœºå™¨è¿›è¡Œäº†ä¸€äº›è®¾ç½®ï¼Œæ²¡äº†è§£è¿‡riscvçš„å¤„ç†å™¨ï¼Œéšç€å®éªŒçš„æ·±å…¥åº”è¯¥ä¹Ÿè®¸ä¼šäº†è§£æ›´å¤šå§ï¼Œä¸Šé¢ä»£ç çš„æœ€åä¸€å¥ï¼Œä½¿ç”¨æ±‡ç¼–mretï¼Œè¿™ä¸€èˆ¬ç”¨äºsupervisor modeè°ƒç”¨machine modeçš„ä»£ç åä»machine modeè¿”å›supervisor modeï¼Œåœ¨è¿™ä¸ªä»£ç é‡Œé€šè¿‡mretè¿›å…¥supervisor modeï¼Œä¹Ÿå°±æ˜¯æ“ä½œç³»ç»Ÿå†…æ ¸è¿è¡Œçš„æ¨¡å¼ï¼Œåœ¨startå‡½æ•°å‰é¢ä¸€äº›ä»£ç å·²ç»å°†è¿”å›åœ°å€è®¾ä¸ºäº†mainï¼Œæ•…mretä¼šè½¬åˆ°mainå‡½æ•°ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // start() jumps here in supervisor mode on all CPUs. void main() { if(cpuid() == 0){ consoleinit(); printfinit(); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;xv6 kernel is booting\\n\u0026#34;); printf(\u0026#34;\\n\u0026#34;); kinit(); // physical page allocator kvminit(); // create kernel page table kvminithart(); // turn on paging procinit(); // process table trapinit(); // trap vectors trapinithart(); // install kernel trap vector plicinit(); // set up interrupt controller plicinithart(); // ask PLIC for device interrupts binit(); // buffer cache iinit(); // inode cache fileinit(); // file table virtio_disk_init(); // emulated hard disk userinit(); // first user process __sync_synchronize(); started = 1; } else { while(started == 0) ; __sync_synchronize(); printf(\u0026#34;hart %d starting\\n\u0026#34;, cpuid()); kvminithart(); // turn on paging trapinithart(); // install kernel trap vector plicinithart(); // ask PLIC for device interrupts } scheduler(); } mainå‡½æ•°å†…è¿›è¡Œäº†ä¸€å †åˆå§‹åŒ–æ“ä½œï¼Œæœ€åè°ƒç”¨äº†userinit()å‡½æ•°å¯åŠ¨ç¬¬ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹ï¼Œè¯¥å‡½æ•°ä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Set up first user process. void userinit(void) { struct proc *p; p = allocproc(); initproc = p; // allocate one user page and copy init\u0026#39;s instructions // and data into it. uvminit(p-\u0026gt;pagetable, initcode, sizeof(initcode)); p-\u0026gt;sz = PGSIZE; // prepare for the very first \u0026#34;return\u0026#34; from kernel to user. p-\u0026gt;trapframe-\u0026gt;epc = 0; // user program counter p-\u0026gt;trapframe-\u0026gt;sp = PGSIZE; // user stack pointer safestrcpy(p-\u0026gt;name, \u0026#34;initcode\u0026#34;, sizeof(p-\u0026gt;name)); p-\u0026gt;cwd = namei(\u0026#34;/\u0026#34;); p-\u0026gt;state = RUNNABLE; release(\u0026amp;p-\u0026gt;lock); } ä¸Šé¢çš„ä»£ç åœ¨å¯¹è¿›ç¨‹ä¸€äº›å¿…è¦çš„ä¸œè¥¿åˆå§‹åŒ–åå¯åŠ¨äº†initcodeè¿™ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹ï¼Œè¯¥è¿›ç¨‹æ˜¯ç”¨æ±‡ç¼–å†™çš„ï¼Œä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026#34;syscall.h\u0026#34; # exec(init, argv) .globl start start: la a0, init la a1, argv li a7, SYS_exec ecall # for(;;) exit(); exit: li a7, SYS_exit ecall jal exit # char init[] = \u0026#34;/init\\0\u0026#34;; init: .string \u0026#34;/init\\0\u0026#34; # char *argv[] = { init, 0 }; .p2align 2 argv: .long init .long 0 ä¸Šé¢çš„ä»£ç ç›¸å½“äºæ‰§è¡Œäº†cç¨‹åº\n1 2 3 4 5 6 7 8 void start(){ char *init = \u0026#34;/init\u0026#34;; char *argv[] = {init,0}; exec(init,argv); for(;;) exit(); } è¿™ä¸ª/initç¨‹åºè§æºç user/init.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // init: The initial user-level program #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;kernel/spinlock.h\u0026#34; #include \u0026#34;kernel/sleeplock.h\u0026#34; #include \u0026#34;kernel/fs.h\u0026#34; #include \u0026#34;kernel/file.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; #include \u0026#34;kernel/fcntl.h\u0026#34; char *argv[] = { \u0026#34;sh\u0026#34;, 0 }; int main(void) { int pid, wpid; if(open(\u0026#34;console\u0026#34;, O_RDWR) \u0026lt; 0){ mknod(\u0026#34;console\u0026#34;, CONSOLE, 0); open(\u0026#34;console\u0026#34;, O_RDWR); } dup(0); // stdout dup(0); // stderr for(;;){ printf(\u0026#34;init: starting sh\\n\u0026#34;); pid = fork(); if(pid \u0026lt; 0){ printf(\u0026#34;init: fork failed\\n\u0026#34;); exit(1); } if(pid == 0){ exec(\u0026#34;sh\u0026#34;, argv); printf(\u0026#34;init: exec sh failed\\n\u0026#34;); exit(1); } for(;;){ // this call to wait() returns if the shell exits, // or if a parentless process exits. wpid = wait((int *) 0); if(wpid == pid){ // the shell exited; restart it. break; } else if(wpid \u0026lt; 0){ printf(\u0026#34;init: wait returned an error\\n\u0026#34;); exit(1); } else { // it was a parentless process; do nothing. } } } } å¼•ç”¨æŒ‡å¯¼ä¹¦çš„è¯ï¼Œinitç¨‹åºå¹²çš„äº‹ä¸º\nInit (user/init.c:15) creates a new console device fifile if needed and then opens it as fifile descriptors 0, 1, and 2. Then it starts a shell on the console. The system is up.\nxv6å¤§è‡´çš„å¯åŠ¨æµç¨‹åˆ°æ­¤ç»“æŸï¼Œå…¶å®è¿˜æ˜¯æ¯”è¾ƒæ¨¡ç³Šçš„ï¼Œç»†èŠ‚åº”è¯¥ä¼šåœ¨åé¢çš„å®éªŒé€æ¸å±•å¼€ \u0026hellip; å§ğŸ¤£\nç³»ç»Ÿè°ƒç”¨ åœ¨å®éªŒæŒ‡å¯¼ç½‘ç«™ä¸­è¿˜æåˆ°è¦çœ‹æŒ‡å¯¼ä¹¦çš„4.3å’Œ4.4èŠ‚ï¼Œè¿™ä¸¤èŠ‚è±¡å¾æ€§çš„è®²äº†ä¸‹ç³»ç»Ÿè°ƒç”¨ç›¸å…³çš„ä»£ç ï¼Œç»†èŠ‚ä¸è¡¨ï¼Œå¤§æ¦‚æµç¨‹åœ¨æœ¬èŠ‚ç²—ç•¥çš„è§£é‡Šä¸€ä¸‹ã€‚\né¦–å…ˆåœ¨ä¸Šä¸€èŠ‚ä¸­å…¶å®çœ‹åˆ°äº†æ±‡ç¼–å¦‚ä½•è°ƒç”¨execç³»ç»Ÿè°ƒç”¨çš„ï¼Œå¦‚ä¸‹\n1 2 3 4 la a0, init la a1, argv li a7, SYS_exec ecall riscvå†…æœ‰a0-a7è¿™å‡ ä¸ªå¯„å­˜å™¨ï¼ˆæŒ‰ç…§æƒ¯ä¾‹ï¼‰ç”¨äºä¼ é€’å‚æ•°(aå°±æ˜¯arg)ï¼Œexecéœ€è¦ä¸¤ä¸ªå‚æ•°ï¼Œè¿™ä¸¤ä¸ªå‚æ•°åˆ†åˆ«å­˜å…¥a0,a1ä¸­ï¼Œa7ç”¨äºå­˜æ”¾ç³»ç»Ÿè°ƒç”¨å·ã€‚ecallæŒ‡ä»¤ä¼šé™·å…¥å†…æ ¸(å…·ä½“å“ªé‡Œä»¥ååº”è¯¥ä¼šçŸ¥é“çš„)ï¼Œé™·å…¥å†…æ ¸åä¾æ¬¡æ‰§è¡Œuservecã€usertrapç„¶åæ˜¯syscallï¼Œæœ€åè¿™ä¸ªsyscallå‡½æ•°çœŸæ­£è°ƒç”¨äº†ç³»ç»Ÿè°ƒç”¨ã€‚è¯¥å‡½æ•°è§kernel/syscall.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void syscall(void) { int num; struct proc *p = myproc(); num = p-\u0026gt;trapframe-\u0026gt;a7; if(num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt; NELEM(syscalls) \u0026amp;\u0026amp; syscalls[num]) { p-\u0026gt;trapframe-\u0026gt;a0 = syscalls[num](); } else { printf(\u0026#34;%d %s: unknown sys call %d\\n\u0026#34;, p-\u0026gt;pid, p-\u0026gt;name, num); p-\u0026gt;trapframe-\u0026gt;a0 = -1; } } å…ˆæ³¨æ„ä¸Šé¢çš„myprocï¼Œè¯¥å‡½æ•°è¿”å›ä¸€ä¸ªè¿›ç¨‹(ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨çš„è¿›ç¨‹)ç›¸å…³çš„ç»“æ„ä½“(åº”è¯¥å°±æ˜¯ç†è®ºå­¦ä¹ ä¸­çš„PCBäº†å§)ï¼Œè¯¥ç»“æ„ä½“å®šä¹‰å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Per-process state struct proc { struct spinlock lock; // p-\u0026gt;lock must be held when using these: enum procstate state; // Process state struct proc *parent; // Parent process void *chan; // If non-zero, sleeping on chan int killed; // If non-zero, have been killed int xstate; // Exit status to be returned to parent\u0026#39;s wait int pid; // Process ID // these are private to the process, so p-\u0026gt;lock need not be held. uint64 kstack; // Virtual address of kernel stack uint64 sz; // Size of process memory (bytes) pagetable_t pagetable; // User page table struct trapframe *trapframe; // data page for trampoline.S struct context context; // swtch() here to run process struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory char name[16]; // Process name (debugging) }; ä¸Šé¢ç»“æ„ä¸­çš„trapframeå­˜ç€è¯¥è¿›ç¨‹çš„å¯„å­˜å™¨çŠ¶æ€å’Œå…¶ä»–ä¸€äº›ä¿¡æ¯ï¼Œåœ¨å›è¿‡å¤´æ¥çœ‹syscallä¸­çš„å¦‚ä¸‹ä»£ç \n1 2 3 4 5 6 7 int num; struct proc *p = myproc(); num = p-\u0026gt;trapframe-\u0026gt;a7; // a7å­˜çš„æ˜¯è°ƒç”¨å·ï¼Œå¦‚å‰é¢æ±‡ç¼–è¯­è¨€è°ƒç”¨ç³»ç»Ÿè°ƒç”¨æ‰€ç¤º if(num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt; NELEM(syscalls) \u0026amp;\u0026amp; syscalls[num]) { // è°ƒç”¨å·æ»¡è¶³ä¸€å®šæ¡ä»¶æ‰èƒ½è°ƒç”¨ç³»ç»Ÿè°ƒç”¨ p-\u0026gt;trapframe-\u0026gt;a0 = syscalls[num](); } è§£é‡Šè§æ³¨é‡Šï¼Œå†æ¥çœ‹çœ‹syscallsè¿™ä¸ªå˜é‡\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 static uint64 (*syscalls[])(void) = { [SYS_fork] sys_fork, [SYS_exit] sys_exit, [SYS_wait] sys_wait, [SYS_pipe] sys_pipe, [SYS_read] sys_read, [SYS_kill] sys_kill, [SYS_exec] sys_exec, [SYS_fstat] sys_fstat, [SYS_chdir] sys_chdir, [SYS_dup] sys_dup, [SYS_getpid] sys_getpid, [SYS_sbrk] sys_sbrk, [SYS_sleep] sys_sleep, [SYS_uptime] sys_uptime, [SYS_open] sys_open, [SYS_write] sys_write, [SYS_mknod] sys_mknod, [SYS_unlink] sys_unlink, [SYS_link] sys_link, [SYS_mkdir] sys_mkdir, [SYS_close] sys_close, }; è¿™æ˜¯ä¸€ä¸ªæŒ‡å‘å‡½æ•°çš„æŒ‡é’ˆçš„æ•°ç»„ï¼ŒæŒ‡å‘çš„å‡½æ•°å½¢å¦‚uint64 func_name(void )ï¼Œè¿™ä¸€æ®µä»£ç ç»™è¯¥æ•°ç»„è¿›è¡Œåˆå§‹åŒ–ï¼Œå…¶ä¸­sys_forkï¼Œsys_exitä¹‹ç±»çš„ä¸ºå…·ä½“çš„å‡½æ•°(å‡½æ•°å°±æ˜¯ä¸€å †æŒ‡ä»¤ï¼Œå‡½æ•°åå…¶å®å°±æ˜¯è¿™ä¸€å †æŒ‡ä»¤çš„é¦–åœ°å€)ï¼ŒSYS_forkä¹‹ç±»çš„è¡¨æ˜æ•°ç»„ä¸‹æ ‡ï¼Œè¿™äº›å®å®šä¹‰åœ¨syscall.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // System call numbers #define SYS_fork 1 #define SYS_exit 2 #define SYS_wait 3 #define SYS_pipe 4 #define SYS_read 5 #define SYS_kill 6 #define SYS_exec 7 #define SYS_fstat 8 #define SYS_chdir 9 #define SYS_dup 10 #define SYS_getpid 11 #define SYS_sbrk 12 #define SYS_sleep 13 #define SYS_uptime 14 #define SYS_open 15 #define SYS_write 16 #define SYS_mknod 17 #define SYS_unlink 18 #define SYS_link 19 #define SYS_mkdir 20 #define SYS_close 21 è·å–å‚æ•° ä¸Šé¢çœ‹åˆ°äº†ç³»ç»Ÿè°ƒç”¨çš„è¿‡ç¨‹ï¼Œsyscallå®é™…ä¸Šæ˜¯æ ¹æ®a7ä¸­çš„è°ƒç”¨å·æ¥é€‰æ‹©æŸä¸ªå…·ä½“çš„å®ç°ç³»ç»Ÿè°ƒç”¨çš„å‡½æ•°æ¥å®Œæˆç³»ç»Ÿè°ƒç”¨çš„ã€‚ä¸Šä¸€å°èŠ‚çœ‹åˆ°ï¼Œsyscallè°ƒç”¨çš„å‡½æ•°åŸå‹ä¸ºuint64 func_name(void)ï¼Œé‚£è¿™äº›å‡½æ•°å¦‚ä½•æ‹¿åˆ°ç”¨æˆ·ä¼ é€’çš„å‚æ•°å‘¢ï¼Ÿ\nå®é™…ä¸Šé€šè¿‡é™·å…¥ç³»ç»Ÿè°ƒç”¨çš„ä»£ç å°±å¯ä»¥çœ‹å‡ºæ¥äº†\n1 2 3 4 5 # è°ƒç”¨ exec(init,argv) la a0, init la a1, argv li a7, SYS_exec ecall å‚æ•°å­˜åœ¨äº†è¯¥è¿›ç¨‹çš„a0-a5å¯„å­˜å™¨ä¸­ï¼Œè€Œé€šè¿‡å‰æ–‡å¯ä»¥çœ‹åˆ°ï¼Œå¯ä»¥é€šè¿‡myprocæ‹¿åˆ°ç”¨æˆ·è¿›ç¨‹çš„PCBï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªstruct proc *ï¼Œè¯¥ç»“æ„å†…çš„trapframeå†…æœ‰ç”¨æˆ·è¿›ç¨‹çš„å¯„å­˜å™¨çŠ¶æ€ï¼Œæ¯”å¦‚execè¦æ‹¿åˆ°ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œåªéœ€è¦æ‹¿åˆ°a0å³å¯ï¼Œå¦‚ä¸‹\n1 2 3 struct proc *p = myproc(); p-\u0026gt;trapframe-\u0026gt;a0 // è¿™ä¸ªå€¼å°±æ˜¯ç¬¬ä¸€ä¸ªå‚æ•° åœ¨kernel/syscall.cä¸­å·²ç»ç»™æˆ‘ä»¬å°è£…å¥½äº†ç›¸å…³çš„å‡½æ•°ï¼Œå¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 static uint64 argraw(int n) { struct proc *p = myproc(); switch (n) { case 0: return p-\u0026gt;trapframe-\u0026gt;a0; case 1: return p-\u0026gt;trapframe-\u0026gt;a1; case 2: return p-\u0026gt;trapframe-\u0026gt;a2; case 3: return p-\u0026gt;trapframe-\u0026gt;a3; case 4: return p-\u0026gt;trapframe-\u0026gt;a4; case 5: return p-\u0026gt;trapframe-\u0026gt;a5; } panic(\u0026#34;argraw\u0026#34;); return -1; } å¯ä»¥çœ‹åˆ°ï¼Œè°ƒç”¨ argraw(n)å¯ä»¥æ‹¿åˆ°ç¬¬nä¸ªå‚æ•°ï¼Œä¹Ÿå°±æ˜¯anå¯„å­˜å™¨çš„å€¼ï¼Œåœ¨è¯¥æ–‡ä»¶ä¸­è¿˜è¿›ä¸€æ­¥å°è£…äº†å¦å¤–å‡ ä¸ªå‡½æ•°\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Fetch the nth 32-bit system call argument. int argint(int n, int *ip) // è·å–æ•´æ•°ç±»å‹çš„å‚æ•° { *ip = argraw(n); return 0; } // Retrieve an argument as a pointer. // Doesn\u0026#39;t check for legality, since // copyin/copyout will do that. int argaddr(int n, uint64 *ip) // è·å–åœ°å€(æŒ‡é’ˆç±»å‹çš„å‚æ•°) { *ip = argraw(n); return 0; } // Fetch the nth word-sized system call argument as a null-terminated string. // Copies into buf, at most max. // Returns string length if OK (including nul), -1 if error. int argstr(int n, char *buf, int max) // è·å–å­—ç¬¦ä¸²ç±»å‹çš„å‚æ•° { uint64 addr; if(argaddr(n, \u0026amp;addr) \u0026lt; 0) return -1; // fetchstr ä»ç”¨æˆ·æ€çš„åœ°å€å¤„å°†å­—ç¬¦ä¸²å–å‡ºå¤åˆ¶åˆ°å†…æ ¸æ€ä¸­çš„bufå†… å†…æ ¸æ€å’Œç”¨æˆ·æ€ // çš„åœ°å€ç©ºé—´ä¸ä¸€æ ·(é¡µè¡¨ä¸åŒ) return fetchstr(addr, buf, max); } å…·ä½“åŠŸèƒ½è§æ³¨é‡Šã€‚\nç”¨æˆ·æ€stub ä½œä¸ºç”¨æˆ·ï¼Œå¦‚æœå¸Œæœ›è¿›è¡Œç³»ç»Ÿè°ƒç”¨ï¼Œè‚¯å®šä¸å¸Œæœ›å†™æ±‡ç¼–æ¥è°ƒç”¨ï¼Œé‚£ä¹ˆåœ¨ç”¨æˆ·æ€ä¸‹éœ€è¦å°è£…ä¸€å±‚å‡½æ•°æ¥é™·å…¥å†…æ ¸è¿›è¡Œç³»ç»Ÿè°ƒç”¨ï¼Œå¦‚ç”¨æˆ·å¸Œæœ›è°ƒç”¨æ–‡ä»¶ç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨åªéœ€æŒ‰ç…§ä¸‹é¢çš„ä»£ç ä¹¦å†™\n1 2 3 fd = open(\u0026#34;hello.txt\u0026#34;,O_CREAT|O_WRONLY); write(fd,\u0026#34;Hello,xv6!\u0026#34;,10); é‚£ä¹ˆä¸Šé¢è¿™äº›openã€writeçš„ä»£ç ç©¶ç«Ÿåœ¨å“ªé‡Œå‘¢ï¼Ÿè¿™äº›ä»£ç è¯¦è§user/usys.Sï¼Œæˆªå–è¿™ä¸¤ä¸ªå‡½æ•°ä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 .global open open: li a7, SYS_open ecall ret .global write write: li a7, SYS_write ecall ret åœ¨ç”¨æˆ·æ€ç¼–å†™ä»£ç func(a,b,c)æ—¶ï¼Œå…¶å®å°±æ˜¯å°†a,b,cçš„å€¼è£…å…¥a0,a1,a2å¯„å­˜å™¨ï¼Œç„¶åå°†ä¸‹ä¸€è·³æŒ‡ä»¤åœ°å€ä¿å­˜åœ¨raå¯„å­˜å™¨ï¼Œç„¶åè·³è½¬åˆ°funcåœ°å€å¤„æ‰§è¡Œï¼Œä¸Šé¢çš„openå’Œwriteå‡½æ•°åªéœ€è¦å‘a7å¯„å­˜å™¨è£…å…¥è°ƒç”¨å·ï¼Œå†ç”¨ecallå°±å¯ä»¥é™·å…¥å†…æ ¸è¿›è¡Œç³»ç»Ÿè°ƒç”¨äº†ã€‚\nå¯ä»¥çœ‹è§è¿™äº›ä»£ç éƒ½éå¸¸çš„ä¸€è‡´ï¼Œè‡ªå·±æ‰‹å†™æ˜¾å¾—å¤ªå‚»äº†ï¼Œæ•…xv6æºç ä¸­ç”¨usys.plè¿™ä¸ªperlè„šæœ¬è‡ªåŠ¨ç”Ÿæˆusys.Sï¼Œè¯¥è„šæœ¬å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/usr/bin/perl -w # Generate usys.S, the stubs for syscalls. print \u0026#34;# generated by usys.pl - do not edit\\n\u0026#34;; print \u0026#34;#include \\\u0026#34;kernel/syscall.h\\\u0026#34;\\n\u0026#34;; sub entry { my $name = shift; print \u0026#34;.global $name\\n\u0026#34;; print \u0026#34;${name}:\\n\u0026#34;; print \u0026#34; li a7, SYS_${name}\\n\u0026#34;; print \u0026#34; ecall\\n\u0026#34;; print \u0026#34; ret\\n\u0026#34;; } entry(\u0026#34;fork\u0026#34;); entry(\u0026#34;exit\u0026#34;); ... # æ¯ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨å†™ä¸€ä¸ªentry(\u0026#34;syscall_name\u0026#34;)å³å¯ åˆ°è¿™é‡Œå°±åŸºæœ¬çŸ¥é“ç³»ç»Ÿè°ƒç”¨æ˜¯æ€ä¹ˆå›äº‹äº†ï¼Œè™½ç„¶å…·ä½“ç»†èŠ‚ä¸å¤ªæ¸…æ¥šï¼Œä½†çŸ¥é“ä¸ªå¤§æ¦‚æµç¨‹å°±å¯ä»¥å¼€å§‹åšæœ¬æ¬¡å®éªŒäº†ã€‚\nç”¨æˆ·æ€å’Œå†…æ ¸æ€æ•°æ®ä¼ è¾“ ç”±äºç”¨æˆ·æ€å’Œå†…æ ¸æ€åœ°å€ç©ºé—´ä¸ä¸€æ ·ï¼Œæ•…ä¸èƒ½ç®€å•çš„é€šè¿‡åœ°å€æ¥ä¼ å…¥æˆ–ä¼ å‡ºæ•°æ®ï¼Œæ¥çœ‹çœ‹fstatç³»ç»Ÿè°ƒç”¨å¦‚ä½•ä¼ å‡ºstruct statç»“æ„ä½“åˆ°ç”¨æˆ·æ€ï¼Œçœ‹å…¶æºç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 uint64 sys_fstat(void) { struct file *f; uint64 st; // user pointer to struct stat if(argfd(0, 0, \u0026amp;f) \u0026lt; 0 || argaddr(1, \u0026amp;st) \u0026lt; 0) // è¿™é‡Œè°ƒç”¨argaddr(1,\u0026amp;st)åï¼Œstå³å­˜ç€ç”¨æˆ·ä¼ å…¥çš„struct stat*æŒ‡é’ˆçš„å€¼ return -1; return filestat(f, st); } å†çœ‹çœ‹filestatçš„å®ç°\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Get metadata about file f. // addr is a user virtual address, pointing to a struct stat. int filestat(struct file *f, uint64 addr) { struct proc *p = myproc(); struct stat st; if(f-\u0026gt;type == FD_INODE || f-\u0026gt;type == FD_DEVICE){ ilock(f-\u0026gt;ip); stati(f-\u0026gt;ip, \u0026amp;st); iunlock(f-\u0026gt;ip); if(copyout(p-\u0026gt;pagetable, addr, (char *)\u0026amp;st, sizeof(st)) \u0026lt; 0) // æ³¨æ„è¿™é‡Œå°†å†…æ ¸æ€çš„ç»“æ„å¤åˆ¶åˆ°ç”¨æˆ·æ€çš„åœ°å€å¤„ return -1; return 0; } return -1; } å¯ä»¥çœ‹åˆ°éœ€è¦é€šè¿‡copyoutå‡½æ•°æ¥å°†å†…æ ¸åœ°å€ç©ºé—´çš„æ•°æ®å¤åˆ¶åˆ°ç”¨æˆ·çš„åœ°å€ç©ºé—´ï¼Œå…¶ä¸­ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ç”¨æˆ·è¿›ç¨‹çš„é¡µè¡¨ã€‚\nå®éªŒ trace çœ‹çœ‹å®éªŒè¦åšä»€ä¹ˆ\nIn this assignment you will add a system call tracing feature that may help you when debugging later labs. You\u0026rsquo;ll create a new trace system call that will control tracing. It should take one argument, an integer \u0026ldquo;mask\u0026rdquo;, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls trace(1 \u0026lt;\u0026lt; SYS_fork), where SYS_fork is a syscall number from kernel/syscall.h. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call\u0026rsquo;s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don\u0026rsquo;t need to print the system call arguments. The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.\nå®éªŒåº”è¯¥è¾¾åˆ°çš„æ•ˆæœ\n1 2 3 4 5 $ trace 32 grep hello README # 32 å°±æ˜¯ 1 \u0026lt;\u0026lt; SYS_read 3: syscall read -\u0026gt; 1023 3: syscall read -\u0026gt; 966 3: syscall read -\u0026gt; 70 3: syscall read -\u0026gt; 0 æœ‰äº†å‰æ–‡çš„åŸºç¡€ï¼Œè¿™ä¸ªå®éªŒå…¶å®å¾ˆç®€å•ï¼Œé¦–å…ˆè¦æ‰¾ä¸ªåœ°æ–¹è®°å½•æŸä¸ªè¿›ç¨‹è¦traceçš„ç³»ç»Ÿè°ƒç”¨ï¼Œæ˜¾ç„¶åœ¨PCBå³struct procä¸­è®°å½•è¿™ä¸ªmaskæ¯”è¾ƒå¥½ï¼Œåœ¨è¯¥ç»“æ„ä¸­æ·»åŠ ä¸€ä¸ªmaskå­—æ®µå¦‚ä¸‹\n1 2 3 4 5 6 // Per-process state struct proc { ... // for syscall trace int trace_mask; // save the trace mask for a process }; é‚£ä¹ˆæ·»åŠ çš„ç³»ç»Ÿè°ƒç”¨åŠŸèƒ½å°±æ˜¯è®¾ç½®è¿›ç¨‹çš„trace_maskï¼Œåœ¨sysproc.cä¸­æ·»åŠ å¦‚ä¸‹ç³»ç»Ÿè°ƒç”¨å‡½æ•°å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 uint64 sys_trace(void) { struct proc *p = myproc(); int mask; argint(0,\u0026amp;mask); // get the mask argment p-\u0026gt;trace_mask = mask; // save the trace mask return 0; } åœ¨syscall.hä¸­æ·»åŠ ç³»ç»Ÿè°ƒç”¨å·ï¼Œå¦‚ä¸‹\n1 2 3 4 5 // System call numbers ... // added system call #define SYS_trace 22 æ¥ç€ä¿®æ”¹syscall.cä¸­çš„ç³»ç»Ÿè°ƒç”¨è¡¨ï¼Œæ·»åŠ ä¸€æ¡å¦‚ä¸‹\n1 2 3 4 5 6 7 8 // added system call extern uint64 sys_trace(void); // declaration static uint64 (*syscalls[])(void) = { ... // added syscall [SYS_trace] sys_trace, // æ·»åŠ ä¸€æ¡ç³»ç»Ÿè°ƒç”¨ }; ä¸ºäº†åœ¨è°ƒç”¨ç³»ç»Ÿè°ƒç”¨æ—¶è¾“å‡ºç›¸å…³ä¿¡æ¯ï¼Œä»”ç»†æƒ³æƒ³ï¼Œæ¯ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨éƒ½è¦ç»è¿‡syscallï¼Œé‚£ä¹ˆå¯ä»¥ä¿®æ”¹syscallï¼Œåœ¨ç³»ç»Ÿè°ƒç”¨åè¾“å‡ºtraceçš„ä¿¡æ¯ï¼Œä¿®æ”¹è¯¥å‡½æ•°å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // è®°å½•ç³»ç»Ÿè°ƒç”¨åå­— static char *syscalls_names[] = { \u0026#34;none\u0026#34;,\u0026#34;fork\u0026#34;,\u0026#34;exit\u0026#34;,\u0026#34;wait\u0026#34;,\u0026#34;pipe\u0026#34;,\u0026#34;read\u0026#34;,\u0026#34;kill\u0026#34;,\u0026#34;exec\u0026#34;,\u0026#34;fstat\u0026#34;,\u0026#34;chdir\u0026#34;,\u0026#34;dup\u0026#34;,\u0026#34;getpid\u0026#34;,\u0026#34;sbrk\u0026#34;, \u0026#34;sleep\u0026#34;,\u0026#34;uptime\u0026#34;,\u0026#34;open\u0026#34;,\u0026#34;write\u0026#34;,\u0026#34;mknod\u0026#34;,\u0026#34;unlink\u0026#34;,\u0026#34;link\u0026#34;,\u0026#34;mkdir\u0026#34;,\u0026#34;close\u0026#34;,\u0026#34;trace\u0026#34;,\u0026#34;sysinfo\u0026#34; }; void syscall(void) { int num; struct proc *p = myproc(); num = p-\u0026gt;trapframe-\u0026gt;a7; if(num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt; NELEM(syscalls) \u0026amp;\u0026amp; syscalls[num]) { p-\u0026gt;trapframe-\u0026gt;a0 = syscalls[num](); // a0 ä¸­å­˜ç€è¿”å›å€¼ if((p-\u0026gt;trace_mask \u0026amp; (1 \u0026lt;\u0026lt; num)) != 0){ // it is a traced system call // å¦‚æœè¯¥ç³»ç»Ÿè°ƒç”¨çš„maskè®¾ç½®è¿‡äº†ï¼Œåˆ™è¾“å‡ºä¿¡æ¯ printf(\u0026#34;%d: syscall %s -\u0026gt; %d\\n\u0026#34;,p-\u0026gt;pid,syscalls_names[num],p-\u0026gt;trapframe-\u0026gt;a0); } } else { printf(\u0026#34;%d %s: unknown sys call %d\\n\u0026#34;, p-\u0026gt;pid, p-\u0026gt;name, num); p-\u0026gt;trapframe-\u0026gt;a0 = -1; } } æ³¨æ„æŒ‰ç…§ä»»åŠ¡è¦æ±‚ï¼Œå¦‚æœä¸€ä¸ªè¿›ç¨‹traceæŸäº›ç³»ç»Ÿè°ƒç”¨ï¼Œé‚£ä¹ˆè¯¥è¿›è¡Œforkå‡ºæ¥çš„å­è¿›ç¨‹ä¹Ÿè¦traceè¿™äº›ç³»ç»Ÿè°ƒç”¨ï¼Œforkç³»ç»Ÿè°ƒç”¨ä»£ç å¦‚ä¸‹\n1 2 3 4 5 uint64 sys_fork(void) { return fork(); } æŸ¥çœ‹è¿™ä¸ªforkå‡½æ•°ä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // Create a new process, copying the parent. // Sets up child kernel stack to return as if from fork() system call. int fork(void) { int i, pid; struct proc *np; struct proc *p = myproc(); // Allocate process. if((np = allocproc()) == 0){ return -1; } // Copy user memory from parent to child. if(uvmcopy(p-\u0026gt;pagetable, np-\u0026gt;pagetable, p-\u0026gt;sz) \u0026lt; 0){ freeproc(np); release(\u0026amp;np-\u0026gt;lock); return -1; } np-\u0026gt;sz = p-\u0026gt;sz; np-\u0026gt;parent = p; // copy saved user registers. *(np-\u0026gt;trapframe) = *(p-\u0026gt;trapframe); // Cause fork to return 0 in the child. np-\u0026gt;trapframe-\u0026gt;a0 = 0; // increment reference counts on open file descriptors. for(i = 0; i \u0026lt; NOFILE; i++) if(p-\u0026gt;ofile[i]) np-\u0026gt;ofile[i] = filedup(p-\u0026gt;ofile[i]); np-\u0026gt;cwd = idup(p-\u0026gt;cwd); safestrcpy(np-\u0026gt;name, p-\u0026gt;name, sizeof(p-\u0026gt;name)); pid = np-\u0026gt;pid; np-\u0026gt;state = RUNNABLE; release(\u0026amp;np-\u0026gt;lock); return pid; } å…·ä½“ç»†èŠ‚ä¸è°ˆï¼Œä½†ä»ä¸Šé¢çš„ä»£ç å¯ä»¥çœ‹å‡ºï¼Œpæ˜¯å½“å‰è¿›ç¨‹PCBï¼Œnpæ˜¯forkå‡ºæ¥çš„ï¼Œæ–°çš„è¿›ç¨‹çš„PCBï¼Œè¯¥å‡½æ•°å°±æ˜¯åœ¨æ‰§è¡Œå¤åˆ¶è¿›ç¨‹çš„å·¥ä½œã€‚ä¸ºäº†è®©å­è¿›ç¨‹å¯ä»¥traceå’Œçˆ¶è¿›ç¨‹åŒæ ·çš„ç³»ç»Ÿè°ƒç”¨ï¼Œéœ€è¦å°†çˆ¶è¿›ç¨‹çš„trace_maskä¹Ÿå¤åˆ¶ä¸€ä¸‹ï¼Œæ·»åŠ ä¸€è¡Œä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 // Create a new process, copying the parent. // Sets up child kernel stack to return as if from fork() system call. int fork(void) { ... // copy trace mask np-\u0026gt;trace_mask = p-\u0026gt;trace_mask; ... return pid; } è‡³æ­¤å®Œæˆäº†æ·»åŠ å‡½æ•°è°ƒç”¨çš„ä»»åŠ¡ï¼Œæ¥ä¸‹æ¥è¿˜éœ€è¦ç»™ç”¨æˆ·å¢åŠ æ¥å£ï¼Œæ•…åœ¨usys.plä¸­æœ«å°¾æ·»åŠ ä»£ç å¦‚ä¸‹(ä½œç”¨è§ ç”¨æˆ·æ€stub é‚£ä¸€å°èŠ‚)\n1 2 3 ... # added system call entry(\u0026#34;trace\u0026#34;); åœ¨å¤´æ–‡ä»¶user/user.hä¸­æ·»åŠ è¯¥ç³»ç»Ÿè°ƒç”¨åŸå‹å¦‚ä¸‹\n1 2 // added system call int trace(int mask); ä¸€åˆ‡å®Œæˆåæµ‹è¯•èƒ½å¦é€šè¿‡æµ‹è¯•ï¼Œå¦‚ä¸‹\nsysinfo ç¬¬äºŒä¸ªæ·»åŠ çš„ç³»ç»Ÿè°ƒç”¨æ ¹æ®å®éªŒæŒ‡å¯¼ä¹¦æè¿°å¦‚ä¸‹\nIn this assignment you will add a system call, sysinfo, that collects information about the running system. The system call takes one argument: a pointer to a struct sysinfo (see kernel/sysinfo.h). The kernel should fill out the fields of this struct: the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED. We provide a test program sysinfotest; you pass this assignment if it prints \u0026ldquo;sysinfotest: OK\u0026rdquo;.\nå¯ä»¥çœ‹åˆ°ï¼Œsysinfoç³»ç»Ÿè°ƒç”¨è¦æ±‚ç»™ç”¨æˆ·è¿”å›å¦‚ä¸‹ç»“æ„\n1 2 3 4 struct sysinfo { uint64 freemem; // amount of free memory (bytes) uint64 nproc; // number of process }; æŒ‡å¯¼ä¹¦ä¸Šæ¯”è¾ƒå…³é”®çš„å‡ å¥æç¤ºå¦‚ä¸‹\nsysinfo needs to copy a struct sysinfo back to user space; see sys_fstat() (kernel/sysfile.c) and filestat() (kernel/file.c) for examples of how to do that using copyout(). To collect the amount of free memory, add a function to kernel/kalloc.c To collect the number of processes, add a function to kernel/proc.c å…¶ä¸­ç¬¬ä¸€ç‚¹åœ¨å‰æ–‡ä¸­æœ‰æ‰€æè¿°ã€‚\nä½†éå¸¸ç¾æ„§çš„æ˜¯ï¼Œç¬¬äºŒç¬¬ä¸‰ç‚¹ï¼Œé“ç†æˆ‘éƒ½æ‡‚ï¼Œå¯æ˜¯å…³äºxv6æˆ‘è¿˜ä¸€æ— æ‰€çŸ¥ï¼Œæˆ‘æ€ä¹ˆçŸ¥é“æ€ä¹ˆè·å–ç³»ç»Ÿè¿›ç¨‹æ•°å’Œç©ºé—²å†…å­˜å‘€ğŸ˜…ï¼Œä¹Ÿæ²¡æœ‰ä¸€ç‚¹æç¤ºï¼Œè¿˜æ²¡çœ‹åˆ°xv6çš„å†…å­˜ç®¡ç†å’Œè¿›ç¨‹è°ƒåº¦å‘¢ğŸ¤¡\næ— å¥ˆç¨å¾®åœ¨ç½‘ä¸ŠæŸ¥äº†ä¸€ä¸‹ğŸ™ƒï¼Œç¼–å†™è·å–ç©ºé—²å†…å­˜çš„ä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // kalloc.c struct run { struct run *next; }; struct { struct spinlock lock; struct run *freelist; } kmem; // return number of free bytes uint64 free_bytes(){ struct run *p = kmem.freelist; uint64 num_of_free_page = 0; while(p){ num_of_free_page ++; p = p-\u0026gt;next; } return num_of_free_page * PGSIZE; } ä¸Šé¢ä»£ç ä¸­çš„kmemç”¨äºç®¡ç†å†…å­˜ï¼Œè¯¥ç»“æ„å†…æœ‰ä¸€ä¸ªlockå’Œfreelistï¼Œé¡¾åæ€ä¹‰freeliståº”è¯¥å°±æ˜¯ä¸²èµ·ç©ºé—²é¡µçš„ç»“æ„(ç°å¸¸å¥‡æ€ªï¼Œè¿™ä¸ªé“¾è¡¨èŠ‚ç‚¹struct runä¸ºæ¯›åªæœ‰ä¸€ä¸ªæŒ‡é’ˆ\u0026hellip;)ï¼Œä½†æ€»ä¹‹å…ˆè¿™æ ·å§ï¼Œåé¢åšå†…å­˜ç®¡ç†æ—¶ä¼šçŸ¥é“æ€ä¹ˆå›äº‹çš„ğŸ¤£\nä¸Šé¢ä»£ç çš„free_byteså³è·å–ç©ºé—²å†…å­˜å­—èŠ‚æ•°çš„å‡½æ•°ã€‚\næ¥ä¸‹æ¥å†çœ‹çœ‹æ€ä¹ˆè·å–ç³»ç»Ÿè¿›ç¨‹æ•°ç›®ï¼Œä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 struct proc proc[NPROC]; // get the number of process uint64 num_proc(){ uint64 sum = 0; for(int i = 0;i \u0026lt; NPROC;i ++) if(proc[i].state != UNUSED) sum ++; return sum; } ä¸Šé¢ä»£ç ä¸­çš„procç»“æ„ä½“å°±æ˜¯å­˜æ‰€æœ‰è¿›ç¨‹çš„çŠ¶æ€çš„ï¼Œstruct procè¿™ä¸ªç»“æ„ä½“åœ¨å‰æ–‡ä¹Ÿçœ‹åˆ°è¿‡ï¼Œå†æ¬¡å±•ç¤ºå¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 enum procstate { UNUSED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE }; // Per-process state struct proc { struct spinlock lock; // p-\u0026gt;lock must be held when using these: enum procstate state; // Process state struct proc *parent; // Parent process void *chan; // If non-zero, sleeping on chan int killed; // If non-zero, have been killed int xstate; // Exit status to be returned to parent\u0026#39;s wait int pid; // Process ID // these are private to the process, so p-\u0026gt;lock need not be held. uint64 kstack; // Virtual address of kernel stack uint64 sz; // Size of process memory (bytes) pagetable_t pagetable; // User page table struct trapframe *trapframe; // data page for trampoline.S struct context context; // swtch() here to run process struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory char name[16]; // Process name (debugging) // for syscall trace int trace_mask; }; å…¶ä¸­stateä¸ºè¿›ç¨‹çŠ¶æ€ï¼ŒUNUSEDè¡¨ç¤ºprocæ•°ç»„ä¸­è¯¥é¡¹è¿˜æœªè¢«ä½¿ç”¨ï¼Œæ•…è¦å¾—åˆ°è¿›ç¨‹æ•°ï¼Œåªéœ€è¦éå†procæ•°ç»„ï¼Œçœ‹çœ‹ä¸æ˜¯UNUSEDçš„æœ‰å¤šå°‘ä¸ªå³å¯ï¼Œå…·ä½“ä»£ç è§ä¸Šé¢çš„num_proc.\nå†™äº†num_procå’Œfree_bytesè¿™ä¿©å‡½æ•°åï¼Œæ¥ç€å°±å¾ˆå®¹æ˜“ç¼–å†™æˆ‘ä»¬çš„ç³»ç»Ÿè°ƒç”¨äº†ï¼Œåœ¨kernel/sysproc.cæ·»åŠ å¦‚ä¸‹ç³»ç»Ÿè°ƒç”¨ä»£ç \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 uint64 sys_sysinfo(void) { uint64 info; // user pointer to struct sysinfo struct sysinfo si; struct proc *p = myproc(); uint64 num_proc(); uint64 free_bytes(); si.freemem = free_bytes(); si.nproc = num_proc(); argaddr(0,\u0026amp;info); // get user\u0026#39;s pointer to struct sysinfo if(copyout(p-\u0026gt;pagetable,info,(char *)\u0026amp;si,sizeof(si)) \u0026lt; 0) // use copyout to copy si to user address space return -1; return 0; } å…¶ä»–æ“ä½œåœ¨æ­¤ç•¥è¿‡ï¼Œè¯¦è§ä¸Šä¸€å°èŠ‚ï¼ˆå¦‚æ·»åŠ ç³»ç»Ÿè°ƒç”¨å·ï¼Œä¿®æ”¹syscall.cç­‰ç­‰ï¼‰.\nå°¾å£° è¿™ä¸ªç³»åˆ—å¯è°“æ˜¯å†™ä¸€ç¯‡å°‘ä¸€ç¯‡å•¦ğŸ˜†\nå¯æŒ‡ä¸å‡†å•¥æ—¶å€™å°±â€œä¸­é“å´©æ®‚â€äº†ï¼Œä¸è¿‡ä¸ç®¡æ€ä¹ˆè¯´ï¼Œå‰ä¸¤ä¸ªå®éªŒåšå®Œå•¦ï¼\nè¿™ä¸¤ä¸ªå®éªŒéƒ½åªæ˜¯æ‘¸æ‘¸xv6çš„è¡¨é¢ï¼Œä¸‹ä¸€ä¸ªå®éªŒç»ˆäºæ­£å¼å’Œæ“ä½œç³»ç»Ÿç›¸å…³å•¦ï¼è¿›å…¥å†…å­˜ç®¡ç†é˜¶æ®µï¼ï¼\n","date":"2023-01-06T22:37:47+08:00","image":"https://XieWeikai.github.io/aniya_blog/p/lab2-system-calls/cover_hu7ace472778f385b50e7c8f287dbb6c46_2544271_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/lab2-system-calls/","title":"lab2: system calls"},{"content":"xv6 util lab åœ¨é—²æš‡ä¹‹ä½™ï¼ŒæŠ½å‡ºäº†ä¸€éƒ¨åˆ†æ—¶é—´çœ‹äº†çœ‹MIT 6.S081è¯¾ç¨‹çš„å®éªŒä¸€ï¼Œè¿™ä¸ªå®éªŒå¯èƒ½ä¹Ÿè®¸æ˜¯æœ€ç®€å•çš„ä¸€ä¸ªå®éªŒäº†å§ï¼Œå®Œå…¨æ²¡æœ‰æ¶‰åŠåˆ°æ“ä½œç³»ç»Ÿå†…éƒ¨åŸç†ç›¸å…³çš„çŸ¥è¯†ï¼Œåªæ˜¯ç”¨xv6çš„ç³»ç»Ÿè°ƒç”¨ç¼–å†™ç”¨æˆ·æ€çš„ç¨‹åºã€‚æˆ‘ä¹Ÿä¸çŸ¥é“èŠ±äº†ä¸çŸ¥é“å¤šä¹…ï¼Œæ–­æ–­ç»­ç»­çš„æŠŠå®éªŒä¸€å¹²å®Œäº†ã€‚è¯¥å®éªŒçš„å®éªŒè¦æ±‚è§ https://pdos.csail.mit.edu/6.828/2020/labs/util.html.\nå‡†å¤‡ ç¼–è¯‘å¹¶ä½¿ç”¨qemuæ¨¡æ‹Ÿå¯åŠ¨æ“ä½œç³»ç»Ÿæ–¹æ³•ä¸º\n1 make qemu æ‰“åˆ†æµ‹è¯•çš„å‘½ä»¤å¦‚ä¸‹\n1 make grade æµ‹è¯•æŸä¸ªå…·ä½“çš„ç”¨ä¾‹ï¼Œå¦‚æµ‹è¯•sleepï¼Œæ–¹æ³•æœ‰ä¸¤ç§\n1 2 ./grade-lab-util sleep # ç¬¬ä¸€ç§æ–¹æ³• make GRADEFLAGS=sleep grade # ç¬¬äºŒç§æ–¹æ³• sleep è¯¥ä»»åŠ¡éå¸¸ç®€å•ï¼Œå†™ä¸€ä¸ªsleepç¨‹åºï¼Œèƒ½é€šè¿‡å‘½ä»¤è¡Œå‚æ•°æŒ‡å®šsleepçš„tickæ•°(tickæŒ‡ä¸€ä¸ªæ—¶é’Ÿå‘¨æœŸ)ã€‚ç¨‹åºéå¸¸ç®€å•ï¼Œåœ¨userç›®å½•ä¸‹æ–°å»ºæ–‡ä»¶sleep.cï¼Œç¼–å†™ä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; int main(int argc, char *argv[]) { if(argc \u0026lt;= 1){ write(1,\u0026#34;error: no input from user !\\n\u0026#34;,28); exit(-1); } sleep(atoi(argv[1])); // sleep ä¸ºç³»ç»Ÿè°ƒç”¨ å‚æ•°ä¸ºtickæ•°ï¼Œå°†å‘½ä»¤è¡Œå‚æ•°é€šè¿‡atoiè½¬ä¸ºæ•´æ•°å³å¯ exit(0); } ç¼–å†™å®Œæˆåè¿˜éœ€è¦ä¿®æ”¹Makefileä¸­çš„UPROGS(è¿™åº”è¯¥æ˜¯user programsçš„æ„æ€)ï¼Œæ·»åŠ sleepï¼Œå¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 U=user # ç”¨æˆ·æ€ç¨‹åºç›®å½• UPROGS=\\ $U/_cat\\ $U/_echo\\ $U/_forktest\\ $U/_grep\\ $U/_init\\ $U/_kill\\ $U/_ln\\ $U/_ls\\ $U/_mkdir\\ $U/_rm\\ $U/_sh\\ $U/_stressfs\\ $U/_usertests\\ $U/_grind\\ $U/_wc\\ $U/_zombie\\ $U/_sleep # è¿™æ˜¯æ·»åŠ çš„ä¸€è¡Œå†…å®¹ ä¿®æ”¹åmake qemuè¿›å…¥xv6ç³»ç»Ÿå¯ä»¥çœ‹åˆ°å¤šå‡ºäº†ä¸€ä¸ªsleepç¨‹åºã€‚è¯¥ç¨‹åºèƒ½é€šè¿‡æ‰“åˆ†ç¨‹åºã€‚\npingpong è¿™ä¸ªä¹Ÿå¾ˆç®€å•ï¼Œç›´æ¥è´´ä¸Šuser/pingpong.cä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; int main(int argc, char *argv[]) { int p1[2],p2[2]; char byte; // byte // ä¸¤æ¡ç®¡é“ åŒå‘é€šä¿¡ pipe(p1); // parent to child pipe(p2); // child to parent if(fork() != 0){ // parent close(p2[1]); close(p1[0]); write(p1[1],\u0026#34;0\u0026#34;,1); // write a byte read(p2[0],\u0026amp;byte,1); // read a byte printf(\u0026#34;%d: received pong\\n\u0026#34;,getpid()); close(p2[0]); close(p1[1]); exit(0); }else{ // child close(p2[0]); close(p1[1]); read(p1[0],\u0026amp;byte,1); // read a byte printf(\u0026#34;%d: received ping\\n\u0026#34;,getpid()); write(p2[1],\u0026amp;byte,1); // write a byte close(p2[1]); close(p1[0]); exit(0); } } primes è¯¥ä»»åŠ¡éœ€è¦ç¼–å†™ç¨‹åºè¾“å‡º2~35ä¸­çš„æ‰€æœ‰è´¨æ•°ï¼Œæ¯”è¾ƒç‰¹æ®Šçš„è¦æ±‚æ˜¯ä½¿ç”¨å¹¶å‘çš„æ–¹å¼æ¥ç­›é€‰è´¨æ•°ï¼Œç®—æ³•æè¿°è§ http://swtch.com/~rsc/thread/\nç®—æ³•æè¿° ç”¨ä¸€å¼ å›¾æ¥æè¿°è¿™ä¸ªç­›é€‰è´¨æ•°çš„å¹¶å‘ç®—æ³•ï¼Œå¦‚ä¸‹\nä¸Šå›¾ä¸­æ¯ä¸€ä¸ªæ¡†æ¡†ä¸ºä¸€ä¸ªç‹¬ç«‹æ‰§è¡Œçš„ä¾‹ç¨‹(å¯ä»¥æ˜¯processã€threadæˆ–è€…åˆ«çš„ä»€ä¹ˆæ¯”å¦‚golangä¸­çš„goroutineï¼Œæ€»ä¹‹æ˜¯å¯ä»¥å¹¶å‘æ‰§è¡Œçš„ä¸€æ®µç¨‹åº)ï¼Œæ¯ä¸€ä¸ªä¾‹ç¨‹å¯ä»¥ç»™å³è¾¹çš„é‚»å±…å‘é€ç­›é€‰å‡ºæ¥çš„æœ‰å¯èƒ½æ˜¯è´¨æ•°çš„æ•°ï¼Œæ¯ä¸€ä¸ªä¾‹ç¨‹éƒ½ä¼šè¿›è¡Œç›¸åº”çš„ç­›é€‰ï¼Œé€‰å‡ºæ¥çš„æ•°å‘ç»™å³è¾¹çš„é‚»å±…ã€‚\nå…¶ä¸­ç¬¬ä¸€ä¸ªä¾‹ç¨‹ä¼šæ”¶åˆ°2-MAXæ‰€æœ‰çš„æ•°å­—ï¼Œæ”¶åˆ°çš„ç¬¬ä¸€ä¸ªæ•°å­—å½“åšè´¨æ•°è¾“å‡º(æ˜¾ç„¶ç¬¬ä¸€ä¸ªæ•°æ˜¯2ï¼Œæ˜¯è´¨æ•°)ã€‚ç¬¬ä¸€ä¸ªä¾‹ç¨‹çŸ¥é“2æ˜¯è´¨æ•°äº†ï¼Œé‚£ç¬¬ä¸€ä¸ªä¾‹ç¨‹æ¥ä¸‹æ¥æ”¶åˆ°çš„æ‰€æœ‰æ•°å­—ï¼Œå¦‚æœå¯ä»¥è¢«2æ•´é™¤ï¼Œé‚£ä¸€å®šä¸æ˜¯è´¨æ•°ï¼Œä¸èƒ½è¢«2æ•´é™¤çš„æœ‰å¯èƒ½æ˜¯è´¨æ•°ï¼Œå°†æœ‰å¯èƒ½æ˜¯è´¨æ•°çš„æ•°å‘é€ç»™å³è¾¹çš„é‚»å±…ï¼Œå³è¾¹çš„é‚»å±…åšè¿›ä¸€æ­¥çš„ç­›é€‰ã€‚\næ¥ä¸‹æ¥çœ‹ç¬¬äºŒä¸ªä¾‹ç¨‹ï¼Œå¯ä»¥ç¡®å®šçš„æ˜¯ï¼Œç¬¬äºŒä¸ªä¾‹ç¨‹æ”¶åˆ°çš„ç¬¬ä¸€ä¸ªä¾‹ç¨‹çš„ç¬¬ä¸€ä¸ªæ•°å­—ä¸€å®šä¹Ÿæ˜¯ä¸ªè´¨æ•°ã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Ÿç¬¬äºŒä¸ªä¾‹ç¨‹æ”¶åˆ°çš„ç¬¬ä¸€ä¸ªæ•°å­—(è®°ä½œp)ä¸€å®šå¤§äº2(å¤§äºå‰ä¸€ä¸ªä¾‹ç¨‹è®¤å®šäº†æ˜¯è´¨æ•°çš„æ•°)ï¼Œæ‰€æœ‰å°äºpçš„è´¨æ•°(ç›®å‰æ¥çœ‹å°±æ˜¯2)éƒ½ä¸æ˜¯pçš„å› å­ï¼Œé‚£pè‚¯å®šä¹Ÿæ˜¯è´¨æ•°ã€‚æ‰€ä»¥ç¬¬äºŒä¸ªä¾‹ç¨‹å¯ä»¥å°†æ”¶åˆ°çš„ç¬¬ä¸€ä¸ªæ•°è®¤å®šä¸ºè´¨æ•°ï¼Œå°†å…¶è¾“å‡ºã€‚æ¥ä¸‹æ¥æ”¶åˆ°çš„æ•°å­—ï¼Œç¬¬äºŒä¸ªä¾‹ç¨‹å°†æ£€æµ‹æ˜¯å¦èƒ½è¢«pæ•´é™¤ï¼Œè‹¥ä¸èƒ½æ‰å¯èƒ½æ˜¯è´¨æ•°ï¼Œç¬¬äºŒä¸ªä¾‹ç¨‹ä¼šå°†æœ‰å¯èƒ½æ˜¯è´¨æ•°çš„æ•°å‘ç»™å³è¾¹çš„é‚»å±…ï¼ˆå³ç¬¬ä¸‰ä¸ªä¾‹ç¨‹ï¼‰ã€‚æ˜¾ç„¶ç¬¬ä¸‰ä¸ªä¾‹ç¨‹æ”¶åˆ°çš„æ•°å­—ä¸€å®šä¸ä¼šè¢«å‰ä¸¤ä¸ªè´¨æ•°æ•´é™¤ï¼Œé‚£ä¹ˆç¬¬ä¸‰ä¸ªä¾‹ç¨‹æ”¶åˆ°çš„ç¬¬ä¸€ä¸ªæ•°å­—ä¹Ÿæ˜¯ä¸ªè´¨æ•°\u0026hellip;\u0026hellip;\nç”¨æ•°å­¦å½’çº³æ³•å¯ä»¥å®¹æ˜“çœ‹å‡ºï¼Œæ¯ä¸ªä¾‹ç¨‹æ”¶åˆ°çš„ç¬¬ä¸€ä¸ªæ•°éƒ½æ˜¯è´¨æ•°ï¼Œä¸”æ¯ä¸€ä¸ªä¾‹ç¨‹éƒ½ä¼šæŠŠå¯èƒ½æ˜¯è´¨æ•°çš„æ•°å‘ç»™å³é‚»å±…è¿›ä¸€æ­¥ç­›é€‰ï¼Œæ¯ä¸€ä¸ªä¾‹ç¨‹è¡Œä¸ºçš„ä¼ªä»£ç æè¿°ä¸º\n1 2 3 4 5 6 p = get a number from left neighbor print p loop: n = get a number from left neighbor if (p does not divide n) send n to right neighbor ç®—æ³•å®ç° è¿™ä¸ªä»»åŠ¡å°±è¦å®ç°è¿™ä¸€ä¸ªç®—æ³•ã€‚åœ¨æˆ‘çš„å®ç°ä¸­ï¼Œä½¿ç”¨è¿›ç¨‹ä½œä¸ºä¸€ä¸ªç‹¬ç«‹çš„ä¾‹ç¨‹ï¼Œä¸»è¿›ç¨‹è´Ÿè´£å‘é€2-35æ‰€æœ‰çš„æ•°å­—ï¼Œç„¶åå¼€å¯ç¬¬ä¸€ä¸ªè¿›ç¨‹è¿›è¡Œç­›é€‰ï¼Œæ¥ç€æ¯ä¸€ä¸ªè¿›ç¨‹æ ¹æ®éœ€è¦åˆ¤æ–­æ˜¯å¦éœ€è¦å¼€å¯å³é‚»å±…ï¼Œå…ˆçœ‹ä¸»è¿›ç¨‹ä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main(int argc,char *argv[]){ int p; int to[2]; int status; pipe(to); // to æ˜¯ä¸»è¿›ç¨‹å‘é€2~35æ‰€æœ‰æ•°å­—ç»™ç¬¬ä¸€ä¸ªä¾‹ç¨‹æ‰€ç”¨çš„ç®¡é“ if(fork() != 0){ // parent close(to[0]); // do not read ä¸ç”¨çš„èµ„æºå°½å¿«close ä¸»è¿›ç¨‹ç”¨è¯¥ç®¡é“ä¸éœ€è¦è¯» for(p = 2;p \u0026lt;= 35;p++) write(to[1],\u0026amp;p,sizeof(p)); // å°†2~35æ‰€æœ‰æ•°å­—å†™å…¥ç®¡é“ close(to[1]); }else{ // child worker(to); // å­è¿›ç¨‹ï¼Œå³ä¸Šé¢ç¤ºæ„å›¾ä¸­çš„ä¾‹ç¨‹ï¼Œæ¥æ”¶çˆ¶è¿›ç¨‹å‘é€çš„æ•°å­— exit(0); } wait(\u0026amp;status); // ä¸»è¿›ç¨‹ç­‰å¾…å­è¿›ç¨‹ç»“æŸ exit(0); } æ¥ç€æ¥çœ‹çœ‹æ¯ä¸€ä¸ªä¾‹ç¨‹çš„æè¿°å‡½æ•°workerçš„å®ç°ï¼Œworkerå®Œå…¨æŒ‰ç…§å‰æ–‡çš„ä¼ªä»£ç å®ç°\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void worker(int from[]){ // å‚æ•°ä¸ºæ¥æ”¶å·¦é‚»å±…æ•°å­—çš„ç®¡é“ int forked = 0; // æ ‡è®°æ˜¯å¦å¼€å¯è¿‡å³é‚»å±…è¿›ç¨‹ int to[2]; close(from[1]); // do not write to from è¯¥ç®¡é“æˆ‘åªä½¿ç”¨è¯»ç«¯ï¼Œä¸ä½¿ç”¨å†™ç«¯ï¼Œæ²¡ç”¨çš„èµ„æºå°½å¿«é‡Šæ”¾ int p; // æ¥æ”¶ç¬¬ä¸€ä¸ªæ•°å­— read(from[0],\u0026amp;p,sizeof(p)); // read first p printf(\u0026#34;prime %d\\n\u0026#34;,p); // ç¬¬ä¸€ä¸ªæ•°å­—ä¸€å®šæ˜¯è´¨æ•° int t; // æ¥æ”¶æ•°å­— while(read(from[0],\u0026amp;t,sizeof(t) != 0)){ // è¯¥å¾ªç¯é‡Œé¢ä¸æ–­æ¥æ”¶æ•°å­—ï¼ŒæŒ‘å‡ºå¯èƒ½æ˜¯è´¨æ•°çš„æ•°å­—å‘ç»™å³é‚»å±… if(t % p != 0){ // tæœ‰å¯èƒ½æ˜¯è´¨æ•° è¿™éœ€è¦å‘ç»™å³é‚»å±…äº† if(!forked){ // è¿˜æ²¡æœ‰å³é‚»å±… pipe(to); // åˆ›å»ºå’Œå³é‚»å±…é€šä¿¡çš„ç®¡é“ if(fork() != 0){ // parent close(to[0]);// æœ¬è¿›ç¨‹å…³é—­ç®¡é“è¯»ç«¯ }else{ // child worker(to); // å­è¿›ç¨‹ä»toè¯»å–æ•°å­— exit(0); } forked = 1; // æ ‡è®°å·²ç»å¼€å¯è¿‡å­è¿›ç¨‹ } write(to[1],\u0026amp;t,sizeof(t)); // å‘é€tç»™å­è¿›ç¨‹ } } // é‡Šæ”¾èµ„æº close(from[0]); close(to[1]); // ç­‰å¾…å³é‚»å±…é€€å‡º int status; wait(\u0026amp;status); } ä»¥ä¸Šä¸¤æ®µä»£ç å®ç°äº†è¯¥ä»»åŠ¡ã€‚\nå¦å¤–åæ§½ä¸€ä¸‹ï¼Œç»è¿‡æˆ‘çš„å°è¯•ï¼Œä¸‹é¢è¿™æ®µä»£ç ä¹Ÿæ˜¯å¯ä»¥é€šè¿‡æµ‹è¯•çš„ï¼Œçœ‹æ¥MITçš„æµ‹è¯•ä¹Ÿä¸è¿‡æ˜¯éªŒè¯è¾“å‡ºç½¢äº†\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int is_prime(int n){ int p = n/2; for(int i = 2; i \u0026lt;= p;i++){ if(n % p == 0) return 0; } return 1; } int main(int argc, char *argv[]) { for(int i =2;i \u0026lt;= 35;i++){ if(is_prime(i)) printf(\u0026#34;prime %d\\n\u0026#34;,i); } exit(0); } find è¯¥ä»»åŠ¡éœ€è¦å®ç°ä¸€ä¸ªæç®€ç‰ˆçš„findï¼ŒåŠŸèƒ½å¦‚ä¸‹æ‰€è¿°\n1 find \u0026lt;path\u0026gt; \u0026lt;filename\u0026gt; åœ¨\u0026lt;path\u0026gt;è·¯å¾„ä¸­æœç´¢æ–‡ä»¶åä¸º\u0026lt;filename\u0026gt;çš„æ–‡ä»¶ï¼Œç¤ºä¾‹å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 $ make qemu ... init: starting sh $ echo \u0026gt; b $ mkdir a $ echo \u0026gt; a/b $ find . b ./b ./a/b $ xv6çš„ç›®å½•é¡¹ åœ¨ç±»unixç³»ç»Ÿä¸­ä¸€èˆ¬ä½¿ç”¨åŸºäºinodeçš„æ–‡ä»¶ç³»ç»Ÿ(å¯ä»¥å‚è€ƒä¸Šäº¤çš„ã€Šç°ä»£æ“ä½œç³»ç»Ÿ:åŸç†ä¸å®ç°ã€‹ä¸ªäººæ„Ÿè§‰æŒºä¸é”™)ï¼Œåœ¨è¿™ç§æ–‡ä»¶ç³»ç»Ÿä¸‹ï¼Œinodeè®°å½•äº†ä¸€ä¸ªæ–‡ä»¶çš„æ‰€æœ‰å†…å®¹å­˜åœ¨diskçš„ä½ç½®ï¼Œæ‰€ä»¥çŸ¥é“äº†inodeå°±çŸ¥é“äº†æŸä¸€ä¸ªæ–‡ä»¶ã€‚åœ¨ç±»UNIXç³»ç»Ÿä¸‹ç›®å½•ä¹Ÿæ˜¯æ™®é€šçš„æ–‡ä»¶ï¼Œæ–‡ä»¶å†…å­˜ç€ä¸€ä¸ªä¸ªç›®å½•é¡¹ï¼Œå³è®°å½•ç€inodeå·å’Œå…¶ä»–ä¸€äº›æ–‡ä»¶ä¿¡æ¯ï¼Œåœ¨xv6å†…ï¼Œç›®å½•é¡¹å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 // kernel/fs.h // Directory is a file containing a sequence of dirent structures. #define DIRSIZ 14 struct dirent { ushort inum; // inode number char name[DIRSIZ]; // filename }; fstatå’Œstat xv6ä¸­è·å–æ–‡ä»¶ä¿¡æ¯çš„ç³»ç»Ÿè°ƒç”¨ä¸ºfstatï¼Œä½¿ç”¨è¯¥å‡½æ•°è¿˜å°è£…äº†ä¸€ä¸ªç”¨æˆ·æ€ä¸‹çš„å·¥å…·å‡½æ•°statï¼Œä¸¤ä¸ªå‡½æ•°åŸå‹å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // system call int fstat(int fd, struct stat*); // fd ä¸ºæ–‡ä»¶æè¿°ç¬¦ // ulib.c int stat(const char*, struct stat*); int stat(const char *n, struct stat *st) // å‡½æ•°å®šä¹‰ { int fd; int r; fd = open(n, O_RDONLY); if(fd \u0026lt; 0) return -1; r = fstat(fd, st); close(fd); return r; } å…¶ä¸­æè¿°æ–‡ä»¶ä¿¡æ¯çš„ç»“æ„å®šä¹‰å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 #define T_DIR 1 // Directory #define T_FILE 2 // File #define T_DEVICE 3 // Device struct stat { int dev; // File system\u0026#39;s disk device uint ino; // Inode number short type; // Type of file short nlink; // Number of links to file uint64 size; // Size of file in bytes }; å®ç° æœ‰äº†ä¸Šé¢çš„é“ºå«ï¼Œå®¹æ˜“ç¼–å†™findä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 void find(char *path,char *filename){ // è¯¥å‡½æ•°åœ¨ path å†…æ‰¾ æ–‡ä»¶åä¸ºfilenameçš„æ–‡ä»¶ int fd; struct stat st; struct dirent de; char buff[512]; char *p; strcpy(buff,path); // è·¯å¾„å¤åˆ¶åˆ°buffé‡Œ p = buff + strlen(buff); *p ++ = \u0026#39;/\u0026#39;; // path ååŠ ä¸€ä¸ª / if((fd = open(path,0)) \u0026lt; 0){ // æ‰“å¼€pathè¿™ä¸ªç›®å½•æ–‡ä»¶ fprintf(2,\u0026#34;find: cannot open file:%s\\n\u0026#34;,path); return; } if(fstat(fd,\u0026amp;st) \u0026lt; 0){ // æ²¡èƒ½è·å–æ–‡ä»¶ä¿¡æ¯ fprintf(2,\u0026#34;find: cannot stat\\n\u0026#34;); close(fd); return; } if(st.type != T_DIR){ // path ä¸æ˜¯ç›®å½•æ–‡ä»¶ fprintf(2,\u0026#34;find: path:%s is not a directory\\n\u0026#34;,path); close(fd); return; } while(read(fd,\u0026amp;de,sizeof(de)) == sizeof(de)){ // éå†æ¯ä¸€ä¸ªç›®å½•é¡¹ // æ— æ•ˆçš„inode æˆ–è€…. å’Œ ..éƒ½ä¸ç»§ç»­æœç´¢ if(de.inum == 0 || strcmp(de.name,\u0026#34;.\u0026#34;) == 0 || strcmp(de.name,\u0026#34;..\u0026#34;) == 0) continue; strcpy(p,de.name); // path/filename stat(buff,\u0026amp;st); // è·å–æ–‡ä»¶ä¿¡æ¯ switch (st.type) { case T_FILE: // æ™®é€šæ–‡ä»¶ if(strcmp(de.name,filename) == 0) printf(\u0026#34;%s\\n\u0026#34;,buff); break; case T_DIR: // ç›®å½•æ–‡ä»¶åˆ™é€’å½’æœç´¢ find(buff,filename); // find recursively break; default: break; } } } ä¸»å‡½æ•°ç¼–å†™å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 int main(int argc,char *argv[]){ if(argc \u0026lt;= 2){ fprintf(2,\u0026#34;find: no enough argument\\n\u0026#34;); exit(-1); } find(argv[1],argv[2]); exit(0); } xargs è¯¥ä»»åŠ¡è¦æ±‚å®ç°ä¸€ä¸ªæç®€ç‰ˆçš„xargsï¼Œè²Œä¼¼ä¹Ÿæ²¡ä»€ä¹ˆå¥½è§£é‡Šçš„ï¼Œå°±æ˜¯ç†Ÿæ‚‰forkå’Œexecå³å¯ï¼Œç›´æ¥ç²˜ä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; #include \u0026#34;kernel/fs.h\u0026#34; #include \u0026#34;kernel/param.h\u0026#34; #define EOF -1 int getchar(){ char ch; if(read(0,\u0026amp;ch,sizeof(ch)) \u0026lt;= 0) return EOF; return (int)ch; } int readline(char *buf){ int ch; while((ch = getchar()) != \u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; ch != EOF) *buf++ = ch; *buf = 0; if(ch == EOF) return EOF; return 1; } int main(int argc,char *argv[]){ char buf[512]; if(argc \u0026lt;= 1){ fprintf(2,\u0026#34;xarg: no enough arguments\\n\u0026#34;); exit(-1); } int p = 0,q; char *command = argv[1]; char *args[MAXARG]; args[p++] = command; for(int i = 2;i \u0026lt; argc;i++) args[p++] = argv[i]; // arguments from argv q = p; while(readline(buf) != EOF){ args[q] = malloc(strlen(buf)); strcpy(args[q++],buf); } args[q] = 0; int status; if(fork() == 0){ // child exec(command,args); }else{ // father wait(\u0026amp;status); } for(;p \u0026lt; q;p ++) free(args[p]); exit(0); } å°¾å£° è¯´å®è¯ä¸çŸ¥é“è¿™ä¸ªMIT 6.S081è¿˜èƒ½åšæŒå¤šä¹…ï¼Œèƒ½åšæŒä¸€ä¸ªlabå°±å¤šåšæŒä¸€ä¸ªå§â˜ºï¸\nä»£ç æ”¾åˆ° https://github.com/XieWeikai/xv6_lab çš„ lab1åˆ†æ”¯å•¦ï¼Œä½†ç›®å‰è¯¥ä»“åº“è¿˜æ˜¯privateçš„ï¼Œç­‰åˆ°è¿™ä¸ªè¯¾ç¨‹çœŸçš„å®Œæˆçš„å·®ä¸å¤šäº†å†å‡†å¤‡å…¬å¼€äº†å“ˆå“ˆå“ˆã€‚\n","date":"2023-01-05T16:44:26+08:00","image":"https://XieWeikai.github.io/aniya_blog/p/os_util_lab/saber2_hu583263cbbee05d2c263b501713a891d4_83776_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/os_util_lab/","title":"OS_util_lab"},{"content":"Xv6 ç¯å¢ƒé…ç½® å‡æœŸå¼€å§‹ï¼Œå…ˆè¯•ç€æŠŠxv6çš„å®éªŒç¯å¢ƒæ­å»ºèµ·æ¥ï¼Œä¹‹ååšä¸åšå®éªŒç­‰åˆ°ä»¥åå†è¯´\u0026hellip;\u0026hellip;\næ ¹æ®å®˜æ–¹çš„æŒ‡å¯¼æ•™ç¨‹ï¼Œåœ¨macOSä¸‹é…ç½®å®éªŒç¯å¢ƒéœ€è¦åšå¦‚ä¸‹å‡†å¤‡\nå®‰è£…git æ—©å°±å®‰è£…å¥½äº† å®‰è£…qemu å®‰è£…risc-vçš„å·¥å…·é“¾ å®‰è£…risc-vå·¥å…·é“¾ ä½¿ç”¨å¦‚ä¸‹å‘½ä»¤å®‰è£… (è§ https://github.com/riscv-software-src/homebrew-riscv)\n1 2 brew tap riscv-software-src/riscv brew install riscv-tools åœ¨å®é™…å®‰è£…æ—¶å‘ç°brewç»å¸¸ä¼šåœ¨æŸä¸ªåœ°æ–¹å¡ä½å®Œå…¨ä¸åŠ¨äº†(gitä¸‹è½½ä»“åº“æ—¶)ï¼Œä¸­æ–­åé‡è¯•å‡ æ¬¡éƒ½æ˜¯ä¸€æ ·ã€‚åæ¥åœ¨ç½‘ä¸Šå‘ç°åˆ«äººä¹Ÿç¢°åˆ°äº†ç±»ä¼¼çš„é—®é¢˜(è§ https://zhayujie.com/mit6828-env.html)ï¼ŒæŒ‰ç…§è¯¥åšä¸»çš„è¯´æ³•ï¼Œæˆ‘ä»¬åªéœ€è¦å®‰è£…riscv-gnu-toolchainå³å¯ã€‚ä½†ä¸‹è½½å¥½æºç ç¼–è¯‘æ—¶å‡ºç°äº†å„ç§warningï¼Œç”šè‡³è¿˜æœ‰error(ä½†è²Œä¼¼è¿˜æ˜¯å¯ä»¥ç¼–è¯‘å‡ºå¯æ‰§è¡Œæ–‡ä»¶çš„ï¼Œå¯èƒ½ä¼šå°‘ä¸€äº›ä¸œè¥¿)ï¼Œæ ¹æ®å®˜ç½‘çš„æè¿°(è§ https://github.com/riscv-collab/riscv-gnu-toolchain)ï¼Œåœ¨OS Xä¸Šç¼–è¯‘éœ€è¦ä¿è¯æ–‡ä»¶ç³»ç»Ÿæ˜¯å¤§å°å†™æ•æ„Ÿçš„ï¼Œä½†å¾ˆå¯æƒœmacOSä½¿ç”¨çš„æ–‡ä»¶ç³»ç»Ÿä¸æ˜¯å¤§å°å†™æ•æ„Ÿçš„\u0026hellip;\u0026hellip;\nè¦è§£å†³å¦‚ä¸Šé—®é¢˜å¯ä»¥åˆ›å»ºä¸€ä¸ªå¤§å°å†™æ•æ„Ÿçš„æ–‡ä»¶ç³»ç»Ÿé•œåƒå¹¶æŒ‚è½½åˆ°æœ¬åœ°çš„æŸä¸ªç›®å½•ä¸Šï¼Œæ–¹æ³•è§ https://github.com/spryker/spryker-docs/blob/master/docs/scos/dev/tutorials-and-howtos/howtos/howto-handle-case-sensitive-file-system-on-mac-os.md ï¼Œå°†æºç æ”¾åˆ°è¯¥ç›®å½•ä¸‹å†ç¼–è¯‘å³å¯ã€‚\næœ€åæ„Ÿè§‰å¤ªéº»çƒ¦äº†ï¼Œè¿˜æ˜¯å†³å®šè¯•ä¸€è¯•brewèƒ½å¦æˆåŠŸï¼Œæ‰§è¡Œå¦‚ä¸‹å‘½ä»¤\n1 2 brew tap riscv-software-src/riscv brew install riscv-tools æ‰§è¡Œå¼€å§‹åæœ¬äººå°±å»æ‘†çƒ‚äº†ï¼Œç»ˆäºåœ¨å…­ä¸ªå°æ—¶(å·¦å³)åï¼Œå®‰è£…æˆåŠŸå®Œæˆäº†\nè‡³æ­¤riscvå·¥å…·é“¾å®‰è£…å®Œæ¯•ã€‚\nå®‰è£…qemu ç†è®ºä¸Šæ¥è¯´éå¸¸ç®€å•ï¼Œä¸€æ¡å‘½ä»¤æå®š\n1 brew install qemu å®‰è£…å®Œæ¯•ï¼Œæå®šã€‚\nå°è¯•å¯åŠ¨xv6ï¼Œå¦‚ä¸‹\n1 2 3 4 cd path/to/lab git clone git://g.csail.mit.edu/xv6-labs-2020 git checkout util make qemu åœ¨macOSä¸‹ç¼–è¯‘æ—¶ç¼–è¯‘å™¨ä¼šæŠ¥å¦‚ä¸‹é”™è¯¯\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie -c -o user/sh.o user/sh.c user/sh.c: In function \u0026#39;runcmd\u0026#39;: user/sh.c:58:1: error: infinite recursion detected [-Werror=infinite-recursion] 58 | runcmd(struct cmd *cmd) | ^~~~~~ user/sh.c:89:5: note: recursive call 89 | runcmd(rcmd-\u0026gt;cmd); | ^~~~~~~~~~~~~~~~~ user/sh.c:109:7: note: recursive call 109 | runcmd(pcmd-\u0026gt;left); | ^~~~~~~~~~~~~~~~~~ user/sh.c:116:7: note: recursive call 116 | runcmd(pcmd-\u0026gt;right); | ^~~~~~~~~~~~~~~~~~~ user/sh.c:95:7: note: recursive call 95 | runcmd(lcmd-\u0026gt;left); | ^~~~~~~~~~~~~~~~~~ user/sh.c:97:5: note: recursive call 97 | runcmd(lcmd-\u0026gt;right); | ^~~~~~~~~~~~~~~~~~~ user/sh.c:127:7: note: recursive call 127 | runcmd(bcmd-\u0026gt;cmd); | ^~~~~~~~~~~~~~~~~ cc1: all warnings being treated as errors make: *** [\u0026lt;builtin\u0026gt;: user/sh.o] Error 1 å°†Makefileä¸­CFLAGSçš„-Werroré€‰é¡¹å»æ‰å³å¯ã€‚\nä½†ç¼–è¯‘å®Œæˆåæ‚²æƒ¨çš„å‘ç°ï¼Œå¯åŠ¨qemuåç¨‹åºå°±å¡ä½äº†ï¼Œæ²¡æœ‰ä»»ä½•äº¤äº’è¡Œä¸ºã€‚æ ¹æ®å®˜æ–¹æŒ‡å¯¼çš„æè¿°ï¼Œqemuç‰ˆæœ¬å¤ªæ–°å¯èƒ½ä¼šå‡ºç°è¿™ä¸ªé—®é¢˜ã€‚ç»è¿‡æŸ¥æ‰¾èµ„æ–™ï¼Œbrewè²Œä¼¼æ²¡æœ‰åŠæ³•å®‰è£…æ—§ç‰ˆæœ¬çš„qemuï¼Œåªå¥½åœ¨qemuå®˜ç½‘ä¸Šä¸‹è½½qemu 4.2åé€šè¿‡æºç æ¥å®‰è£…qemuäº†ï¼Œæ–¹æ³•å¦‚ä¸‹\n1 2 3 4 5 6 7 8 cd path/to/lab mkdir qemu-build # åœ¨è¯¥ç›®å½•ä¸‹ä¸‹è½½æºç å¹¶å®‰è£… cd qemu-build wget https://download.qemu.org/qemu-4.2.1.tar.xz # ä¸‹è½½æºç å‹ç¼©åŒ… tar xvJf qemu-4.2.1.tar.xz # è§£å‹ cd qemu-4.2.1 ./configure make # ç¼–è¯‘ éœ€è¦èŠ±è´¹å‡ ååˆ†é’Ÿæ¥å®Œæˆç¼–è¯‘ï¼Œç¼–è¯‘åriscv64-softmmuç›®å½•å†…çš„qemu-system-riscv64å³ä¸ºéœ€è¦çš„å¯æ‰§è¡Œæ–‡ä»¶ï¼Œåšä¸€ä¸ªè½¯è¿æ¥å¦‚ä¸‹\n1 2 cd riscv64-softmmu ln -s $(pwd)/qemu-system-riscv64 /usr/local/bin/qemu-system-riscv64 ä¹‹åé‡æ–°å°è¯•make qemuï¼Œå¯ä»¥æ­£å¸¸å¯åŠ¨xv6æ“ä½œç³»ç»Ÿã€‚\nåœ¨dockerä¸‹é…ç½®ç¯å¢ƒ åœ¨dockerä¸‹æ‹‰å–ubuntué•œåƒï¼Œä»¥è¯¥é•œåƒå¯åŠ¨å®¹å™¨\n1 2 3 4 docker run -it --name xv6 \\ -v ...:.../path/to/lab \\ # æŒ‚è½½æœ¬åœ°ç›®å½• -p ...:... \\ # ç«¯å£æ˜ å°„ ubuntu:latest æ¥ç€åœ¨è¯¥å®¹å™¨å†…å…ˆè£…äº›æœ€åŸºæœ¬çš„ä¸œè¥¿ c/c++çš„å·¥å…·é“¾(gcc/c++å’Œå„ç§åº“ã€åŒ…)ã€gitã€cmakeã€ç­‰å„ç§ä¸œè¥¿ã€‚\nå®‰è£…riscv-tools æ ¹æ®å®˜æ–¹æŒ‡å¯¼ï¼Œä½¿ç”¨å¦‚ä¸‹å‘½ä»¤å®‰è£…\n1 apt-get install gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu è¿™ä¸ªå®‰è£…é€Ÿåº¦æ¯”macä¸‹ç”¨brewæ‹‰å–æºç ç¼–è¯‘å¿«å¾—å¤šäº†ã€‚\né¡ºå¸¦å®‰è£…ä¸€äº›å¯èƒ½æ˜¯è°ƒè¯•å·¥å…·çš„åŒ…\n1 apt-get install gdb-multiarch å®‰è£…qemu æ ¹æ®å®˜æ–¹æŒ‡å¯¼ï¼Œä½¿ç”¨å¦‚ä¸‹å‘½ä»¤å®‰è£…\n1 apt-get install qemu-system-misc å¾ˆé—æ†¾ï¼Œç°åœ¨çš„qemuç»è¿‡ä¸¤å¹´çš„æ”¹è¿›ï¼Œå’ŒmacOSä¸Šä¸€æ ·ï¼Œæ–°ç‰ˆæœ¬çš„qemuå¯åŠ¨åå°±å¡æ­»ã€‚æŒ‰ç…§æŒ‡å¯¼ï¼Œä½¿ç”¨å¦‚ä¸‹å‘½ä»¤å¸è½½å¹¶å®‰è£…è€ç‰ˆæœ¬\n1 2 apt-get remove qemu-system-misc # å¸è½½ apt-get install qemu-system-misc=1:4.2-3ubuntu6 # å®‰è£…è€ç‰ˆæœ¬ ä½†ä»Šéæ˜”æ¯”äº†ï¼Œä¸Šè¿°å®‰è£…æ–¹æ³•ä¼šæç¤ºæ‰¾ä¸åˆ°è¯¥ç‰ˆæœ¬çš„qemuã€‚\næŒ‰ç…§æŒ‡å¯¼ï¼Œä¹Ÿå¯ä»¥è¿›è¡Œæºç å®‰è£…\n1 2 3 4 5 6 wget https://download.qemu.org/qemu-5.1.0.tar.xz # ä¸‹è½½æºç  qemu 5.1.0 tar xf qemu-5.1.0.tar.xz # è§£å‹ cd qemu-5.1.0 ./configure --disable-kvm --disable-werror --prefix=/usr/local --target-list=\u0026#34;riscv64-softmmu\u0026#34; make make install åœ¨ubuntuç¯å¢ƒä¸‹make qemuä¸ä¼šæŠ¥infinite recursionçš„é”™è¯¯ã€‚\nå°¾å£° åˆ°æ­¤xv6å°±å¯ä»¥æ­£å¸¸å¯åŠ¨äº†ï¼Œæœ‰å¯èƒ½ä»¥åè¿˜ä¼šç¢°åˆ°å…¶ä»–çš„é—®é¢˜ï¼Œç­‰åˆ°ä»¥åå†è¯´å§ã€‚\n","date":"2023-01-03T21:11:14+08:00","image":"https://XieWeikai.github.io/aniya_blog/p/xv6-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/wallpaper_hu0ff37ebbb98d2b42bafbb67ed8d5243a_153541_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/xv6-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","title":"xv6 ç¯å¢ƒé…ç½®"},{"content":"OS å¯’å‡å¼€å§‹äº†ï¼Œå¦‚æœæ¯å¤©çœ‹ä¸€ç‚¹å…³äºæ“ä½œç³»ç»Ÿçš„ä¸œè¥¿ï¼Œè¯´ä¸å®šå°±å¯ä»¥å®Œæˆ 25%çš„ä¸‹ä¸ªå­¦æœŸçš„æ“ä½œç³»ç»Ÿè¯¾ç¨‹è®¾è®¡å‘¢ï¼Ÿ\n","date":"2023-01-01T16:38:36+08:00","image":"https://XieWeikai.github.io/aniya_blog/p/os-flag/ostep-fun_hu25d333fcded103db2f52f7476cb1420a_52206_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/os-flag/","title":"OS flag"},{"content":"æ­£æ–‡æµ‹è¯• è€Œè¿™äº›å¹¶ä¸æ˜¯å®Œå…¨é‡è¦ï¼Œæ›´åŠ é‡è¦çš„é—®é¢˜æ˜¯ï¼Œ å¸¦ç€è¿™äº›é—®é¢˜ï¼Œæˆ‘ä»¬æ¥å®¡è§†ä¸€ä¸‹å­¦ç”Ÿä¼šé€€ä¼šã€‚ æ—¢ç„¶å¦‚ä½•ï¼Œ å¯¹æˆ‘ä¸ªäººè€Œè¨€ï¼Œå­¦ç”Ÿä¼šé€€ä¼šä¸ä»…ä»…æ˜¯ä¸€ä¸ªé‡å¤§çš„äº‹ä»¶ï¼Œè¿˜å¯èƒ½ä¼šæ”¹å˜æˆ‘çš„äººç”Ÿã€‚ æˆ‘ä»¬ä¸å¾—ä¸é¢å¯¹ä¸€ä¸ªéå¸¸å°´å°¬çš„äº‹å®ï¼Œé‚£å°±æ˜¯ï¼Œ å¯æ˜¯ï¼Œå³ä½¿æ˜¯è¿™æ ·ï¼Œå­¦ç”Ÿä¼šé€€ä¼šçš„å‡ºç°ä»ç„¶ä»£è¡¨äº†ä¸€å®šçš„æ„ä¹‰ã€‚ å­¦ç”Ÿä¼šé€€ä¼šï¼Œå‘ç”Ÿäº†ä¼šå¦‚ä½•ï¼Œä¸å‘ç”Ÿåˆä¼šå¦‚ä½•ã€‚ ç»è¿‡ä¸Šè¿°è®¨è®ºï¼Œ ç”Ÿæ´»ä¸­ï¼Œè‹¥å­¦ç”Ÿä¼šé€€ä¼šå‡ºç°äº†ï¼Œæˆ‘ä»¬å°±ä¸å¾—ä¸è€ƒè™‘å®ƒå‡ºç°äº†çš„äº‹å®ã€‚ å­¦ç”Ÿä¼šé€€ä¼šï¼Œåˆ°åº•åº”è¯¥å¦‚ä½•å®ç°ã€‚ è¿™æ ·çœ‹æ¥ï¼Œ åœ¨è¿™ç§å›°éš¾çš„æŠ‰æ‹©ä¸‹ï¼Œæœ¬äººæ€æ¥æƒ³å»ï¼Œå¯é£Ÿéš¾å®‰ã€‚ å¯¹æˆ‘ä¸ªäººè€Œè¨€ï¼Œå­¦ç”Ÿä¼šé€€ä¼šä¸ä»…ä»…æ˜¯ä¸€ä¸ªé‡å¤§çš„äº‹ä»¶ï¼Œè¿˜å¯èƒ½ä¼šæ”¹å˜æˆ‘çš„äººç”Ÿã€‚ å°±æˆ‘ä¸ªäººæ¥è¯´ï¼Œå­¦ç”Ÿä¼šé€€ä¼šå¯¹æˆ‘çš„æ„ä¹‰ï¼Œä¸èƒ½ä¸è¯´éå¸¸é‡å¤§ã€‚ èå£«æ¯”äºšæ›¾ç»æåˆ°è¿‡ï¼Œäººçš„ä¸€ç”Ÿæ˜¯çŸ­çš„ï¼Œä½†å¦‚æœå‘åŠ£åœ°è¿‡è¿™ä¸€ç”Ÿï¼Œå°±å¤ªé•¿äº†ã€‚è¿™ä¼¼ä¹è§£ç­”äº†æˆ‘çš„ç–‘æƒ‘ã€‚ è«æ‰ç‰¹è¯´è¿‡ä¸€å¥å¯Œæœ‰å“²ç†çš„è¯ï¼Œè°å’Œæˆ‘ä¸€æ ·ç”¨åŠŸï¼Œè°å°±ä¼šå’Œæˆ‘ä¸€æ ·æˆåŠŸã€‚è¿™å¯å‘äº†æˆ‘ï¼Œ å¯¹æˆ‘ä¸ªäººè€Œè¨€ï¼Œå­¦ç”Ÿä¼šé€€ä¼šä¸ä»…ä»…æ˜¯ä¸€ä¸ªé‡å¤§çš„äº‹ä»¶ï¼Œè¿˜å¯èƒ½ä¼šæ”¹å˜æˆ‘çš„äººç”Ÿã€‚ å­¦ç”Ÿä¼šé€€ä¼šï¼Œåˆ°åº•åº”è¯¥å¦‚ä½•å®ç°ã€‚ ä¸€èˆ¬æ¥è¯´ï¼Œ ä»è¿™ä¸ªè§’åº¦æ¥çœ‹ï¼Œ è¿™ç§äº‹å®å¯¹æœ¬äººæ¥è¯´æ„ä¹‰é‡å¤§ï¼Œç›¸ä¿¡å¯¹è¿™ä¸ªä¸–ç•Œä¹Ÿæ˜¯æœ‰ä¸€å®šæ„ä¹‰çš„ã€‚ åœ¨è¿™ç§å›°éš¾çš„æŠ‰æ‹©ä¸‹ï¼Œæœ¬äººæ€æ¥æƒ³å»ï¼Œå¯é£Ÿéš¾å®‰ã€‚ äº†è§£æ¸…æ¥šå­¦ç”Ÿä¼šé€€ä¼šåˆ°åº•æ˜¯ä¸€ç§æ€ä¹ˆæ ·çš„å­˜åœ¨ï¼Œæ˜¯è§£å†³ä¸€åˆ‡é—®é¢˜çš„å…³é”®ã€‚ ä¸€èˆ¬æ¥è¯´ï¼Œ ç”Ÿæ´»ä¸­ï¼Œè‹¥å­¦ç”Ÿä¼šé€€ä¼šå‡ºç°äº†ï¼Œæˆ‘ä»¬å°±ä¸å¾—ä¸è€ƒè™‘å®ƒå‡ºç°äº†çš„äº‹å®ã€‚ é—®é¢˜çš„å…³é”®ç©¶ç«Ÿä¸ºä½•ï¼Ÿ è€Œè¿™äº›å¹¶ä¸æ˜¯å®Œå…¨é‡è¦ï¼Œæ›´åŠ é‡è¦çš„é—®é¢˜æ˜¯ã€‚\nå¥¥æ–¯ç‰¹æ´›å¤«æ–¯åŸºæ›¾ç»è¯´è¿‡ï¼Œå…±åŒçš„äº‹ä¸šï¼Œå…±åŒçš„æ–—äº‰ï¼Œå¯ä»¥ä½¿äººä»¬äº§ç”Ÿå¿å—ä¸€åˆ‡çš„åŠ›é‡ã€‚ã€€å¸¦ç€è¿™å¥è¯ï¼Œæˆ‘ä»¬è¿˜è¦æ›´åŠ æ…é‡çš„å®¡è§†è¿™ä¸ªé—®é¢˜ï¼š ä¸€èˆ¬æ¥è®²ï¼Œæˆ‘ä»¬éƒ½å¿…é¡»åŠ¡å¿…æ…é‡çš„è€ƒè™‘è€ƒè™‘ã€‚ æ—¢ç„¶å¦‚æ­¤ï¼Œ è¿™ç§äº‹å®å¯¹æœ¬äººæ¥è¯´æ„ä¹‰é‡å¤§ï¼Œç›¸ä¿¡å¯¹è¿™ä¸ªä¸–ç•Œä¹Ÿæ˜¯æœ‰ä¸€å®šæ„ä¹‰çš„ã€‚ å¸¦ç€è¿™äº›é—®é¢˜ï¼Œæˆ‘ä»¬æ¥å®¡è§†ä¸€ä¸‹å­¦ç”Ÿä¼šé€€ä¼šã€‚ æˆ‘è®¤ä¸ºï¼Œ æˆ‘è®¤ä¸ºï¼Œ åœ¨è¿™ç§å›°éš¾çš„æŠ‰æ‹©ä¸‹ï¼Œæœ¬äººæ€æ¥æƒ³å»ï¼Œå¯é£Ÿéš¾å®‰ã€‚ é—®é¢˜çš„å…³é”®ç©¶ç«Ÿä¸ºä½•ï¼Ÿ æ¯ä¸ªäººéƒ½ä¸å¾—ä¸é¢å¯¹è¿™äº›é—®é¢˜ã€‚ åœ¨é¢å¯¹è¿™ç§é—®é¢˜æ—¶ï¼Œ è¦æƒ³æ¸…æ¥šï¼Œå­¦ç”Ÿä¼šé€€ä¼šï¼Œåˆ°åº•æ˜¯ä¸€ç§æ€ä¹ˆæ ·çš„å­˜åœ¨ã€‚ æˆ‘è®¤ä¸ºï¼Œ æ—¢ç„¶å¦‚æ­¤ï¼Œ æ¯ä¸ªäººéƒ½ä¸å¾—ä¸é¢å¯¹è¿™äº›é—®é¢˜ã€‚ åœ¨é¢å¯¹è¿™ç§é—®é¢˜æ—¶ï¼Œ é‚£ä¹ˆï¼Œ æˆ‘è®¤ä¸ºï¼Œ å­¦ç”Ÿä¼šé€€ä¼šå› ä½•è€Œå‘ç”Ÿã€‚\nå¼•ç”¨ æ€å¿µæ˜¯æœ€æš–çš„å¿§ä¼¤åƒä¸€åŒç¿…è†€\nè®©æˆ‘åœä¸äº†é£ä¸è¿œåœ¨è¿‡å¾€æ¸¸è¡\nä¸å‘Šè€Œåˆ«çš„ä½  å°±ç®—ä¸ºäº†æˆ‘ç€æƒ³\nè¿™ä¹ˆæ²‰ç—›çš„å‘µæŠ¤ æˆ‘æ€ä¹ˆèƒ½ç¿±ç¿”\næœ€æš–çš„æ†‚å‚· - ç”°é¦¥ç”„\nå›¾ç‰‡ 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) ç›¸å†Œè¯­æ³•æ¥è‡ª Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://XieWeikai.github.io/aniya_blog/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;â€”\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating. â€” Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements â€” abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://XieWeikai.github.io/aniya_blog/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nYouTube Privacy Enhanced Shortcode Twitter Simple Shortcode Vimeo Simple Shortcode bilibilibi Shortcode Gist Shortcode Gitlab Snippets Shortcode Quote Shortcode Stack adds a quote shortcode. For example:\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\nâ€• A famous person, The book they wrote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\nâ€• Anonymous book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\nâ€• Some book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\nâ€• Somebody","date":"2019-03-10T00:00:00Z","permalink":"https://XieWeikai.github.io/aniya_blog/p/rich-content/","title":"Rich Content"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://XieWeikai.github.io/aniya_blog/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\ninline math is like this $a^2+b^2=c^2$\n","date":"2019-03-08T00:00:00Z","permalink":"https://XieWeikai.github.io/aniya_blog/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://XieWeikai.github.io/aniya_blog/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/emoji-support/","title":"Emoji Support"}]