[{"content":"xv6 page tableç›¸å…³ä»£ç è§£æ è·ç¦»ä¸Šä¸€æ¬¡å®éªŒè¿‡äº†12å¤©å•¦ğŸ¤£ï¼Œé™©äº›å°±ä¸­é“å´©æ®‚äº†ğŸ™ƒ\nä¸è¿‡è™½ç„¶ä¹…äº†ç‚¹ï¼Œå¥½æ­¹è¿˜æ˜¯å®Œæˆäº†ç¬¬ä¸‰ä¸ªå®éªŒï¼Œä¹Ÿå°±æ˜¯ä¼ è¯´ä¸­çš„page tableç›¸å…³çš„å®éªŒã€‚è¿™éƒ¨åˆ†å®éªŒéœ€è¦ç†è§£riscvå¤„ç†å™¨çš„å¯»å€æ–¹å¼ï¼Œå¹¶æ˜ç™½xv6æºç ä¸­å’Œpage tableç›¸å…³çš„éƒ¨åˆ†ä»£ç æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚\nåœ¨æœ¬ç¯‡å†…å®¹ä¸­å…ˆä¸è®²å®ç°ï¼Œå…ˆçœ‹çœ‹æºç ä¸­çš„ç›¸å…³éƒ¨åˆ†ç©¶ç«Ÿåœ¨åšä»€ä¹ˆğŸ˜¤\nriscv å¯»å€æ–¹å¼ é¦–å…ˆè¦å¼„æ¸…æ¥šriscvçš„å¯»å€æ–¹å¼ï¼Œå¯»å€ç¤ºæ„å›¾å¦‚ä¸‹\nriscvä¸­è™šæ‹Ÿåœ°å€ä¸º64ä½ï¼Œç‰©ç†åœ°å€ä¸º56ä½(åšç¡¬ä»¶çš„è®¾è®¡çš„ï¼Œä»–ä»¬è§‰å¾—ç›®å‰ä»¥åŠçŸ­æ—¶é—´çš„æœªæ¥å¤Ÿç”¨äº†å§)ï¼Œå†…å­˜ç›¸å…³ç¡¬ä»¶å¯ä»¥ä½¿ç”¨åˆ†é¡µæœºåˆ¶ï¼Œè§„å®šä¸€é¡µå†…å­˜å¤§å°ä¸º4096 bytes($2^{12}$å­—èŠ‚)ã€‚ç”±äºä¸€é¡µ4096å­—èŠ‚ï¼Œæ•…è™šæ‹Ÿåœ°å€(virtual addressï¼Œç®€ç§° va)å’Œç‰©ç†åœ°å€(physical addressï¼Œç®€ç§°pa)ä½¿ç”¨12ä½ä½œä¸ºé¡µå†…åç§»(offset)ã€‚paçš„é«˜44ä½ä¸ºç‰©ç†é¡µå·(physical page numberï¼Œç®€ç§°ppn).\nsatpå¯„å­˜å™¨ ä»å‰é¢çš„é‚£å¼ å›¾å¯ä»¥çœ‹åˆ°ï¼Œriscvé‡‡ç”¨ä¸‰çº§é¡µè¡¨ï¼Œå°†ä¸‰çº§é¡µè¡¨åˆ†åˆ«è®°ä¸ºL2ã€L1ã€L0å…¶ä¸­2çº§ä¸ºæœ€é«˜ï¼Œ0çº§ä¸ºæœ€ä½ã€‚æ¯ä¸€å¼ é¡µè¡¨å æ®4096å­—èŠ‚ï¼Œå³å æ®ä¸€ä¸ªé¡µçš„å¤§å°ï¼Œæ•…é¡µè¡¨é¦–åœ°å€è®¾è®¡ä¸ºæŒ‰é¡µå¯¹é½ï¼Œè¿™æ ·å°±åªéœ€è¦è®°å½•ppnå³å¯çŸ¥é“é¡µè¡¨çš„ä½ç½®äº†ã€‚\nL2é¡µè¡¨çš„ppnè®°å½•åœ¨ä¸€ä¸ªç‰¹æ®Šçš„å¯„å­˜å™¨ä¸­ï¼Œå¯„å­˜å™¨å…¨ç¨‹ä¸º:Supervisor Address Translation and Protection (satp) Registerï¼Œæ ¹æ®æ‰‹å†Œï¼Œè¯¥å¯„å­˜å™¨ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤º\nåœ¨è¿™é‡Œå…ˆè§£é‡Šä¸€äº›æ¦‚å¿µå¦‚ä¸‹\nCSR: Control and Status Registerï¼Œé¡¾åæ€ä¹‰ï¼Œæœ‰ç€æ§åˆ¶ä½œç”¨æˆ–è€…è®°å½•çŠ¶æ€çš„å¯„å­˜å™¨ï¼Œå³æœ‰ç€ç‰¹æ®Šä½œç”¨çš„å¯„å­˜å™¨ï¼Œä¸€èˆ¬åªæœ‰ç‰¹æƒæŒ‡ä»¤ä¼šç”¨åˆ°è¿™äº›å¯„å­˜å™¨ã€‚ WARL: Write Any Values, Reads Legal Values.å³å¯ä»¥å†™å…¥ä»»ä½•å€¼ï¼Œä½†åªèƒ½è¯»åˆ°åˆæ³•å€¼ï¼Œä¹Ÿå°±æ˜¯è¯´å¦‚æœå†™å…¥ä¸åˆæ³•å€¼ï¼Œé‚£å†™å…¥ä¸ä¼šç”Ÿæ•ˆçš„ï¼Œä¸‹æ¬¡è¯»åˆ°çš„è¿˜æ˜¯åˆæ³•å€¼ã€‚ satpå°±æ˜¯ä¸€ä¸ªCSRï¼Œå…¶ä¸­åŒ…å«ä¸‰ä¸ªéƒ¨åˆ†ï¼šMODEã€ASIDå’ŒPPNï¼Œä½œç”¨å¦‚ä¸‹\nPPN:å³L2é¡µè¡¨çš„ppnï¼Œè¯¥ppnä½ä½å¡«12ä¸ª0å³ä¸ºL2é¡µè¡¨æ‰€åœ¨çš„ç‰©ç†åœ°å€ã€‚ ASIDï¼šä¸å¤ªæ¸…æ¥šå…·ä½“å¹²å•¥çš„ï¼Œæ‰‹å†Œæè¿°ä¸º: an address space identififier (ASID), which facilitates address-translation fences on a per-address-space basis. MODE:æ§åˆ¶vaåˆ°paçš„è½¬æ¢æ¨¡å¼ã€‚ MODEå­—æ®µå¯é€‰å€¼å³ä½œç”¨å¦‚ä¸‹\nå…¶ä¸­8å³ä¸ºxv6ä½¿ç”¨çš„MODEï¼Œå³ä½¿ç”¨åŸºäºåˆ†é¡µæœºåˆ¶çš„39ä½è™šæ‹Ÿåœ°å€ã€‚ä»å›¾1ä¹Ÿå¯ä»¥çœ‹å‡ºï¼Œè™šæ‹Ÿåœ°å€è™½ç„¶æœ‰64ä½ï¼Œä½†åªæœ‰ä½39ä½æœ‰ç”¨ï¼Œè¿™å°±æ˜¯å› ä¸ºxv6å°†MODEè®¾ä¸ºäº†8.\né¡µè¡¨ã€é¡µè¡¨é¡¹ å¦‚å›¾1æ‰€ç¤ºï¼Œä¸€å¼ é¡µè¡¨åŒ…å«512é¡¹ï¼Œæ¯ä¸€é¡¹ç§°ä¸ºé¡µè¡¨é¡¹(Page Table Entry, PTE)ï¼Œæ¯ä¸€é¡¹å 64 bitsï¼Œå¦‚å‰é¢æ‰€è¿°ï¼Œä¸€å¼ é¡µè¡¨å $512 \\times 64 \\ bits = 4096 \\ bytes$ï¼Œä¸ºä¸€é¡µçš„å¤§å°ã€‚\n$PTE$çš„ç»“æ„å¦‚ä¸‹\nå…¶ä¸­54-63ä¸ºä¿ç•™ä½ï¼Œ10-53è¿™44 bitsä¸ºä½ä¸€çº§é¡µè¡¨çš„ppnæˆ–ç›´æ¥æ˜¯æœ€ç»ˆç‰©ç†åœ°å€çš„ppn(L0é¡µè¡¨å†…çš„$PTE$ä¸­çš„ppnä¸ºæœ€ç»ˆç‰©ç†åœ°å€ppn).\n0-9è¿™10ä½ä¸ºæƒé™è®¾ç½®æ ‡å¿—ï¼Œä½œç”¨é¡¾åæ€ä¹‰ã€‚æ³¨æ„ï¼Œåœ¨è¯»ä»£ç æ—¶å‘ç°ï¼ŒL2ã€L1è¿™ä¸¤çº§é¡µè¡¨ä¸­è²Œä¼¼åªç”¨åˆ°Vè¿™ä¸ªä½ï¼ŒL0çº§é¡µè¡¨æ‰ç”¨åˆ°åˆ«çš„å„ä¸ªä½ã€‚\nå¯»å€æ–¹å¼ å¦‚å‰æ–‡æ‰€è¯´ï¼Œxv6ä½¿ç”¨$Sv39$ï¼Œè™šæ‹Ÿåœ°å€åªä½¿ç”¨ä½39ä½ï¼Œä½12ä½ä¸º$offset$ï¼Œå‰©ä¸‹$27\\ bits$åˆ†ä¸ºä¸‰éƒ¨åˆ†ï¼Œæ¯ä¸€éƒ¨åˆ†$9\\ bits$(å¯¹åº”512ä¸ª$PTE$)ï¼Œåˆ†åˆ«ä¸ºä¸‰çº§é¡µè¡¨çš„ç´¢å¼•ï¼Œäº§ç”Ÿæœ€ç»ˆç‰©ç†åœ°å€æ–¹å¼è§ä¸‹å›¾\nç‰©ç†åœ°å€layout ç”±ä¹‹å‰å­¦è¿‡çš„æ•°å­—é€»è¾‘ã€è®¡ç®—æœºç»„æˆåŸç†å¯ä»¥çŸ¥é“ï¼Œåœ°å€ä¸ä»…ä»…å¯ä»¥ç”¨æ¥æ˜ å°„åˆ°RAMï¼Œå…¶å®è¿˜å¯ä»¥é€šè¿‡MUX(multiplexer å¤šè·¯é€‰æ‹©å™¨)æ¥å°†ä¸åŒåœ°å€æ˜ å°„åˆ°ä¸åŒç¡¬ä»¶è®¾å¤‡ï¼Œå¦‚ROMã€RAMã€åˆ«çš„IOè®¾å¤‡ç­‰ç­‰ï¼Œxv6ç³»ç»Ÿä½¿ç”¨çš„æ¨¡æ‹Ÿç¯å¢ƒä¸‹ç‰©ç†åœ°å€ç©ºé—´çš„å¸ƒå±€å¦‚ä¸‹å›¾å³åŠéƒ¨åˆ†æ‰€ç¤º\nä¸Šå›¾ä¸­$KERNBASE$å’Œ$PHYSTOP$ä¹‹é—´çš„ç©ºé—´å³ä¸ºxv6ä½¿ç”¨çš„RAMç©ºé—´ï¼Œ$KERNBASE$ä¹‹ä¸‹çš„ç©ºé—´è¦ä¹ˆæ²¡ç”¨ï¼Œè¦ä¹ˆæ˜¯åˆ«çš„ä¸€äº›ç¡¬ä»¶ï¼Œå¦‚$0x1000$å¤„ä¸ºå¯åŠ¨ä»£ç æ‰€åœ¨çš„ROM.\nç‰©ç†å†…å­˜åˆ†é… riscvé‡‡ç”¨åˆ†é¡µæœºåˆ¶ï¼Œå†…å­˜åˆ†é…ä»¥é¡µä¸ºå•ä½ï¼Œå¦‚å‰æ–‡æ‰€ç¤ºï¼Œä»KERNBASEå¼€å§‹ä¸ºRAMï¼Œåˆ°PHYSTOPä¸ºæ­¢ã€‚å†…æ ¸çš„ä»£ç å’Œæ•°æ®åº“ä»KERNBASEå¼€å§‹è£…è½½ï¼Œå†…æ ¸ä»£ç å’Œæ•°æ®ç»“æŸåä¸€ç›´åˆ°PHYSTOPéƒ½æ˜¯ç©ºé—²çš„å¯ä»¥åˆ†é…çš„å†…å­˜ç©ºé—´ï¼Œxv6çš„å†…å­˜åˆ†é…å™¨å°±ä»è¿™ä¸€å—ç©ºé—´æ¥åˆ†é…ç©ºé—²é¡µã€‚\nåœ¨å¯åŠ¨æµç¨‹æ¦‚è¿°ä¸­è¯´è¿‡ï¼Œå†…æ ¸ä»£ç æœ€ä»entry.Så¼€å§‹æ‰§è¡Œï¼Œåˆå§‹åŒ–å„ä¸ªå¤„ç†å™¨çš„spå¯„å­˜å™¨(å³æ ˆ)ï¼Œç„¶åè·³åˆ°start.cä¸­çš„start()ï¼Œåœ¨å¯¹ç¡¬ä»¶è¿›è¡Œä¸€äº›è®¾ç½®åï¼Œé€šè¿‡mretæŒ‡ä»¤è·³è½¬åˆ°main.cä¸­çš„main()å‡½æ•°ï¼ŒåŒæ—¶è¿›å…¥supervisoræ¨¡å¼ï¼Œmain()å‡½æ•°æˆªå–éƒ¨åˆ†å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // start() jumps here in supervisor mode on all CPUs. void main() { if(cpuid() == 0){ consoleinit(); #if defined(LAB_PGTBL) || defined(LAB_LOCK) statsinit(); #endif printfinit(); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;xv6 kernel is booting\\n\u0026#34;); printf(\u0026#34;\\n\u0026#34;); kinit(); // physical page allocator ... } else { ... } scheduler(); } **ï¼ˆæ³¨æ„åœ¨æ‰§è¡Œè¿™éƒ¨åˆ†ä»£ç çš„æ—¶å€™ï¼Œsatpå¯„å­˜å™¨çš„modeè¿˜æ²¡æœ‰è®¾ç½®æˆå¼€å¯åˆ†é¡µæœºåˆ¶ï¼Œæ­¤æ—¶è™šæ‹Ÿåœ°å€ä¸ç»ç¿»è¯‘ç›´æ¥ä½œä¸ºç‰©ç†åœ°å€ï¼Œæ•…ä¸‹é¢ç”¨åˆ°çš„åœ°å€å‡ä¸ºå‰æ–‡ä¸­ç‰©ç†å†…å­˜å¸ƒå±€æè¿°çš„é‚£æ ·ï¼‰**å…¶ä¸­kinit()å‡½æ•°å°±æ˜¯å¯¹ç©ºé—²é¡µåˆ†é…å™¨çš„åˆå§‹åŒ–æ“ä½œï¼Œæ¥ä¸‹æ¥çœ‹çœ‹è¿™ä¸ªåˆ†é…å™¨çš„å®ç°ï¼Œæºç è§kalloc.cï¼Œkinit()å‡½æ•°å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 extern char end[]; // first address after kernel. // defined by kernel.ld. void kinit() { initlock(\u0026amp;kmem.lock, \u0026#34;kmem\u0026#34;); freerange(end, (void*)PHYSTOP); } ç”±äºè¿˜æ²¡å­¦åˆ°é”ï¼Œç¬¬ä¸€å¥initlockå…ˆä¸ç®¡ï¼Œendä¸ºå†…æ ¸ä»£ç å’Œæ•°æ®ç»“æŸåçš„é¦–åœ°å€ï¼Œå®šä¹‰è§é“¾æ¥è„šæœ¬kernel.ldï¼ˆæš‚æ—¶æ²¡å­¦è¿‡é“¾æ¥è„šæœ¬ï¼Œå¯ä»¥å‚è€ƒ è¯¥æ–‡ç« ï¼ŒPHYSTOPæ„ä¹‰è§å‰ä¸€èŠ‚ï¼Œå®šä¹‰åœ¨memlayout.hä¸­ã€‚æ¥ç€çœ‹çœ‹æ¥å—äº†endå’ŒPHYSTOPå‚æ•°çš„freerangeå¹²äº†å•¥ï¼Œè¯¥å‡½æ•°å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 // define in riscv.h #define PGROUNDUP(sz) (((sz)+PGSIZE-1) \u0026amp; ~(PGSIZE-1)) void freerange(void *pa_start, void *pa_end) { char *p; p = (char*)PGROUNDUP((uint64)pa_start); for(; p + PGSIZE \u0026lt;= (char*)pa_end; p += PGSIZE) kfree(p); } å¯ä»¥çœ‹åˆ°ï¼Œè¯¥å‡½æ•°å¯¹pa_startåˆ°pa_endä¹‹é—´æ‰€æœ‰å®Œæ•´çš„é¡µçš„é¦–åœ°å€å‡è°ƒç”¨äº†ä¸€æ¬¡kfreeå‡½æ•°ï¼Œæ¥ç€åœ¨çœ‹çœ‹kfreeå¹²ä»€ä¹ˆï¼Œå¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 struct run { struct run *next; }; struct { struct spinlock lock; struct run *freelist; } kmem; // Free the page of physical memory pointed at by v, // which normally should have been returned by a // call to kalloc(). (The exception is when // initializing the allocator; see kinit above.) void kfree(void *pa) { struct run *r; if(((uint64)pa % PGSIZE) != 0 || (char*)pa \u0026lt; end || (uint64)pa \u0026gt;= PHYSTOP) panic(\u0026#34;kfree\u0026#34;); // Fill with junk to catch dangling refs. memset(pa, 1, PGSIZE); r = (struct run*)pa; acquire(\u0026amp;kmem.lock); r-\u0026gt;next = kmem.freelist; kmem.freelist = r; release(\u0026amp;kmem.lock); } åœ¨è¿™ç¯‡æ–‡ç« ä¸­å…ˆå¿½ç•¥lockæ˜¯æ€ä¹ˆå®ç°çš„ï¼Œå°±ç®—ä»–æ˜¯å¯¹çš„ã€‚ä¸Šé¢çš„kfreeå‡½æ•°é¦–å…ˆæ£€æµ‹ç»™çš„åœ°å€æ˜¯ä¸æ˜¯é¡µçš„é¦–åœ°å€ä»¥åŠç»™å®šåœ°å€èŒƒå›´æ˜¯å¦æ­£ç¡®ï¼Œæ¥ç€å¾€è¯¥è¦é‡Šæ”¾çš„ç©ºé—´å¡«å…¥åƒåœ¾æ•°æ®(è¿™æ˜¯ä¸ºäº†è®©ä½¿ç”¨å·²é‡Šæ”¾å†…å­˜çš„ç¨‹åºå°½å¿«å´©æºƒ)ï¼Œæœ€åä½¿ç”¨è¯¥é¡µçš„å¼€å¤´ä¸€å°éƒ¨åˆ†ç©ºé—´å¡«å……ä¸€ä¸ªstruct runç»“æ„ï¼Œå°†è¯¥èŠ‚ç‚¹ä¸²è¿›kmem.freelistè¿™ä¸ªé“¾è¡¨å†…ã€‚\næ•…æ‰§è¡Œå®Œfreerangeåï¼Œå¯ç”¨çš„ç©ºé—²é¡µå‡è¢«ä¸²è¿›äº†kmem.freelistè¿™ä¸ªç©ºé—²é“¾è¡¨å†…äº†ï¼Œåˆ†é…å™¨åˆå§‹åŒ–å®Œæ¯•ã€‚\nkinitåˆ†é…å™¨åˆå§‹åŒ–å‡½æ•°åˆ†æå®Œæ¯•ï¼Œé¡ºå¸¦å°†é‡Šæ”¾é¡µçš„å‡½æ•°kfreeä¹Ÿçœ‹è¿‡äº†ï¼Œæ¥ç€çœ‹çœ‹åˆ†é…ç©ºé—²é¡µçš„å‡½æ•°ï¼Œå¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Allocate one 4096-byte page of physical memory. // Returns a pointer that the kernel can use. // Returns 0 if the memory cannot be allocated. void * kalloc(void) { struct run *r; acquire(\u0026amp;kmem.lock); r = kmem.freelist; if(r) kmem.freelist = r-\u0026gt;next; release(\u0026amp;kmem.lock); if(r) memset((char*)r, 5, PGSIZE); // fill with junk return (void*)r; } å¯ä»¥çœ‹åˆ°è¯¥åˆ†é…å‡½æ•°éå¸¸ç®€å•ï¼Œä»kmem.freelistä¸­å–å‡ºä¸€ä¸ªç©ºé—²é¡µè¿”å›å³å¯ã€‚\næœ¬å°èŠ‚çœ‹åˆ°äº†ä¸€ä¸ªæç®€å†…å­˜åˆ†é…å™¨çš„å·¥ä½œæ–¹å¼ï¼Œä¹¦ä¸Šå­¦è¿‡çš„ç†è®ºçŸ¥è¯†ä¸€ç‚¹éƒ½æ²¡æœ‰ç”¨åˆ°æğŸ˜€ï¼Œæ¯•ç«Ÿxv6åªæ˜¯ä¸ªæç®€çš„æ•™å­¦æ“ä½œç³»ç»Ÿã€‚ä¸è¿‡ä¹Ÿçœ‹åˆ°äº†çœŸæ­£çš„ä¸€ä¸ªåˆ†é…å™¨ä¹Ÿç®—æœ‰æ‰€æ”¶è·ã€‚\nå†…æ ¸åœ°å€ç©ºé—´ æ³¨æ„ï¼šæŒ‡ä»¤ä¸­ç”¨åˆ°çš„æ‰€æœ‰åœ°å€å‡ä¸ºè™šæ‹Ÿåœ°å€ï¼Œè™šæ‹Ÿåœ°å€å¦‚ä½•è½¬æ¢ä¸ºç‰©ç†åœ°å€ç”±satpä¸­çš„MODEå†³å®šï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬è¿˜æ²¡æœ‰å¼€å¯åˆ†é¡µæœºåˆ¶ï¼Œä¸è¿›è¡Œåœ°å€ç¿»è¯‘ï¼Œå³è™šæ‹Ÿåœ°å€ç›´æ¥ä½œä¸ºç‰©ç†åœ°å€ã€‚\nwalk è¯¥å‡½æ•°åœ¨xv6å’Œpage tableç›¸å…³çš„ä»£ç ä¸­å¯ä»¥è¯´æ˜¯åŸºçŸ³èˆ¬çš„å­˜åœ¨ï¼Œå› æ­¤æœ¬æ–‡å…ˆä»è¯¥å‡½æ•°è®²èµ·ï¼Œè¯¥å‡½æ•°çš„è¡Œä¸ºå°±æ˜¯æ¨¡æ‹ŸMMUçš„è¡Œä¸ºï¼Œæ‰¾åˆ°ä¸€ä¸ªVAåœ¨page tableä¸­å¯¹åº”çš„pteå¯¹åº”çš„æ¡ç›®ï¼Œå…·ä½“ç»†èŠ‚å¾…ä¼šå†è¯´ã€‚\nç›¸å…³çš„å® åœ¨riscv.hä¸­å®šä¹‰äº†å¾ˆå¤šç›¸å…³çš„å®ï¼ŒæŒ‘é€‰ä¸€äº›åˆ—ä¸¾å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #define PGSIZE 4096 // bytes per page #define PGSHIFT 12 // bits of offset within a page #define PGROUNDUP(sz) (((sz)+PGSIZE-1) \u0026amp; ~(PGSIZE-1)) #define PGROUNDDOWN(a) (((a)) \u0026amp; ~(PGSIZE-1)) // shift a physical address to the right place for a PTE. #define PA2PTE(pa) ((((uint64)pa) \u0026gt;\u0026gt; 12) \u0026lt;\u0026lt; 10) #define PTE2PA(pte) (((pte) \u0026gt;\u0026gt; 10) \u0026lt;\u0026lt; 12) // extract the three 9-bit page table indices from a virtual address. #define PXMASK 0x1FF // 9 bits #define PXSHIFT(level) (PGSHIFT+(9*(level))) #define PX(level, va) ((((uint64) (va)) \u0026gt;\u0026gt; PXSHIFT(level)) \u0026amp; PXMASK) // one beyond the highest possible virtual address. // MAXVA is actually one bit less than the max allowed by // Sv39, to avoid having to sign-extend virtual addresses // that have the high bit set. #define MAXVA (1L \u0026lt;\u0026lt; (9 + 9 + 9 + 12 - 1)) #define PTE_V (1L \u0026lt;\u0026lt; 0) // valid #define PTE_R (1L \u0026lt;\u0026lt; 1) #define PTE_W (1L \u0026lt;\u0026lt; 2) #define PTE_X (1L \u0026lt;\u0026lt; 3) #define PTE_U (1L \u0026lt;\u0026lt; 4) // 1 -\u0026gt; user can access å„ä¸ªå®çš„æ„ä¹‰éƒ½æ¯”è¾ƒæ˜æ˜¾ï¼Œä»åå­—å°±å¯ä»¥çœ‹å‡ºåŠŸèƒ½ã€‚åœ¨è¿™é‡Œè§£é‡Šä¸€ä¸‹PXè¿™ä¸ªå®ï¼Œè¿™ä¸ªå®æ˜¯ç”¨æ¥å–å‡ºä¸€ä¸ªvaä¸­L2ã€L1ã€L0è¿™å‡ éƒ¨åˆ†å¯¹åº”çš„æ•°å­—çš„\nå¦‚ä¸Šå›¾ï¼ŒPX(2,va)å³ä¸ºå›¾ä¸­L2éƒ¨åˆ†çš„æ•°å­—ï¼ŒåŒç†PX(1,va)å’ŒPX(0,va)ä¸ºä¸Šå›¾ä¸­L1å’ŒL0å¯¹åº”çš„æ•°å­—ã€‚\nç±»å‹å®šä¹‰ åŒæ ·åœ¨riscv.hä¸­å®šä¹‰äº†å‡ ä¸ªæœ‰ç”¨çš„ç±»å‹\n1 2 typedef uint64 pte_t; typedef uint64 *pagetable_t; // 512 PTEs å…¶ä¸­pte_tå³ä¸ºå‰é¢è®²è¿‡çš„Page table entryï¼Œä¸€ä¸ªpte64ä½ï¼Œæ•…å…¶å®å°±æ˜¯uint64.è€Œä¸€ä¸ªpagetable_tå³ä¸€å¼ é¡µè¡¨çš„é¦–åœ°å€ï¼Œæ•…å…¶å®é™…ç±»å‹ä¸ºuint64 *ï¼Œå…¶å®å°±æ˜¯pte_t *ï¼Œå‰æ–‡è¯´åˆ°è¿‡ï¼Œä¸€å¼ é¡µè¡¨å ä¸€é¡µï¼Œå³4096 bytesï¼Œæœ‰512ä¸ªpte.\nwalkåŠŸèƒ½ walkå‡½æ•°åŠŸèƒ½å…¶å®å°±æ˜¯ç»™å®šä¸€ä¸ªvaå’Œæ ¹é¡µè¡¨(å³å‰æ–‡è¯´çš„L2çº§çš„é¡µè¡¨)ï¼Œæ ¹æ®vaæ‰¾åˆ°å¯¹åº”çš„pteï¼Œå¹¶å°†è¯¥pteçš„åœ°å€è¿”å›ï¼Œå‡½æ•°å®šä¹‰å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 pte_t * walk(pagetable_t pagetable, uint64 va, int alloc) { if(va \u0026gt;= MAXVA) // va è¶…èŒƒå›´ panic panic(\u0026#34;walk\u0026#34;); for(int level = 2; level \u0026gt; 0; level--) { // ä»æœ€é«˜ä¸€çº§é¡µè¡¨å¼€å§‹é€å±‚æ‰¾pte pte_t *pte = \u0026amp;pagetable[PX(level, va)]; // æ‰¾åˆ°è¯¥å±‚å¯¹åº”çš„pte if(*pte \u0026amp; PTE_V) { // è¯¥pteæœ‰æ•ˆåˆ™æ‰¾åˆ°äº†ï¼Œå¾€ä¸‹èµ°ä¸€å±‚ pagetable = (pagetable_t)PTE2PA(*pte); } else { if(!alloc || (pagetable = (pde_t*)kalloc()) == 0) // å¦‚æœalloc != 0åˆ™ä¼šåˆ†é…ä¸€å¼ é¡µè¡¨ return 0; // alloc == 0 æˆ–è€… åˆ†é…ç©ºé—²é¡µå¤±è´¥ è¿”å›0 memset(pagetable, 0, PGSIZE); // åˆ†é…çš„é¡µåšç©ºé¡µè¡¨ï¼Œpteå…¨è®¾ä¸º0 *pte = PA2PTE(pagetable) | PTE_V; // æ¥ç€å¾€ä¸‹èµ° } } return \u0026amp;pagetable[PX(0, va)]; // è¿”å›pteå¯¹åº”çš„åœ°å€ } ä¸Šé¢çš„walkå‡½æ•°ä¸ä»…å¯ä»¥æ¨¡ä»¿MMUæ‰¾åˆ°pteï¼Œè¿˜å¯ä»¥é€šè¿‡allocå‚æ•°æ§åˆ¶åˆ†é…æœ¬æ¥ä¸å­˜åœ¨çš„é¡µè¡¨ã€‚è¿™ä¸ªåŠŸèƒ½éå¸¸æœ‰ç”¨ï¼Œæ¯”å¦‚ç°åœ¨æŸä¸ªvaåœ¨é¡µè¡¨ä¸­æ²¡æœ‰å¯¹åº”çš„é¡¹ï¼Œå¯ä»¥é€šè¿‡walk(pg,va,1)æ¥åœ¨é¡µè¡¨ä¸­åˆ›å»ºåŸæœ¬æ²¡æœ‰çš„é¡µè¡¨ï¼Œæœ€åè¿”å›vaå¯¹åº”çš„pteåœ°å€ï¼Œè®¾ç½®pteå³å¯é…ç½®vaæ˜ å°„åˆ°å“ªä¸ªç‰©ç†åœ°å€ä»¥åŠå¯¹åº”çš„æƒé™äº†ã€‚ä»è¿™é‡Œä¹Ÿå¯ä»¥çœ‹å‡ºä¸‰çº§é¡µè¡¨çš„å¥½å¤„ï¼Œæ²¡ç”¨åˆ°çš„é¡¹ä¸ä¼šåˆ†é…ç©ºé—´ï¼Œç›¸æ¯”ä¸€çº§é¡µè¡¨å ç”¨ç©ºé—´å°‘ã€‚\nmappages æœ‰äº†walkå‡½æ•°ï¼Œå¯ä»¥å¾ˆå®¹æ˜“çš„æŠŠæŸä¸ªvaæ˜ å°„åˆ°å¯¹åº”çš„paä¸Šå¹¶è®¾ç½®å¯¹åº”æƒé™ï¼Œå…·ä½“æ–¹æ³•åœ¨ä¸Šé¢æè¿°äº†ä¸€ä¸‹ï¼Œåœ¨æºç ä¸­ï¼Œå°è£…äº†ä¸€ä¸ªmappageså‡½æ•°ä¸“é—¨åšvaåˆ°paçš„æ˜ å°„ï¼Œè¯¥å‡½æ•°å®šä¹‰å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Create PTEs for virtual addresses starting at va that refer to // physical addresses starting at pa. va and size might not // be page-aligned. Returns 0 on success, -1 if walk() couldn\u0026#39;t // allocate a needed page-table page. int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm) { uint64 a, last; pte_t *pte; a = PGROUNDDOWN(va); // å¼€å§‹è¦åšæ˜ å°„çš„è™šæ‹Ÿé¡µ last = PGROUNDDOWN(va + size - 1); // æœ€åä¸€é¡µè¦åšæ˜ å°„çš„è™šæ‹Ÿé¡µ for(;;){ if((pte = walk(pagetable, a, 1)) == 0) // æ­¤å¤„walkçš„alloc ä¸º1 éœ€è¦åˆ†é…æœ¬æ¥æ²¡æœ‰çš„é¡µè¡¨ return -1; // åˆ†é…å¤±è´¥ if(*pte \u0026amp; PTE_V) // è¿™ä¸ªvaå·²ç»æ˜ å°„è¿‡äº†ï¼Œé‡æ–°æ˜ å°„ä¹Ÿè®¸æ˜¯æ— æ„ä¸ºä¹‹ï¼Œpanicä»¥æå‰å‘ç°é”™è¯¯ panic(\u0026#34;remap\u0026#34;); *pte = PA2PTE(pa) | perm | PTE_V; // è®¾ç½®ppnå’Œflagï¼Œå³æ˜ å°„åˆ°çš„ç‰©ç†åœ°å€å’Œè®¿é—®æƒé™ if(a == last) // åˆ†é…å®Œæ¯• break; a += PGSIZE; // ä¸‹ä¸€é¡µ pa += PGSIZE; // ä¸‹ä¸€é¡µ } return 0; } æœ‰äº†mappagesï¼Œå¯ä»¥å¾ˆå®¹æ˜“çš„å°†ä¸€å—è¿ç»­çš„è™šæ‹Ÿåœ°å€ç©ºé—´æ˜ å°„åˆ°ä¸€å—è¿ç»­çš„ç‰©ç†åœ°å€ç©ºé—´ä¸Šã€‚\nkvmmap å‘½åæœ‰è¿¹å¯å¾ªï¼Œkæ˜¯æŒ‡kernelï¼Œvmæ˜¯virtual memoryï¼Œkvmå¼€å¤´çš„å‡½æ•°å’Œå†…æ ¸çš„è™šæ‹Ÿåœ°å€ç©ºé—´æœ‰å…³ã€‚uæ˜¯userï¼Œuvmå¼€å¤´çš„å‡½æ•°å’Œç”¨æˆ·çš„è™šæ‹Ÿåœ°å€ç©ºé—´æœ‰å…³ï¼Œå…¶ä¸­kvmmapæ˜¯ç»™å†…æ ¸ä½¿ç”¨çš„é¡µè¡¨åšæ˜ å°„ï¼Œå…¶å®å°±æ˜¯å¯¹mappagesçš„å°è£…ï¼Œå…¶å®šä¹‰å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 // add a mapping to the kernel page table. // only used when booting. // does not flush TLB or enable paging. void kvmmap(uint64 va, uint64 pa, uint64 sz, int perm) { if(mappages(kernel_pagetable, va, sz, pa, perm) != 0) panic(\u0026#34;kvmmap\u0026#34;); } å…¶ä¸­çš„kernel_pagetableæ˜¯ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œå³å†…æ ¸çš„é¡µè¡¨ï¼Œåœ¨åé¢ä¼šçœ‹åˆ°è¯¥å˜é‡åœ¨å“ªé‡Œåˆå§‹åŒ–ã€‚\nå†…æ ¸åœ°å€ç©ºé—´åˆå§‹åŒ– åœ¨ç‰©ç†å†…å­˜åˆ†é…é‚£ä¸€å°èŠ‚è¯´è¿‡ï¼Œç³»ç»Ÿå¯åŠ¨æ—¶ï¼Œmainé€šè¿‡è°ƒç”¨kinitåˆå§‹åŒ–äº†å†…å­˜åˆ†é…å™¨ï¼Œå†å›è¿‡å¤´çœ‹çœ‹mainå¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // start() jumps here in supervisor mode on all CPUs. void main() { if(cpuid() == 0){ consoleinit(); #if defined(LAB_PGTBL) || defined(LAB_LOCK) statsinit(); #endif printfinit(); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;xv6 kernel is booting\\n\u0026#34;); printf(\u0026#34;\\n\u0026#34;); kinit(); // physical page allocator kvminit(); // create kernel page table kvminithart(); // turn on paging procinit(); // process table ... userinit(); // first user process ... } else { ... } scheduler(); } kinitå‡½æ•°æ¥ä¸‹å»å°±æ˜¯kvminitï¼Œè¯¥å‡½æ•°åˆå§‹åŒ–å†…æ ¸çš„è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œå³è®¾ç½®å†…æ ¸çš„é¡µè¡¨ï¼Œå…¶å®šä¹‰å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // è¾…åŠ©å‡½æ•°ï¼Œå®šä¹‰åœ¨string.c é¡¾åæ€ä¹‰ï¼Œè®¾ç½®å†…å­˜çš„ void* memset(void *dst, int c, uint n) { char *cdst = (char *) dst; int i; for(i = 0; i \u0026lt; n; i++){ cdst[i] = c; } return dst; } /* * the kernel\u0026#39;s page table. */ pagetable_t kernel_pagetable; void kvminit() { kernel_pagetable = (pagetable_t) kalloc(); // æ ¹é¡µè¡¨é¦–å…ˆéœ€è¦åˆ†é…ä¸€é¡µç©ºé—´ memset(kernel_pagetable, 0, PGSIZE); // å…¨éƒ¨pteè®¾ä¸º0 // uart registers kvmmap(UART0, UART0, PGSIZE, PTE_R | PTE_W); // virtio mmio disk interface kvmmap(VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W); // CLINT kvmmap(CLINT, CLINT, 0x10000, PTE_R | PTE_W); // PLIC kvmmap(PLIC, PLIC, 0x400000, PTE_R | PTE_W); // map kernel text executable and read-only. kvmmap(KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X); // map kernel data and the physical RAM we\u0026#39;ll make use of. kvmmap((uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W); // map the trampoline for trap entry/exit to // the highest virtual address in the kernel. kvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X); } kvminitå°†è™šæ‹Ÿåœ°å€ç©ºé—´çš„å„ä¸ªåœ°å€æ˜ å°„åˆ°ç‰©ç†åœ°å€ç©ºé—´çš„å„ä¸ªéƒ¨åˆ†ï¼Œå…·ä½“å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤º\nç”±ä¸Šå›¾å¾ˆå®¹æ˜“ç†è§£kvminitçš„åŠŸèƒ½ğŸ˜‹ï¼Œç‰¹åˆ«æ³¨æ„åˆ°é™¤äº†è™šæ‹Ÿåœ°å€ç©ºé—´ä¸­éå¸¸é«˜ä½çš„é‚£éƒ¨åˆ†(MAXVAå‘ä¸‹çš„Trampolineå’ŒKstack)ï¼Œå…¶ä»–çš„éƒ¨åˆ†å‡ä¸ºæ’ç­‰æ˜ å°„ï¼Œå³vaæ˜ å°„åçš„paä¸vaç›¸åŒã€‚\nå¯åŠ¨åˆ†é¡µæœºåˆ¶ ä»mainä»£ç å¯ä»¥çœ‹åˆ°ï¼Œkvminitåä¸‹ä¸€ä¸ªæ˜¯kvminithartï¼Œè¿™ä¸ªå‡½æ•°è®¾ç½®äº†satpå¯„å­˜å™¨ï¼Œå¼€å¯é¡µè¡¨å¹¶æ¸…é™¤TLBç¼“å­˜(TLBå°±æ˜¯è®¡ç»„å’Œcsappé‡Œè¯´çš„é‚£ä¸ªç¼“å­˜é¡µè¡¨å†…å®¹çš„ç¼“å­˜)ï¼Œå¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // use riscv\u0026#39;s sv39 page table scheme. #define SATP_SV39 (8L \u0026lt;\u0026lt; 60) #define MAKE_SATP(pagetable) (SATP_SV39 | (((uint64)pagetable) \u0026gt;\u0026gt; 12)) // supervisor address translation and protection; // holds the address of the page table. static inline void w_satp(uint64 x) { asm volatile(\u0026#34;csrw satp, %0\u0026#34; : : \u0026#34;r\u0026#34; (x)); } // flush the TLB. static inline void sfence_vma() { // the zero, zero means flush all TLB entries. asm volatile(\u0026#34;sfence.vma zero, zero\u0026#34;); } // Switch h/w page table register to the kernel\u0026#39;s page table, // and enable paging. void kvminithart() { w_satp(MAKE_SATP(kernel_pagetable)); sfence_vma(); } å¦‚ä¸Šï¼Œw_satpæ˜¯ç”¨å†…è”æ±‡ç¼–å†™çš„å‡½æ•°ï¼Œä½œç”¨å°±æ˜¯å†™satpå¯„å­˜å™¨ï¼Œè¿™è¡Œä»£ç å°†satpçš„MODEè®¾ä¸ºsv39ï¼Œppnè®¾ä¸ºkernel_pagetableçš„ppn.ä¸‹ä¸€è¡Œçš„sfence_vmaæ¸…é™¤TLBç¼“å­˜.kvminithartåï¼Œåˆ†é¡µæœºåˆ¶å¯åŠ¨ï¼Œæ¥ä¸‹æ¥æ‰€æœ‰æŒ‡ä»¤ç”¨åˆ°çš„åœ°å€éƒ½ä¼šé€šè¿‡é¡µè¡¨ç¿»è¯‘ä¸ºpa.\nåˆ°è¿™é‡Œï¼Œé¡µè¡¨çš„åŸºæœ¬ä½¿ç”¨å’Œå†…æ ¸åœ°å€ç©ºé—´åˆ†å¸ƒå‡ä»‹ç»å®Œæ¯•ï¼Œæ¥ä¸‹æ¥çœ‹çœ‹å’Œè¿›ç¨‹ç›¸å…³çš„å†…å®¹ã€‚\nè¿›ç¨‹åˆå§‹åŒ– åœ¨kvminithartåæ˜¯procinitï¼Œè¯¥å‡½æ•°å®šä¹‰å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // Per-process state struct proc { struct spinlock lock; // p-\u0026gt;lock must be held when using these: enum procstate state; // Process state struct proc *parent; // Parent process void *chan; // If non-zero, sleeping on chan int killed; // If non-zero, have been killed int xstate; // Exit status to be returned to parent\u0026#39;s wait int pid; // Process ID // these are private to the process, so p-\u0026gt;lock need not be held. uint64 kstack; // Virtual address of kernel stack uint64 sz; // Size of process memory (bytes) pagetable_t pagetable; // User page table struct trapframe *trapframe; // data page for trampoline.S struct context context; // swtch() here to run process struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory char name[16]; // Process name (debugging) }; struct proc proc[NPROC]; // initialize the proc table at boot time. void procinit(void) { struct proc *p; initlock(\u0026amp;pid_lock, \u0026#34;nextpid\u0026#34;); for(p = proc; p \u0026lt; \u0026amp;proc[NPROC]; p++) { initlock(\u0026amp;p-\u0026gt;lock, \u0026#34;proc\u0026#34;); // Allocate a page for the process\u0026#39;s kernel stack. // Map it high in memory, followed by an invalid // guard page. char *pa = kalloc(); if(pa == 0) panic(\u0026#34;kalloc\u0026#34;); uint64 va = KSTACK((int) (p - proc)); kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W); p-\u0026gt;kstack = va; } kvminithart(); } ä¸Šé¢ä»£ç ç»™æ¯ä¸ªprocåˆå§‹åŒ–äº†ä¸€ä¸ªé”ï¼Œå¹¶åˆ†äº†ä¸€é¡µä½œä¸ºkernel stackï¼Œkernel stackåœ¨è™šæ‹Ÿåœ°å€ç©ºé—´æ‰€å¤„ä½ç½®è§å†…æ ¸åœ°å€ç©ºé—´åˆå§‹åŒ–ä¸­çš„å¸ƒå±€å›¾ã€‚\nä¸Šé¢ä»£ç ä¸­çš„å®KSTACKå®šä¹‰å¦‚ä¸‹\n1 2 3 // map kernel stacks beneath the trampoline, // each surrounded by invalid guard pages. #define KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE) ä»å‰é¢å¸ƒå±€å›¾ä¸­å®¹æ˜“çœ‹å‡ºï¼Œä»trampolineå‘ä¸‹ï¼Œæ¯ä¸¤é¡µä¸­ä½¿ç”¨ä¸€é¡µä½œä¸ºkstackï¼Œå¦ä¸€é¡µç”¨ä½œguard page(è‹¥è®¿é—®è¶…è¿‡æ ˆç©ºé—´ï¼Œå°±ä¼šè®¿é—®åˆ°guard pageçš„åœ°å€ï¼Œè¯¥åœ°å€åœ¨é¡µè¡¨ä¸­æ²¡æœ‰å¯¹åº”çš„æ˜ å°„ï¼Œæ•…äº§ç”Ÿé¡µé”™è¯¯ï¼Œä¸­æ–­è¿›è¡Œå¤„ç†)ã€‚\nè¿™ä¸ªkernel stackçš„ä½œç”¨æš‚æ—¶è¿˜ä¸æ¸…æ¥šæ˜¯ä»€ä¹ˆï¼Œçœ‹åå­—å¯èƒ½æ˜¯æŸä¸ªè¿›ç¨‹ä½¿ç”¨å†…æ ¸(å¦‚ç³»ç»Ÿè°ƒç”¨)æ—¶å†…æ ¸ä½¿ç”¨çš„æ ˆå§ã€‚\nç¬¬ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹ ç»™æ¯ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹å‡åˆ†é…ä¸€ä¸ªé¡µè¡¨ï¼Œå³æ¯ä¸€ä¸ªè¿›ç¨‹æœ‰å®ƒè‡ªå·±çš„è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œè¯¥ç©ºé—´å¸ƒå±€å¦‚ä¸‹å›¾æ‰€ç¤º\nåœ¨å¯åŠ¨æµç¨‹æ¦‚è¿°ä¸­è¯´è¿‡ï¼Œç¬¬ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹è§initcode.Sï¼Œå…¶å†…å®¹å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # Initial process that execs /init. # This code runs in user space. #include \u0026#34;syscall.h\u0026#34; # exec(init, argv) .globl start start: la a0, init la a1, argv li a7, SYS_exec ecall # for(;;) exit(); exit: li a7, SYS_exit ecall jal exit # char init[] = \u0026#34;/init\\0\u0026#34;; init: .string \u0026#34;/init\\0\u0026#34; # char *argv[] = { init, 0 }; .p2align 2 argv: .long init .long 0 æ¥ä¸‹æ¥çœ‹çœ‹ç¬¬ä¸€ä¸ªè¿›ç¨‹å…·ä½“æ˜¯å¦‚ä½•å¯åŠ¨èµ·æ¥çš„ï¼Œåœ¨mainå‡½æ•°ä¸­ï¼Œæœ‰å¦‚ä¸‹åˆå§‹åŒ–ä»£ç \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // start() jumps here in supervisor mode on all CPUs. void main() { if(cpuid() == 0){ ... userinit(); // first user process __sync_synchronize(); started = 1; } else { ... } scheduler(); } å¯ä»¥çœ‹åˆ°æœ€åä¸€æ­¥åˆå§‹åŒ–ä¸ºuserinitï¼Œè¯¥å‡½æ•°åˆå§‹åŒ–äº†ç¬¬ä¸€ä¸ªè¿›ç¨‹ï¼Œå®šä¹‰å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Set up first user process. void userinit(void) { struct proc *p; p = allocproc(); // set trampoline and trapframe initproc = p; // allocate one user page and copy init\u0026#39;s instructions // and data into it. uvminit(p-\u0026gt;pagetable, initcode, sizeof(initcode)); // allocate one page and copy data in it p-\u0026gt;sz = PGSIZE; // prepare for the very first \u0026#34;return\u0026#34; from kernel to user. p-\u0026gt;trapframe-\u0026gt;epc = 0; // user program counter p-\u0026gt;trapframe-\u0026gt;sp = PGSIZE; // user stack pointer safestrcpy(p-\u0026gt;name, \u0026#34;initcode\u0026#34;, sizeof(p-\u0026gt;name)); p-\u0026gt;cwd = namei(\u0026#34;/\u0026#34;); p-\u0026gt;state = RUNNABLE; release(\u0026amp;p-\u0026gt;lock); } è¯¥å‡½æ•°é¦–å…ˆè°ƒç”¨allocprocè¿”å›äº†ä¸€ä¸ªå¯ç”¨çš„struct proc*ï¼Œè¯¥å‡½æ•°å®šä¹‰å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // Look in the process table for an UNUSED proc. // If found, initialize state required to run in the kernel, // and return with p-\u0026gt;lock held. // If there are no free procs, or a memory allocation fails, return 0. static struct proc* allocproc(void) { struct proc *p; // ä»procä¸­æ‰¾ä¸€ä¸ªUNUSEDçš„ç©ºä½ for(p = proc; p \u0026lt; \u0026amp;proc[NPROC]; p++) { acquire(\u0026amp;p-\u0026gt;lock); if(p-\u0026gt;state == UNUSED) { goto found; } else { release(\u0026amp;p-\u0026gt;lock); } } return 0; found: // æ‰¾åˆ°UNUSEDçš„å¯ä¾›ä½¿ç”¨ p-\u0026gt;pid = allocpid(); // åˆ†é…ä¸€ä¸ªpid ,ä¹Ÿå°±æ˜¯å½“å‰æ²¡æœ‰ç”¨çš„æœ€å°çš„æ•´æ•° // Allocate a trapframe page. if((p-\u0026gt;trapframe = (struct trapframe *)kalloc()) == 0){ release(\u0026amp;p-\u0026gt;lock); return 0; } // An empty user page table. p-\u0026gt;pagetable = proc_pagetable(p); // proc_pagetableæ˜ å°„äº†è™šæ‹Ÿå†…å­˜çš„trapframe å’Œtrampoline if(p-\u0026gt;pagetable == 0){ freeproc(p); release(\u0026amp;p-\u0026gt;lock); return 0; } // Set up new context to start executing at forkret, // which returns to user space. memset(\u0026amp;p-\u0026gt;context, 0, sizeof(p-\u0026gt;context)); p-\u0026gt;context.ra = (uint64)forkret; // raæ˜¯return address p-\u0026gt;context.sp = p-\u0026gt;kstack + PGSIZE; // spæ˜¯stack pointer return p; } (åŠŸèƒ½è§ä»£ç å’Œæ³¨é‡Š) æ¥ç€userinitè°ƒç”¨uvminit(initcode)ï¼Œå®šä¹‰å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 void uvminit(pagetable_t pagetable, uchar *src, uint sz) { char *mem; if(sz \u0026gt;= PGSIZE) panic(\u0026#34;inituvm: more than a page\u0026#34;); mem = kalloc(); memset(mem, 0, PGSIZE); mappages(pagetable, 0, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U); memmove(mem, src, sz); } è¯¥å‡½æ•°åˆ†é…ä¸€é¡µå¹¶å°†srcçš„å†…å®¹å¤åˆ¶è¿›è¿™ä¸€é¡µä¸­ï¼Œå¤åˆ¶çš„å¤§å°ä¸ºszï¼Œåœ¨userinitä¸­ï¼Œsrcä¸ºinitcodeï¼Œå†…å®¹å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 // a user program that calls exec(\u0026#34;/init\u0026#34;) // od -t xC initcode uchar initcode[] = { 0x17, 0x05, 0x00, 0x00, 0x13, 0x05, 0x45, 0x02, 0x97, 0x05, 0x00, 0x00, 0x93, 0x85, 0x35, 0x02, 0x93, 0x08, 0x70, 0x00, 0x73, 0x00, 0x00, 0x00, 0x93, 0x08, 0x20, 0x00, 0x73, 0x00, 0x00, 0x00, 0xef, 0xf0, 0x9f, 0xff, 0x2f, 0x69, 0x6e, 0x69, 0x74, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; é¢\u0026hellip;å…¶å®å°±æ˜¯é‚£ä¸ªinitcode.Sç¼–è¯‘åå¯¹åº”çš„äºŒè¿›åˆ¶å†…å®¹ğŸ¤£ğŸ¤£ï¼Œuserinitæœ€åè®¾ç½®äº†procä¸­ä¸€äº›å­—æ®µå°±ç»“æŸäº†ï¼Œç¬¬ä¸€ä¸ªè¿›ç¨‹å°±æ­¤åˆå§‹åŒ–å®Œæ¯•ã€‚\nè¿›ç¨‹è°ƒåº¦ mainä¸­çš„æœ€åä¸€ä¸ªå‡½æ•°ä¸ºschedulerï¼Œå³è¿›ç¨‹è°ƒåº¦å™¨ï¼Œå®šä¹‰å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // Per-CPU process scheduler. // Each CPU calls scheduler() after setting itself up. // Scheduler never returns. It loops, doing: // - choose a process to run. // - swtch to start running that process. // - eventually that process transfers control // via swtch back to the scheduler. void scheduler(void) { struct proc *p; struct cpu *c = mycpu(); c-\u0026gt;proc = 0; for(;;){ // Avoid deadlock by ensuring that devices can interrupt. intr_on(); int found = 0; for(p = proc; p \u0026lt; \u0026amp;proc[NPROC]; p++) { acquire(\u0026amp;p-\u0026gt;lock); if(p-\u0026gt;state == RUNNABLE) { // Switch to chosen process. It is the process\u0026#39;s job // to release its lock and then reacquire it // before jumping back to us. p-\u0026gt;state = RUNNING; c-\u0026gt;proc = p; swtch(\u0026amp;c-\u0026gt;context, \u0026amp;p-\u0026gt;context); // Process is done running for now. // It should have changed its p-\u0026gt;state before coming back. c-\u0026gt;proc = 0; found = 1; } release(\u0026amp;p-\u0026gt;lock); } #if !defined (LAB_FS) if(found == 0) { intr_on(); asm volatile(\u0026#34;wfi\u0026#34;); } #else ; #endif } } è¿™ä¸ªå‡½æ•°æ˜¯ä¸€ä¸ªæ— é™å¾ªç¯ï¼Œä»procä¸­æ‰¾ä¸€ä¸ªRUNNABLEçš„è¿›ç¨‹è¿›è¡Œè°ƒåº¦ï¼Œå…¶ä¸­swtchå‡½æ•°ç¥å¥‡çš„å°†cpuè½¬ç§»åˆ°äº†æŸä¸ªè¿›ç¨‹ï¼Œçœ‹çœ‹è¯¥å‡½æ•°å®ç°ï¼Œå¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 .globl swtch swtch: sd ra, 0(a0) sd sp, 8(a0) sd s0, 16(a0) sd s1, 24(a0) sd s2, 32(a0) sd s3, 40(a0) sd s4, 48(a0) sd s5, 56(a0) sd s6, 64(a0) sd s7, 72(a0) sd s8, 80(a0) sd s9, 88(a0) sd s10, 96(a0) sd s11, 104(a0) ld ra, 0(a1) ld sp, 8(a1) ld s0, 16(a1) ld s1, 24(a1) ld s2, 32(a1) ld s3, 40(a1) ld s4, 48(a1) ld s5, 56(a1) ld s6, 64(a1) ld s7, 72(a1) ld s8, 80(a1) ld s9, 88(a1) ld s10, 96(a1) ld s11, 104(a1) ret çœ‹çœ‹contextç»“æ„\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // Saved registers for kernel context switches. struct context { uint64 ra; uint64 sp; // callee-saved uint64 s0; uint64 s1; uint64 s2; uint64 s3; uint64 s4; uint64 s5; uint64 s6; uint64 s7; uint64 s8; uint64 s9; uint64 s10; uint64 s11; }; åˆ°è¿™å°±çŸ¥é“swtchå¹²äº†ä»€ä¹ˆäº†ï¼Œè¯¥å‡½æ•°å…ˆå°†ç°åœ¨çš„éœ€è¦ä¿å­˜çš„å„ä¸ªå¯„å­˜å™¨æ”¾åˆ°c-\u0026gt;contextå†…ï¼Œæ¥ç€å°†p-\u0026gt;contextä¸­çš„ä¿å­˜çš„å„ä¸ªå¯„å­˜å™¨å€¼æ”¾å…¥å¯„å­˜å™¨ä¸­ï¼Œæœ€åæ˜¯ä¸€ä¸ªretæŒ‡ä»¤ã€‚æ³¨æ„è¿™é‡Œçš„retæŒ‡ä»¤ä¸ä¼šè¿”å›åˆ°schedulerä¸­è°ƒç”¨è¯¥å‡½æ•°çš„ä½ç½®äº†ï¼Œå› ä¸ºra(return address)å¯„å­˜å™¨çš„å€¼å·²ç»æ”¹å˜äº†ï¼Œè¯¥å‡½æ•°ä¼šè¿”å›åˆ°p-\u0026gt;context-\u0026gt;raä½ç½®å¤„ã€‚æ³¨æ„åˆ°åˆšåˆšåœ¨userinitå†…æœ‰è¿™æ ·ä¸¤å¥\n1 2 3 4 5 // Set up new context to start executing at forkret, // which returns to user space. memset(\u0026amp;p-\u0026gt;context, 0, sizeof(p-\u0026gt;context)); p-\u0026gt;context.ra = (uint64)forkret; // raæ˜¯return address p-\u0026gt;context.sp = p-\u0026gt;kstack + PGSIZE; // spæ˜¯stack pointer æ‰€ä»¥swtchå‡½æ•°è¿”å›çš„ä½ç½®æ˜¯forkretï¼Œè¯¥å‡½æ•°å®šä¹‰å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // A fork child\u0026#39;s very first scheduling by scheduler() // will swtch to forkret. void forkret(void) { static int first = 1; // Still holding p-\u0026gt;lock from scheduler. release(\u0026amp;myproc()-\u0026gt;lock); if (first) { // File system initialization must be run in the context of a // regular process (e.g., because it calls sleep), and thus cannot // be run from main(). first = 0; fsinit(ROOTDEV); } usertrapret(); } å¯ä»¥çœ‹åˆ°é¦–å…ˆé‡Šæ”¾äº†é”ï¼Œæ¥ç€é€šè¿‡usertrapretå°†cpuäº¤ç»™ç”¨æˆ·è¿›ç¨‹ï¼Œç”±äºä¸‹ä¸€èŠ‚è¯¾æ‰æ˜¯trapï¼Œè¿˜æ²¡æœ‰å¼€å§‹çœ‹ï¼Œæ•…æ­¤å¤„ä¸å†æ·±å…¥ï¼Œåªéœ€è¦çŸ¥é“usertrapretå°†cpuè¿”å›åˆ°ç”¨æˆ·è¿›ç¨‹å³å¯ã€‚\nåˆ›å»ºè¿›ç¨‹ ç±»unixç³»ç»Ÿå‡ä½¿ç”¨fork()åˆ›å»ºæ–°çš„è¿›ç¨‹ï¼Œè¦å¯åŠ¨ä¸€ä¸ªæ–°è¿›ç¨‹ï¼Œä¸€èˆ¬æ–¹å¼ä¸ºforkåˆ›å»ºå­è¿›ç¨‹ï¼Œæ¥ç€ç”¨execæ¥æ‰§è¡ŒæŒ‡å®šè¿›ç¨‹ï¼Œæ¥ä¸‹æ¥çœ‹çœ‹ç›¸å…³å®ç°ã€‚\nfork forkå‡½æ•°å®ç°å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // Create a new process, copying the parent. // Sets up child kernel stack to return as if from fork() system call. int fork(void) { int i, pid; struct proc *np; struct proc *p = myproc(); // Allocate process. if((np = allocproc()) == 0){ return -1; } // Copy user memory from parent to child. if(uvmcopy(p-\u0026gt;pagetable, np-\u0026gt;pagetable, p-\u0026gt;sz) \u0026lt; 0){ freeproc(np); release(\u0026amp;np-\u0026gt;lock); return -1; } np-\u0026gt;sz = p-\u0026gt;sz; np-\u0026gt;parent = p; // copy saved user registers. *(np-\u0026gt;trapframe) = *(p-\u0026gt;trapframe); // Cause fork to return 0 in the child. np-\u0026gt;trapframe-\u0026gt;a0 = 0; // increment reference counts on open file descriptors. for(i = 0; i \u0026lt; NOFILE; i++) if(p-\u0026gt;ofile[i]) np-\u0026gt;ofile[i] = filedup(p-\u0026gt;ofile[i]); np-\u0026gt;cwd = idup(p-\u0026gt;cwd); safestrcpy(np-\u0026gt;name, p-\u0026gt;name, sizeof(p-\u0026gt;name)); pid = np-\u0026gt;pid; np-\u0026gt;state = RUNNABLE; release(\u0026amp;np-\u0026gt;lock); return pid; } å¹²çš„äº‹å‡ ä¹å°±æ˜¯å°†çˆ¶è¿›ç¨‹å¤åˆ¶äº†ä¸€éï¼Œé¦–å…ˆè¿˜æ˜¯allocprocæ‰¾åˆ°UNUSEDçš„procåˆ†é…åŸºæœ¬çš„trampolineå’Œtrapframeé¡µï¼Œç„¶åå¤åˆ¶é¡µè¡¨ï¼Œå¤åˆ¶trapframeå†…å®¹ï¼Œå¤åˆ¶æ–‡ä»¶æè¿°ç¬¦ï¼Œè®¾ç½®pidï¼Œè®¾ç½®è¿›ç¨‹çŠ¶æ€ã€‚å…¶ä¸­å’Œpage tableç›¸å…³çš„uvmcopyä»£ç å®ç°å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // Given a parent process\u0026#39;s page table, copy // its memory into a child\u0026#39;s page table. // Copies both the page table and the // physical memory. // returns 0 on success, -1 on failure. // frees any allocated pages on failure. int uvmcopy(pagetable_t old, pagetable_t new, uint64 sz) { pte_t *pte; uint64 pa, i; uint flags; char *mem; for(i = 0; i \u0026lt; sz; i += PGSIZE){ if((pte = walk(old, i, 0)) == 0) panic(\u0026#34;uvmcopy: pte should exist\u0026#34;); if((*pte \u0026amp; PTE_V) == 0) panic(\u0026#34;uvmcopy: page not present\u0026#34;); pa = PTE2PA(*pte); flags = PTE_FLAGS(*pte); if((mem = kalloc()) == 0) goto err; memmove(mem, (char*)pa, PGSIZE); if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){ kfree(mem); goto err; } } return 0; err: uvmunmap(new, 0, i / PGSIZE, 1); return -1; } å…¶å®å°±æ˜¯ä»0åˆ°szï¼Œå¯¹æ¯ä¸€é¡µè¿›è¡Œä»¥ä¸‹æ“ä½œ\næ‰¾åˆ°è¯¥é¡µå¯¹åº”çš„pa åˆ†é…ä¸€ä¸ªç©ºé—²é¡µmemï¼Œå°†paå†…å®¹å¤åˆ¶åˆ°mem ç»™æ–°é¡µè¡¨åŒæ ·çš„åœ°å€æ˜ å°„åˆ°memå¤„ å¯ä»¥çœ‹åˆ°è¿™ä¸ªå¤åˆ¶å¹¶æ²¡æœ‰ç”¨åˆ°ç†è®ºæ•™æä¸Šæåˆ°çš„copy on page æŠ€æœ¯ğŸ˜€ï¼Œxv6æœç„¶å¤ªç²—ç³™äº†ğŸ¤£ã€‚\nè¿˜æœ‰ä¸€ä¸ªuvmunmapå‡½æ•°ä¹Ÿå€¼å¾—çœ‹ä¸€çœ¼ï¼Œç”¨äºå»é™¤æŸå—è™šæ‹Ÿåœ°å€çš„æ˜ å°„çš„ï¼Œå®šä¹‰å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Remove npages of mappings starting from va. va must be // page-aligned. The mappings must exist. // Optionally free the physical memory. void uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free) { uint64 a; pte_t *pte; if((va % PGSIZE) != 0) panic(\u0026#34;uvmunmap: not aligned\u0026#34;); for(a = va; a \u0026lt; va + npages*PGSIZE; a += PGSIZE){ if((pte = walk(pagetable, a, 0)) == 0) panic(\u0026#34;uvmunmap: walk\u0026#34;); if((*pte \u0026amp; PTE_V) == 0) panic(\u0026#34;uvmunmap: not mapped\u0026#34;); if(PTE_FLAGS(*pte) == PTE_V) panic(\u0026#34;uvmunmap: not a leaf\u0026#34;); if(do_free){ uint64 pa = PTE2PA(*pte); kfree((void*)pa); } *pte = 0; } } å¯ä»¥çœ‹åˆ°å°±æ˜¯å°†vaå¼€å§‹çš„npagesä¸ªé¡µå¯¹åº”é¡µè¡¨ä¸­çš„pteè®¾ä¸º0ï¼Œè‹¥do_freeä¸ä¸º0ï¼Œåˆ™åŒæ—¶é‡Šæ”¾å¯¹åº”çš„ç‰©ç†é¡µ(ä½¿ç”¨kfreeï¼Œå³å°†é¡µæ”¾å›freelistä¸­)ï¼›æ³¨æ„åˆ°ä»ä¸Šé¢çš„if(PTE_FLAGS(*pte) == PTE_V)é‚£å¥å¯ä»¥çœ‹å‡ºL2ã€L1çº§é¡µè¡¨çš„flagå‡åªè®¾ç½®Vè¿™ä¸€ä½ï¼Œåªæœ‰L0çº§é¡µè¡¨ä¼šè®¾ç½®åˆ«çš„æƒé™ä½ã€‚\nexec xv6ä¸­å¯æ‰§è¡Œæ–‡ä»¶ä¹Ÿé‡‡ç”¨elfæ ¼å¼ï¼Œå…³äºè¿™ä¸ªæ ¼å¼ï¼Œå¯ä»¥å‚è€ƒå¦‚ä¸‹å‡ ä¸ªé“¾æ¥\nhttps://www.bookstack.cn/read/linux-c/3bb12105f3887f7b.md https://docs.oracle.com/cd/E19683-01/816-1386/chapter6-83432/index.html execå‡½æ•°å®ç°å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 int exec(char *path, char **argv) { char *s, *last; int i, off; uint64 argc, sz = 0, sp, ustack[MAXARG+1], stackbase; struct elfhdr elf; struct inode *ip; struct proghdr ph; pagetable_t pagetable = 0, oldpagetable; struct proc *p = myproc(); begin_op(); // filesystem æ¥å£ if((ip = namei(path)) == 0){ // æ‰¾åˆ°pathç›¸åº”çš„inode end_op(); return -1; } ilock(ip); // Check ELF header if(readi(ip, 0, (uint64)\u0026amp;elf, 0, sizeof(elf)) != sizeof(elf)) goto bad; if(elf.magic != ELF_MAGIC) goto bad; if((pagetable = proc_pagetable(p)) == 0) // ç»™æ–°è¿›ç¨‹åˆå§‹åŒ–pagetable å³æ˜ å°„trampoline å’Œ trapframe goto bad; // Load program into memory. for(i=0, off=elf.phoff; i\u0026lt;elf.phnum; i++, off+=sizeof(ph)){ // è¯»program header ä¸­çš„ä¸€ä¸ªä¸ªæ¡ç›® if(readi(ip, 0, (uint64)\u0026amp;ph, off, sizeof(ph)) != sizeof(ph)) goto bad; if(ph.type != ELF_PROG_LOAD) // ä¸éœ€è¦åŠ è½½çš„æ¡ç›®ç•¥ continue; if(ph.memsz \u0026lt; ph.filesz) goto bad; if(ph.vaddr + ph.memsz \u0026lt; ph.vaddr) goto bad; uint64 sz1; if((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == 0) // ç»™ç”¨æˆ·åˆ†é…ç©ºé—´ goto bad; sz = sz1; if(ph.vaddr % PGSIZE != 0) goto bad; if(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) \u0026lt; 0) // å°†æ®µè£…å…¥ä¹‹å‰åˆ†é…çš„ç©ºé—´ goto bad; } iunlockput(ip); end_op(); ip = 0; p = myproc(); uint64 oldsz = p-\u0026gt;sz; // Allocate two pages at the next page boundary. // Use the second as the user stack. sz = PGROUNDUP(sz); uint64 sz1; if((sz1 = uvmalloc(pagetable, sz, sz + 2*PGSIZE)) == 0) // å¤šåˆ†é…ä¸¤é¡µï¼Œä¸€é¡µä¸ºç”¨æˆ·stack ä¸€é¡µä¸ºguard page goto bad; sz = sz1; uvmclear(pagetable, sz-2*PGSIZE); // æ¸…é™¤guard page å¯¹åº”çš„Uä½ sp = sz; stackbase = sp - PGSIZE; // Push argument strings, prepare rest of stack in ustack. for(argc = 0; argv[argc]; argc++) { // åˆå§‹åŒ–ç”¨æˆ·çš„å‚æ•° å³argc argv if(argc \u0026gt;= MAXARG) goto bad; sp -= strlen(argv[argc]) + 1; sp -= sp % 16; // riscv sp must be 16-byte aligned if(sp \u0026lt; stackbase) goto bad; if(copyout(pagetable, sp, argv[argc], strlen(argv[argc]) + 1) \u0026lt; 0) goto bad; ustack[argc] = sp; } ustack[argc] = 0; // push the array of argv[] pointers. sp -= (argc+1) * sizeof(uint64); sp -= sp % 16; if(sp \u0026lt; stackbase) goto bad; if(copyout(pagetable, sp, (char *)ustack, (argc+1)*sizeof(uint64)) \u0026lt; 0) goto bad; // arguments to user main(argc, argv) // argc is returned via the system call return // value, which goes in a0. p-\u0026gt;trapframe-\u0026gt;a1 = sp; // Save program name for debugging. for(last=s=path; *s; s++) if(*s == \u0026#39;/\u0026#39;) last = s+1; safestrcpy(p-\u0026gt;name, last, sizeof(p-\u0026gt;name)); // Commit to the user image. oldpagetable = p-\u0026gt;pagetable; p-\u0026gt;pagetable = pagetable; p-\u0026gt;sz = sz; p-\u0026gt;trapframe-\u0026gt;epc = elf.entry; // initial program counter = main p-\u0026gt;trapframe-\u0026gt;sp = sp; // initial stack pointer proc_freepagetable(oldpagetable, oldsz); return argc; // this ends up in a0, the first argument to main(argc, argv) bad: if(pagetable) proc_freepagetable(pagetable, sz); if(ip){ iunlockput(ip); end_op(); } return -1; } è¯¥å‡½æ•°å®ç°è¾ƒé•¿ï¼Œå¤§è‡´æè¿°ä¸€ä¸‹å¹²äº†ä»€ä¹ˆ:è¯»å…¥elfæ–‡ä»¶ä¸­éœ€è¦è£…è½½çš„å„ä¸ªæ®µå¹¶åˆ†é…ç©ºé—´è£…è½½ã€åˆ†é…ç”¨æˆ·æ ˆç©ºé—´ã€åˆå§‹åŒ–ç”¨æˆ·æ ˆ(å³åˆå§‹åŒ–argc argv)ã€æ›´æ–°procç»“æ„çš„å„ä¸ªå­—æ®µã€é‡Šæ”¾æ—§çš„ç©ºé—´ã€æå®šã€‚\nå…¶ä¸­uvmallocå‡½æ•°å€¼å¾—ä¸€çœ‹ï¼Œå…¶å®ç°å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // Allocate PTEs and physical memory to grow process from oldsz to // newsz, which need not be page aligned. Returns new size or 0 on error. uint64 uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz) { char *mem; uint64 a; if(newsz \u0026lt; oldsz) return oldsz; oldsz = PGROUNDUP(oldsz); // oldszå¦‚æœåœ¨ä¸€é¡µçš„ä¸­é—´ï¼Œé‚£ä¹ˆè¿™ä¸€é¡µä¸€å®šä¹‹å‰å·²ç»åˆ†é…è¿‡ç»™ç”¨æˆ·äº†ï¼Œæ‰€ä»¥è¿™é‡Œæ˜¯round up for(a = oldsz; a \u0026lt; newsz; a += PGSIZE){ // æ¯ä¸€é¡µåˆ†é…ç©ºé—²ç‰©ç†é¡µå¹¶è¿›è¡Œæ˜ å°„ mem = kalloc(); if(mem == 0){ uvmdealloc(pagetable, a, oldsz); return 0; } memset(mem, 0, PGSIZE); if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != 0){ kfree(mem); uvmdealloc(pagetable, a, oldsz); return 0; } } return newsz; } è¯¥å‡½æ•°å°†ç”¨æˆ·åœ°å€ç©ºé—´ä»oldszæ‹“å±•åˆ°newszï¼Œå…¶å®å°±æ˜¯æŒ‰ç…§æ¯ä¸€é¡µæ¥åˆ†é…ç©ºé—²çš„å†…å­˜ç©ºé—´å¹¶åšå¯¹åº”çš„æ˜ å°„ã€‚è‹¥ç©ºé—´ä¸è¶³ï¼Œåˆ™è°ƒç”¨uvmdeallocï¼Œå°†ç©ºé—´é‡Šæ”¾ä¸ºåŸæ¥é‚£æ ·ã€‚é¡ºå¸¦çœ‹çœ‹uvmdeallocçš„å®ç°\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Deallocate user pages to bring the process size from oldsz to // newsz. oldsz and newsz need not be page-aligned, nor does newsz // need to be less than oldsz. oldsz can be larger than the actual // process size. Returns the new process size. uint64 uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz) { if(newsz \u0026gt;= oldsz) return oldsz; if(PGROUNDUP(newsz) \u0026lt; PGROUNDUP(oldsz)){ int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE; uvmunmap(pagetable, PGROUNDUP(newsz), npages, 1); } return newsz; } å…¶å®å°±æ˜¯å¯¹ä¹‹å‰è®²è¿‡çš„uvmunmapçš„å°è£…ã€‚\nsbrkå®ç° åœ¨ç¬¬ä¸€ä¸ªå®éªŒæ—¶ä½¿ç”¨è¿‡å¾ˆå¤šç³»ç»Ÿè°ƒç”¨ï¼Œå…¶ä¸­æœ‰ä¸€ä¸ª(æˆ‘æ²¡ä½¿ç”¨è¿‡çš„)å’Œpage tableç›¸å…³ï¼Œå°±æ˜¯sbrkï¼Œæè¿°å¦‚ä¸‹\n1 char *sbrk(int n) // Grow processâ€™s memory by n bytes. Returns start of new memory çœ‹çœ‹è¯¥ç³»ç»Ÿè°ƒç”¨çš„å®ç°ï¼Œä¹‹å‰åšè¿‡syscall labï¼Œå®¹æ˜“æ‰¾åˆ°å¯¹åº”å‡½æ•°å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 uint64 sys_sbrk(void) { int addr; int n; if(argint(0, \u0026amp;n) \u0026lt; 0) // è·å–å‚æ•° n return -1; addr = myproc()-\u0026gt;sz; // ç°åœ¨è¿›ç¨‹çš„åœ°å€ç©ºé—´ä¸º [0,sz) æ•…szå°±æ˜¯æ–°çš„åœ°å€èµ·å§‹ä½ç½® if(growproc(n) \u0026lt; 0) // æ‰©å¤§ç”¨æˆ·è¿›ç¨‹å¯ç”¨å†…å­˜ return -1; return addr; } å¯ä»¥çœ‹åˆ°å…³é”®åœ¨äºè¿™ä¸ªgrowprocå‡½æ•°ï¼ŒæŸ¥çœ‹è¯¥å‡½æ•°å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // Grow or shrink user memory by n bytes. // Return 0 on success, -1 on failure. int growproc(int n) { uint sz; struct proc *p = myproc(); sz = p-\u0026gt;sz; if(n \u0026gt; 0){ if((sz = uvmalloc(p-\u0026gt;pagetable, sz, sz + n)) == 0) { return -1; } } else if(n \u0026lt; 0){ sz = uvmdealloc(p-\u0026gt;pagetable, sz, sz + n); } p-\u0026gt;sz = sz; return 0; } è¯¥å‡½æ•°å°è£…äº†uvmallocå’Œuvmdeallocï¼Œåˆ†åˆ«ç”¨äºå¢é•¿ç©ºé—´å’Œç¼©å°ç©ºé—´ã€‚\nå°¾å£° åˆ°è¿™é‡Œå¤§æ¦‚æŠŠåšpagetable labçœ‹è¿‡çš„æºç éƒ½æ‰«äº†ä¸€éğŸ˜†\nè¿™ä¸ªå®éªŒè¾¹æ‘†è¾¹åšåšçš„æ—¶é—´å®åœ¨æ˜¯æœ‰ç‚¹é•¿äº†ï¼Œå°è±¡åˆ°ç°åœ¨è¿˜æŒºæ·±ï¼Œæ‰€ä»¥è¿™ä¸€ç¯‡æ–‡ç« åŸºæœ¬å°±æ˜¯æ‘˜æŠ„æºä»£ç ï¼Œè§£é‡Šæ¯”è¾ƒå°‘ï¼Œå¸Œæœ›ä»¥åçœ‹åˆ°æ—¶è¿˜èƒ½è®°èµ·æ¥ç©¶ç«Ÿæ˜¯æ€ä¹ˆå›äº‹ğŸ¤£\nä¸‹ä¸€ç¯‡è±¡å¾æ€§å†™å†™pagetable labçš„å®ç°å°±å®Œå•¦ï¼ï¼\n","date":"2023-01-18T11:13:11+08:00","image":"https://XieWeikai.github.io/aniya_blog/p/mit-6.s081-page-table-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/wallpaper_hudb94877ecea93d4ab13b1a424f076a8e_2205015_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/mit-6.s081-page-table-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/","title":"MIT 6.S081 page table ä»£ç è§£æ"},{"content":"é—²è¯ã€gdb é—²è¯ è‡ªæ‰“syscall labä»¥æ¥ï¼Œä¸‰å¤©éƒ½æ²¡çœ‹MIT 6.S081ğŸ¤£ï¼Œä»Šå¤©æ‰«äº†ä¸€ä¸‹ä¸‹ä¸€èŠ‚è¯¾çš„å†…å®¹ï¼Œå‘ç°å±…ç„¶ï¼ï¼ï¼ å±…ç„¶æ˜¯è®²å®éªŒäºŒçš„å†…å®¹ğŸ¤¡\u0026hellip;\nè®²çš„å¤§æ¦‚å°±æ˜¯ä¸Šä¸€ç¯‡åšå®¢ä¸­\u0026quot;å‡†å¤‡\u0026ldquo;é‚£ä¸€å°èŠ‚çš„å†…å®¹ï¼Œå‰å‡ å¤©åšsyscall labæ—¶è¿˜å¥‡æ€ªå‘¢ï¼Œæ€ä¹ˆè¿™ä¸ªå®éªŒå†…å®¹ä¸å¸¦è®²çš„ï¼Œå…¨é è‡ªå·±çœ‹æ˜¯å§ï¼Œè¿˜çœ‹äº†æœ‰å‡ ä¸ªå°æ—¶\u0026hellip;\u0026hellip;\nå®˜ç½‘ä¸Šçš„è¯¾ç¨‹è¡¨é•¿è¿™ä¸ªæ ·\nå®éªŒäºŒå¹¶æ²¡æœ‰å¯¹åº”çš„è¯¾ç¨‹ï¼Œä½†æ˜¯å½“ä½ å¾€ä¸‹ä¸€çœ‹\né€†å¤©å‘€ï¼ŒåŸæ¥æ˜¯å…ˆå¸ƒç½®å®éªŒï¼Œè¿‡å‡ å¤©æ‰ä¸Šå¯¹åº”çš„è¯¾ğŸ˜¨\nç”±äºå·²ç»åšè¿‡å®éªŒäºŒäº†ï¼Œå°±ä¸ä»”ç»†çœ‹è¿™èŠ‚è¯¾äº†ï¼Œè±¡å¾æ€§çš„æ‰«äº†ä¸€ä¸‹ï¼Œè´´å‡ ä¸ªé“¾æ¥å¦‚ä¸‹\nå¥½å¿ƒäººçš„è¯¾ç¨‹ç¿»è¯‘: https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec03-os-organization-and-system-calls è¯¾ç¨‹è§†é¢‘: https://www.bilibili.com/video/BV19k4y1C7kA?p=2\u0026vd_source=a47945b9c45a33522fa3c242107add1e GDB åœ¨ä¸Šé¢è®²åˆ°çš„é‚£èŠ‚è¯¾ä¸­ï¼Œæœ€ååœ¨æè¿°xv6å¤§è‡´å¯åŠ¨è¿‡ç¨‹æ—¶ï¼Œè€å¸ˆç”¨åˆ°äº†GDBæ¥è·Ÿè¸ªå¯åŠ¨æ—¶æ‰§è¡Œçš„ä»£ç ï¼Œä¹‹å‰è¿˜æ²¡ç”¨è¿‡gdbæ¥è°ƒè¯•xv6ï¼Œäºæ˜¯ä¹Ÿå°è¯•äº†ä¸€ä¸‹\nå¯åŠ¨ ä½¿ç”¨å¦‚ä¸‹å‘½ä»¤å¯åŠ¨xv6\n1 make CPUS=1 qemu-gdb CPUSè®¾å®šæ¨¡æ‹Ÿçš„æ ¸æ•°ï¼Œè®¾ä¸º1æ˜¯å› ä¸ºä¸€ä¸ªCPUå®¹æ˜“è°ƒè¯•ï¼Œå¯åŠ¨åæ•ˆæœå¦‚ä¸‹\ndockerç¯å¢ƒä¸‹å¯åŠ¨gdb ä¸Šé¢çš„xv6æ˜¯è·‘åœ¨dockerå®¹å™¨å†…çš„(è§ç¯å¢ƒé…ç½®)ï¼Œç›´æ¥åœ¨dockerå†…ä½¿ç”¨gdbï¼Œæ•ˆæœå¦‚ä¸‹\nå¯åŠ¨æ—¶æŠ¥äº†è¿™æ ·çš„ä¸€ä¸ªè­¦å‘Šï¼Œè¯´æ˜¯auto-loading has been declinedï¼Œgdbåœ¨å¯åŠ¨æ—¶ä¼šè‡ªåŠ¨æ‰§è¡Œå½“å‰ç›®å½•å†…çš„.gdbinitå†…çš„å‘½ä»¤ï¼Œåœ¨å®éªŒç›®å½•ä¸‹è¯¥æ–‡ä»¶å†…å®¹å¦‚ä¸‹\næ‰§è¡Œå®Œè¿™äº›å‘½ä»¤å°±å·²ç»è®¾ç½®å¥½äº†gdbå®¢æˆ·ç«¯ï¼Œå¯ä»¥å¼€å§‹è°ƒè¯•xv6ï¼Œä½†æ˜¯dockerå†…çš„gdbè¯´è¦æ·»åŠ safe-pathï¼ŒæŒ‰ç…§æç¤ºå‘/root/.config/gdb/gdbinitæ·»åŠ å¦‚ä¸‹å†…å®¹\nç›´æ¥å°†/xwkç›®å½•è®¾ç½®ä¸ºsafe-pathï¼Œå†æ¬¡å¯åŠ¨gdbï¼Œæ•ˆæœå¦‚ä¸‹\nç»“æœè¿˜æ˜¯æœ‰é—®é¢˜ï¼Œè¿™ä¸ªæ™®é€šçš„gdbéƒ½ä¸æ”¯æŒriscv:rv64ã€‚å›å¿†èµ·ä¹‹å‰ç¯å¢ƒé…ç½®æ—¶ï¼Œå®‰è£…äº†ä¸€ä¸ªgdb-multiarchï¼Œçœ‹åå­—å°±æ˜¯å¤šarchitechtureçš„gdbï¼Œå°è¯•ä½¿ç”¨gdb-multiarchï¼Œç»“æœå¦‚ä¸‹\nä¸Šå›¾ç»“æœå’Œè¯¾ç¨‹å½•åƒä¸€è‡´ï¼Œä¹Ÿå¯ä»¥æ­£å¸¸è¿›è¡Œè°ƒè¯•ã€‚\nmacä¸‹çš„gdb å°è¯•åœ¨å®éªŒç›®å½•ä¸‹(è¿™æ ·æ‰èƒ½æ‰§è¡Œ.gdbinit)ç›´æ¥å¯åŠ¨macOSä¸‹å®‰è£…çš„gdbï¼Œå‘ç°macOSä¸‹ç”¨brewè£…çš„gdbå±…ç„¶æ”¯æŒriscv:rv64ï¼ŒçœŸæ˜¯å¤ªå¥½äº†ğŸ˜‹ï¼\nå¯æ˜¯dockerå†…çš„25000ç«¯å£æ²¡æœ‰æš´éœ²ğŸ˜…ï¼Œåªå¥½é‡æ–°å¼€ä¸€ä¸ªå®¹å™¨äº†ï¼Œå…ˆæŠŠå·²æœ‰çš„å®¹å™¨commitï¼Œå†æ–°å»ºå®¹å™¨\n1 2 3 4 5 6 docker commit -a \u0026#34;...\u0026#34; -m \u0026#34;...\u0026#34; xv6 dev:latest # å°†å®¹å™¨commitæˆé•œåƒ docker container rm xv6 # åˆ é™¤xv6å®¹å™¨ docker run -itd --name xv6 \\ -p 8080:22 \\ # sshç«¯å£ \\p 25000:25000 \\ # gdbæœåŠ¡å™¨ç«¯å£ -v ...:... # æŒ‚è½½å®éªŒç›®å½• é‡æ–°æ‰§è¡Œä¸‹é¢è¯­å¥å¯åŠ¨xv6å¹¶å¯åŠ¨gdbæœåŠ¡å™¨\n1 make CPUS=1 qemu-gdb æ¥ç€ç›´æ¥åœ¨macOSä¸‹å¯åŠ¨gdbï¼Œå¦‚ä¸‹\nå¤§åŠŸå‘ŠæˆğŸ˜¤\nå°¾å£° å› ä¸ºç§‘ç ”ç»„çš„å…³ç³»ï¼Œæ¥ä¸‹æ¥å¯èƒ½å¾—çœ‹ä¸€äº›æ·±åº¦å­¦ä¹ ç›¸å…³çš„ä¸œè¥¿äº†ï¼Œé‚£OSå°±ä¼šæ¯”ä»¥å‰æ›´æ…¢äº†ğŸ˜¨ï¼Œçœ‹ä¸€èŠ‚è¯¾æ˜¯ä¸€èŠ‚è¯¾å§ğŸ¤£\n","date":"2023-01-10T20:21:11+08:00","image":"https://XieWeikai.github.io/aniya_blog/p/%E9%97%B2%E8%B0%88gdb/piano_hu28da5375bae764b9601c6414097b4ddd_1403895_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/%E9%97%B2%E8%B0%88gdb/","title":"é—²è°ˆã€gdb"},{"content":"OS lab syscall æ—¶éš”ä¸€å¤©ï¼Œå±…ç„¶åˆè±¡å¾æ€§çš„å®Œæˆäº†ä¸€ä¸ªå®éªŒğŸ˜‹\næœ¬æ¬¡å®éªŒéœ€è¦åœ¨xv6ç³»ç»Ÿå†…é¢å¤–æ·»åŠ ä¸¤ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œåˆ†åˆ«æ˜¯traceå’Œsysinfoï¼Œtraceç”¨äºè·Ÿè¸ªæŸä¸ªè¿›ç¨‹ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨çš„æƒ…å†µï¼Œsysinfoç”¨äºæŸ¥çœ‹ç³»ç»Ÿå†…ç©ºé—²å†…å­˜å’Œè¿›ç¨‹ä¸ªæ•°ã€‚\nå®éªŒçš„å®˜æ–¹æŒ‡å¯¼è§ https://pdos.csail.mit.edu/6.828/2020/labs/syscall.html ã€‚\nå‡†å¤‡ å®˜æ–¹æŒ‡å¯¼ä¸­çš„å‰ç½®è¦æ±‚æ˜¯\nBefore you start coding, read Chapter 2 of the xv6 book, and Sections 4.3 and 4.4 of Chapter 4, and related source files:\nThe user-space code for systems calls is in user/user.h and user/usys.pl. The kernel-space code is kernel/syscall.h, kernel/syscall.c. The process-related code is kernel/proc.h and kernel/proc.c. æŒ‡å¯¼ä¹¦ä¸­çš„Chapter 2æè¿°äº†æ“ä½œç³»ç»Ÿçš„ç»„ç»‡ç»“æ„ï¼Œå†…å®¹å¤§æ¦‚æ˜¯ç®€å•è®²äº†ä¸€ä¸‹æ“ä½œç³»ç»Ÿçš„åŠŸèƒ½ä½œç”¨ã€æ“ä½œç³»ç»Ÿä¸ºä»€ä¹ˆé‡è¦ã€æœ‰å“ªäº›ç»„ç»‡æ“ä½œç³»ç»Ÿå„ä¸ªéƒ¨åˆ†çš„æ–¹æ³•ç­‰ç­‰ã€‚\nåœ¨Chapter 2çš„æœ€åå¤§æ¦‚è®²äº†è®²xv6çš„å¯åŠ¨è¿‡ç¨‹ã€‚\nå¯åŠ¨æµç¨‹æ¦‚è¿° qemuæ¨¡æ‹Ÿçš„æœºå™¨å¯åŠ¨æ—¶é¦–å…ˆæ‰§è¡ŒROMä¸­çš„ç¨‹åºï¼Œè¿™ä¸ªç¨‹åºçš„ä½œç”¨åº”è¯¥å°±æ˜¯å°†å¯åŠ¨åŒºçš„ä¸€éƒ¨åˆ†ä»£ç è½½å…¥å†…å­˜å¹¶è½¬äº¤CPUä½¿ç”¨æƒåˆ°è½½å…¥çš„ä»£ç ï¼Œxv6æœ€åˆçš„ä»£ç è§kernel/entry.S:6\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # qemu -kernel loads the kernel at 0x80000000 # and causes each CPU to jump there. # kernel.ld causes the following code to # be placed at 0x80000000. .section .text _entry: # set up a stack for C. # stack0 is declared in start.c, # with a 4096-byte stack per CPU. # sp = stack0 + (hartid * 4096) la sp, stack0 li a0, 1024*4 csrr a1, mhartid addi a1, a1, 1 mul a0, a0, a1 add sp, sp, a0 # jump to start() in start.c call start spin: j spin ä¸Šé¢çš„æ±‡ç¼–ä»£ç è®¾ç½®å¥½æ ˆé¡¶å¯„å­˜å™¨åå°†è·³è½¬åˆ° kernel/start.cä¸­çš„startå‡½æ•°ï¼Œæ³¨æ„åœ¨æœºå™¨åˆšå¯åŠ¨æ—¶å¤„åœ¨machine modeï¼Œè¯¥æ¨¡å¼ä¸‹æ‹¥æœ‰æ‰€æœ‰çš„æƒé™ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // entry.S jumps here in machine mode on stack0. void start() { // set M Previous Privilege mode to Supervisor, for mret. unsigned long x = r_mstatus(); x \u0026amp;= ~MSTATUS_MPP_MASK; x |= MSTATUS_MPP_S; w_mstatus(x); // set M Exception Program Counter to main, for mret. // requires gcc -mcmodel=medany w_mepc((uint64)main); // disable paging for now. w_satp(0); // delegate all interrupts and exceptions to supervisor mode. w_medeleg(0xffff); w_mideleg(0xffff); w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE); // ask for clock interrupts. timerinit(); // keep each CPU\u0026#39;s hartid in its tp register, for cpuid(). int id = r_mhartid(); w_tp(id); // switch to supervisor mode and jump to main(). asm volatile(\u0026#34;mret\u0026#34;); } ä¸Šé¢çš„ä»£ç å¯¹æœºå™¨è¿›è¡Œäº†ä¸€äº›è®¾ç½®ï¼Œæ²¡äº†è§£è¿‡riscvçš„å¤„ç†å™¨ï¼Œéšç€å®éªŒçš„æ·±å…¥åº”è¯¥ä¹Ÿè®¸ä¼šäº†è§£æ›´å¤šå§ï¼Œä¸Šé¢ä»£ç çš„æœ€åä¸€å¥ï¼Œä½¿ç”¨æ±‡ç¼–mretï¼Œè¿™ä¸€èˆ¬ç”¨äºsupervisor modeè°ƒç”¨machine modeçš„ä»£ç åä»machine modeè¿”å›supervisor modeï¼Œåœ¨è¿™ä¸ªä»£ç é‡Œé€šè¿‡mretè¿›å…¥supervisor modeï¼Œä¹Ÿå°±æ˜¯æ“ä½œç³»ç»Ÿå†…æ ¸è¿è¡Œçš„æ¨¡å¼ï¼Œåœ¨startå‡½æ•°å‰é¢ä¸€äº›ä»£ç å·²ç»å°†è¿”å›åœ°å€è®¾ä¸ºäº†mainï¼Œæ•…mretä¼šè½¬åˆ°mainå‡½æ•°ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // start() jumps here in supervisor mode on all CPUs. void main() { if(cpuid() == 0){ consoleinit(); printfinit(); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;xv6 kernel is booting\\n\u0026#34;); printf(\u0026#34;\\n\u0026#34;); kinit(); // physical page allocator kvminit(); // create kernel page table kvminithart(); // turn on paging procinit(); // process table trapinit(); // trap vectors trapinithart(); // install kernel trap vector plicinit(); // set up interrupt controller plicinithart(); // ask PLIC for device interrupts binit(); // buffer cache iinit(); // inode cache fileinit(); // file table virtio_disk_init(); // emulated hard disk userinit(); // first user process __sync_synchronize(); started = 1; } else { while(started == 0) ; __sync_synchronize(); printf(\u0026#34;hart %d starting\\n\u0026#34;, cpuid()); kvminithart(); // turn on paging trapinithart(); // install kernel trap vector plicinithart(); // ask PLIC for device interrupts } scheduler(); } mainå‡½æ•°å†…è¿›è¡Œäº†ä¸€å †åˆå§‹åŒ–æ“ä½œï¼Œæœ€åè°ƒç”¨äº†userinit()å‡½æ•°å¯åŠ¨ç¬¬ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹ï¼Œè¯¥å‡½æ•°ä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Set up first user process. void userinit(void) { struct proc *p; p = allocproc(); initproc = p; // allocate one user page and copy init\u0026#39;s instructions // and data into it. uvminit(p-\u0026gt;pagetable, initcode, sizeof(initcode)); p-\u0026gt;sz = PGSIZE; // prepare for the very first \u0026#34;return\u0026#34; from kernel to user. p-\u0026gt;trapframe-\u0026gt;epc = 0; // user program counter p-\u0026gt;trapframe-\u0026gt;sp = PGSIZE; // user stack pointer safestrcpy(p-\u0026gt;name, \u0026#34;initcode\u0026#34;, sizeof(p-\u0026gt;name)); p-\u0026gt;cwd = namei(\u0026#34;/\u0026#34;); p-\u0026gt;state = RUNNABLE; release(\u0026amp;p-\u0026gt;lock); } ä¸Šé¢çš„ä»£ç åœ¨å¯¹è¿›ç¨‹ä¸€äº›å¿…è¦çš„ä¸œè¥¿åˆå§‹åŒ–åå¯åŠ¨äº†initcodeè¿™ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹ï¼Œè¯¥è¿›ç¨‹æ˜¯ç”¨æ±‡ç¼–å†™çš„ï¼Œä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026#34;syscall.h\u0026#34; # exec(init, argv) .globl start start: la a0, init la a1, argv li a7, SYS_exec ecall # for(;;) exit(); exit: li a7, SYS_exit ecall jal exit # char init[] = \u0026#34;/init\\0\u0026#34;; init: .string \u0026#34;/init\\0\u0026#34; # char *argv[] = { init, 0 }; .p2align 2 argv: .long init .long 0 ä¸Šé¢çš„ä»£ç ç›¸å½“äºæ‰§è¡Œäº†cç¨‹åº\n1 2 3 4 5 6 7 8 void start(){ char *init = \u0026#34;/init\u0026#34;; char *argv[] = {init,0}; exec(init,argv); for(;;) exit(); } è¿™ä¸ª/initç¨‹åºè§æºç user/init.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // init: The initial user-level program #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;kernel/spinlock.h\u0026#34; #include \u0026#34;kernel/sleeplock.h\u0026#34; #include \u0026#34;kernel/fs.h\u0026#34; #include \u0026#34;kernel/file.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; #include \u0026#34;kernel/fcntl.h\u0026#34; char *argv[] = { \u0026#34;sh\u0026#34;, 0 }; int main(void) { int pid, wpid; if(open(\u0026#34;console\u0026#34;, O_RDWR) \u0026lt; 0){ mknod(\u0026#34;console\u0026#34;, CONSOLE, 0); open(\u0026#34;console\u0026#34;, O_RDWR); } dup(0); // stdout dup(0); // stderr for(;;){ printf(\u0026#34;init: starting sh\\n\u0026#34;); pid = fork(); if(pid \u0026lt; 0){ printf(\u0026#34;init: fork failed\\n\u0026#34;); exit(1); } if(pid == 0){ exec(\u0026#34;sh\u0026#34;, argv); printf(\u0026#34;init: exec sh failed\\n\u0026#34;); exit(1); } for(;;){ // this call to wait() returns if the shell exits, // or if a parentless process exits. wpid = wait((int *) 0); if(wpid == pid){ // the shell exited; restart it. break; } else if(wpid \u0026lt; 0){ printf(\u0026#34;init: wait returned an error\\n\u0026#34;); exit(1); } else { // it was a parentless process; do nothing. } } } } å¼•ç”¨æŒ‡å¯¼ä¹¦çš„è¯ï¼Œinitç¨‹åºå¹²çš„äº‹ä¸º\nInit (user/init.c:15) creates a new console device fifile if needed and then opens it as fifile descriptors 0, 1, and 2. Then it starts a shell on the console. The system is up.\nxv6å¤§è‡´çš„å¯åŠ¨æµç¨‹åˆ°æ­¤ç»“æŸï¼Œå…¶å®è¿˜æ˜¯æ¯”è¾ƒæ¨¡ç³Šçš„ï¼Œç»†èŠ‚åº”è¯¥ä¼šåœ¨åé¢çš„å®éªŒé€æ¸å±•å¼€ \u0026hellip; å§ğŸ¤£\nç³»ç»Ÿè°ƒç”¨ åœ¨å®éªŒæŒ‡å¯¼ç½‘ç«™ä¸­è¿˜æåˆ°è¦çœ‹æŒ‡å¯¼ä¹¦çš„4.3å’Œ4.4èŠ‚ï¼Œè¿™ä¸¤èŠ‚è±¡å¾æ€§çš„è®²äº†ä¸‹ç³»ç»Ÿè°ƒç”¨ç›¸å…³çš„ä»£ç ï¼Œç»†èŠ‚ä¸è¡¨ï¼Œå¤§æ¦‚æµç¨‹åœ¨æœ¬èŠ‚ç²—ç•¥çš„è§£é‡Šä¸€ä¸‹ã€‚\né¦–å…ˆåœ¨ä¸Šä¸€èŠ‚ä¸­å…¶å®çœ‹åˆ°äº†æ±‡ç¼–å¦‚ä½•è°ƒç”¨execç³»ç»Ÿè°ƒç”¨çš„ï¼Œå¦‚ä¸‹\n1 2 3 4 la a0, init la a1, argv li a7, SYS_exec ecall riscvå†…æœ‰a0-a7è¿™å‡ ä¸ªå¯„å­˜å™¨ï¼ˆæŒ‰ç…§æƒ¯ä¾‹ï¼‰ç”¨äºä¼ é€’å‚æ•°(aå°±æ˜¯arg)ï¼Œexecéœ€è¦ä¸¤ä¸ªå‚æ•°ï¼Œè¿™ä¸¤ä¸ªå‚æ•°åˆ†åˆ«å­˜å…¥a0,a1ä¸­ï¼Œa7ç”¨äºå­˜æ”¾ç³»ç»Ÿè°ƒç”¨å·ã€‚ecallæŒ‡ä»¤ä¼šé™·å…¥å†…æ ¸(å…·ä½“å“ªé‡Œä»¥ååº”è¯¥ä¼šçŸ¥é“çš„)ï¼Œé™·å…¥å†…æ ¸åä¾æ¬¡æ‰§è¡Œuservecã€usertrapç„¶åæ˜¯syscallï¼Œæœ€åè¿™ä¸ªsyscallå‡½æ•°çœŸæ­£è°ƒç”¨äº†ç³»ç»Ÿè°ƒç”¨ã€‚è¯¥å‡½æ•°è§kernel/syscall.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void syscall(void) { int num; struct proc *p = myproc(); num = p-\u0026gt;trapframe-\u0026gt;a7; if(num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt; NELEM(syscalls) \u0026amp;\u0026amp; syscalls[num]) { p-\u0026gt;trapframe-\u0026gt;a0 = syscalls[num](); } else { printf(\u0026#34;%d %s: unknown sys call %d\\n\u0026#34;, p-\u0026gt;pid, p-\u0026gt;name, num); p-\u0026gt;trapframe-\u0026gt;a0 = -1; } } å…ˆæ³¨æ„ä¸Šé¢çš„myprocï¼Œè¯¥å‡½æ•°è¿”å›ä¸€ä¸ªè¿›ç¨‹(ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨çš„è¿›ç¨‹)ç›¸å…³çš„ç»“æ„ä½“(åº”è¯¥å°±æ˜¯ç†è®ºå­¦ä¹ ä¸­çš„PCBäº†å§)ï¼Œè¯¥ç»“æ„ä½“å®šä¹‰å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Per-process state struct proc { struct spinlock lock; // p-\u0026gt;lock must be held when using these: enum procstate state; // Process state struct proc *parent; // Parent process void *chan; // If non-zero, sleeping on chan int killed; // If non-zero, have been killed int xstate; // Exit status to be returned to parent\u0026#39;s wait int pid; // Process ID // these are private to the process, so p-\u0026gt;lock need not be held. uint64 kstack; // Virtual address of kernel stack uint64 sz; // Size of process memory (bytes) pagetable_t pagetable; // User page table struct trapframe *trapframe; // data page for trampoline.S struct context context; // swtch() here to run process struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory char name[16]; // Process name (debugging) }; ä¸Šé¢ç»“æ„ä¸­çš„trapframeå­˜ç€è¯¥è¿›ç¨‹çš„å¯„å­˜å™¨çŠ¶æ€å’Œå…¶ä»–ä¸€äº›ä¿¡æ¯ï¼Œåœ¨å›è¿‡å¤´æ¥çœ‹syscallä¸­çš„å¦‚ä¸‹ä»£ç \n1 2 3 4 5 6 7 int num; struct proc *p = myproc(); num = p-\u0026gt;trapframe-\u0026gt;a7; // a7å­˜çš„æ˜¯è°ƒç”¨å·ï¼Œå¦‚å‰é¢æ±‡ç¼–è¯­è¨€è°ƒç”¨ç³»ç»Ÿè°ƒç”¨æ‰€ç¤º if(num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt; NELEM(syscalls) \u0026amp;\u0026amp; syscalls[num]) { // è°ƒç”¨å·æ»¡è¶³ä¸€å®šæ¡ä»¶æ‰èƒ½è°ƒç”¨ç³»ç»Ÿè°ƒç”¨ p-\u0026gt;trapframe-\u0026gt;a0 = syscalls[num](); } è§£é‡Šè§æ³¨é‡Šï¼Œå†æ¥çœ‹çœ‹syscallsè¿™ä¸ªå˜é‡\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 static uint64 (*syscalls[])(void) = { [SYS_fork] sys_fork, [SYS_exit] sys_exit, [SYS_wait] sys_wait, [SYS_pipe] sys_pipe, [SYS_read] sys_read, [SYS_kill] sys_kill, [SYS_exec] sys_exec, [SYS_fstat] sys_fstat, [SYS_chdir] sys_chdir, [SYS_dup] sys_dup, [SYS_getpid] sys_getpid, [SYS_sbrk] sys_sbrk, [SYS_sleep] sys_sleep, [SYS_uptime] sys_uptime, [SYS_open] sys_open, [SYS_write] sys_write, [SYS_mknod] sys_mknod, [SYS_unlink] sys_unlink, [SYS_link] sys_link, [SYS_mkdir] sys_mkdir, [SYS_close] sys_close, }; è¿™æ˜¯ä¸€ä¸ªæŒ‡å‘å‡½æ•°çš„æŒ‡é’ˆçš„æ•°ç»„ï¼ŒæŒ‡å‘çš„å‡½æ•°å½¢å¦‚uint64 func_name(void )ï¼Œè¿™ä¸€æ®µä»£ç ç»™è¯¥æ•°ç»„è¿›è¡Œåˆå§‹åŒ–ï¼Œå…¶ä¸­sys_forkï¼Œsys_exitä¹‹ç±»çš„ä¸ºå…·ä½“çš„å‡½æ•°(å‡½æ•°å°±æ˜¯ä¸€å †æŒ‡ä»¤ï¼Œå‡½æ•°åå…¶å®å°±æ˜¯è¿™ä¸€å †æŒ‡ä»¤çš„é¦–åœ°å€)ï¼ŒSYS_forkä¹‹ç±»çš„è¡¨æ˜æ•°ç»„ä¸‹æ ‡ï¼Œè¿™äº›å®å®šä¹‰åœ¨syscall.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // System call numbers #define SYS_fork 1 #define SYS_exit 2 #define SYS_wait 3 #define SYS_pipe 4 #define SYS_read 5 #define SYS_kill 6 #define SYS_exec 7 #define SYS_fstat 8 #define SYS_chdir 9 #define SYS_dup 10 #define SYS_getpid 11 #define SYS_sbrk 12 #define SYS_sleep 13 #define SYS_uptime 14 #define SYS_open 15 #define SYS_write 16 #define SYS_mknod 17 #define SYS_unlink 18 #define SYS_link 19 #define SYS_mkdir 20 #define SYS_close 21 è·å–å‚æ•° ä¸Šé¢çœ‹åˆ°äº†ç³»ç»Ÿè°ƒç”¨çš„è¿‡ç¨‹ï¼Œsyscallå®é™…ä¸Šæ˜¯æ ¹æ®a7ä¸­çš„è°ƒç”¨å·æ¥é€‰æ‹©æŸä¸ªå…·ä½“çš„å®ç°ç³»ç»Ÿè°ƒç”¨çš„å‡½æ•°æ¥å®Œæˆç³»ç»Ÿè°ƒç”¨çš„ã€‚ä¸Šä¸€å°èŠ‚çœ‹åˆ°ï¼Œsyscallè°ƒç”¨çš„å‡½æ•°åŸå‹ä¸ºuint64 func_name(void)ï¼Œé‚£è¿™äº›å‡½æ•°å¦‚ä½•æ‹¿åˆ°ç”¨æˆ·ä¼ é€’çš„å‚æ•°å‘¢ï¼Ÿ\nå®é™…ä¸Šé€šè¿‡é™·å…¥ç³»ç»Ÿè°ƒç”¨çš„ä»£ç å°±å¯ä»¥çœ‹å‡ºæ¥äº†\n1 2 3 4 5 # è°ƒç”¨ exec(init,argv) la a0, init la a1, argv li a7, SYS_exec ecall å‚æ•°å­˜åœ¨äº†è¯¥è¿›ç¨‹çš„a0-a5å¯„å­˜å™¨ä¸­ï¼Œè€Œé€šè¿‡å‰æ–‡å¯ä»¥çœ‹åˆ°ï¼Œå¯ä»¥é€šè¿‡myprocæ‹¿åˆ°ç”¨æˆ·è¿›ç¨‹çš„PCBï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªstruct proc *ï¼Œè¯¥ç»“æ„å†…çš„trapframeå†…æœ‰ç”¨æˆ·è¿›ç¨‹çš„å¯„å­˜å™¨çŠ¶æ€ï¼Œæ¯”å¦‚execè¦æ‹¿åˆ°ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œåªéœ€è¦æ‹¿åˆ°a0å³å¯ï¼Œå¦‚ä¸‹\n1 2 3 struct proc *p = myproc(); p-\u0026gt;trapframe-\u0026gt;a0 // è¿™ä¸ªå€¼å°±æ˜¯ç¬¬ä¸€ä¸ªå‚æ•° åœ¨kernel/syscall.cä¸­å·²ç»ç»™æˆ‘ä»¬å°è£…å¥½äº†ç›¸å…³çš„å‡½æ•°ï¼Œå¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 static uint64 argraw(int n) { struct proc *p = myproc(); switch (n) { case 0: return p-\u0026gt;trapframe-\u0026gt;a0; case 1: return p-\u0026gt;trapframe-\u0026gt;a1; case 2: return p-\u0026gt;trapframe-\u0026gt;a2; case 3: return p-\u0026gt;trapframe-\u0026gt;a3; case 4: return p-\u0026gt;trapframe-\u0026gt;a4; case 5: return p-\u0026gt;trapframe-\u0026gt;a5; } panic(\u0026#34;argraw\u0026#34;); return -1; } å¯ä»¥çœ‹åˆ°ï¼Œè°ƒç”¨ argraw(n)å¯ä»¥æ‹¿åˆ°ç¬¬nä¸ªå‚æ•°ï¼Œä¹Ÿå°±æ˜¯anå¯„å­˜å™¨çš„å€¼ï¼Œåœ¨è¯¥æ–‡ä»¶ä¸­è¿˜è¿›ä¸€æ­¥å°è£…äº†å¦å¤–å‡ ä¸ªå‡½æ•°\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Fetch the nth 32-bit system call argument. int argint(int n, int *ip) // è·å–æ•´æ•°ç±»å‹çš„å‚æ•° { *ip = argraw(n); return 0; } // Retrieve an argument as a pointer. // Doesn\u0026#39;t check for legality, since // copyin/copyout will do that. int argaddr(int n, uint64 *ip) // è·å–åœ°å€(æŒ‡é’ˆç±»å‹çš„å‚æ•°) { *ip = argraw(n); return 0; } // Fetch the nth word-sized system call argument as a null-terminated string. // Copies into buf, at most max. // Returns string length if OK (including nul), -1 if error. int argstr(int n, char *buf, int max) // è·å–å­—ç¬¦ä¸²ç±»å‹çš„å‚æ•° { uint64 addr; if(argaddr(n, \u0026amp;addr) \u0026lt; 0) return -1; // fetchstr ä»ç”¨æˆ·æ€çš„åœ°å€å¤„å°†å­—ç¬¦ä¸²å–å‡ºå¤åˆ¶åˆ°å†…æ ¸æ€ä¸­çš„bufå†… å†…æ ¸æ€å’Œç”¨æˆ·æ€ // çš„åœ°å€ç©ºé—´ä¸ä¸€æ ·(é¡µè¡¨ä¸åŒ) return fetchstr(addr, buf, max); } å…·ä½“åŠŸèƒ½è§æ³¨é‡Šã€‚\nç”¨æˆ·æ€stub ä½œä¸ºç”¨æˆ·ï¼Œå¦‚æœå¸Œæœ›è¿›è¡Œç³»ç»Ÿè°ƒç”¨ï¼Œè‚¯å®šä¸å¸Œæœ›å†™æ±‡ç¼–æ¥è°ƒç”¨ï¼Œé‚£ä¹ˆåœ¨ç”¨æˆ·æ€ä¸‹éœ€è¦å°è£…ä¸€å±‚å‡½æ•°æ¥é™·å…¥å†…æ ¸è¿›è¡Œç³»ç»Ÿè°ƒç”¨ï¼Œå¦‚ç”¨æˆ·å¸Œæœ›è°ƒç”¨æ–‡ä»¶ç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨åªéœ€æŒ‰ç…§ä¸‹é¢çš„ä»£ç ä¹¦å†™\n1 2 3 fd = open(\u0026#34;hello.txt\u0026#34;,O_CREAT|O_WRONLY); write(fd,\u0026#34;Hello,xv6!\u0026#34;,10); é‚£ä¹ˆä¸Šé¢è¿™äº›openã€writeçš„ä»£ç ç©¶ç«Ÿåœ¨å“ªé‡Œå‘¢ï¼Ÿè¿™äº›ä»£ç è¯¦è§user/usys.Sï¼Œæˆªå–è¿™ä¸¤ä¸ªå‡½æ•°ä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 .global open open: li a7, SYS_open ecall ret .global write write: li a7, SYS_write ecall ret åœ¨ç”¨æˆ·æ€ç¼–å†™ä»£ç func(a,b,c)æ—¶ï¼Œå…¶å®å°±æ˜¯å°†a,b,cçš„å€¼è£…å…¥a0,a1,a2å¯„å­˜å™¨ï¼Œç„¶åå°†ä¸‹ä¸€è·³æŒ‡ä»¤åœ°å€ä¿å­˜åœ¨raå¯„å­˜å™¨ï¼Œç„¶åè·³è½¬åˆ°funcåœ°å€å¤„æ‰§è¡Œï¼Œä¸Šé¢çš„openå’Œwriteå‡½æ•°åªéœ€è¦å‘a7å¯„å­˜å™¨è£…å…¥è°ƒç”¨å·ï¼Œå†ç”¨ecallå°±å¯ä»¥é™·å…¥å†…æ ¸è¿›è¡Œç³»ç»Ÿè°ƒç”¨äº†ã€‚\nå¯ä»¥çœ‹è§è¿™äº›ä»£ç éƒ½éå¸¸çš„ä¸€è‡´ï¼Œè‡ªå·±æ‰‹å†™æ˜¾å¾—å¤ªå‚»äº†ï¼Œæ•…xv6æºç ä¸­ç”¨usys.plè¿™ä¸ªperlè„šæœ¬è‡ªåŠ¨ç”Ÿæˆusys.Sï¼Œè¯¥è„šæœ¬å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/usr/bin/perl -w # Generate usys.S, the stubs for syscalls. print \u0026#34;# generated by usys.pl - do not edit\\n\u0026#34;; print \u0026#34;#include \\\u0026#34;kernel/syscall.h\\\u0026#34;\\n\u0026#34;; sub entry { my $name = shift; print \u0026#34;.global $name\\n\u0026#34;; print \u0026#34;${name}:\\n\u0026#34;; print \u0026#34; li a7, SYS_${name}\\n\u0026#34;; print \u0026#34; ecall\\n\u0026#34;; print \u0026#34; ret\\n\u0026#34;; } entry(\u0026#34;fork\u0026#34;); entry(\u0026#34;exit\u0026#34;); ... # æ¯ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨å†™ä¸€ä¸ªentry(\u0026#34;syscall_name\u0026#34;)å³å¯ åˆ°è¿™é‡Œå°±åŸºæœ¬çŸ¥é“ç³»ç»Ÿè°ƒç”¨æ˜¯æ€ä¹ˆå›äº‹äº†ï¼Œè™½ç„¶å…·ä½“ç»†èŠ‚ä¸å¤ªæ¸…æ¥šï¼Œä½†çŸ¥é“ä¸ªå¤§æ¦‚æµç¨‹å°±å¯ä»¥å¼€å§‹åšæœ¬æ¬¡å®éªŒäº†ã€‚\nç”¨æˆ·æ€å’Œå†…æ ¸æ€æ•°æ®ä¼ è¾“ ç”±äºç”¨æˆ·æ€å’Œå†…æ ¸æ€åœ°å€ç©ºé—´ä¸ä¸€æ ·ï¼Œæ•…ä¸èƒ½ç®€å•çš„é€šè¿‡åœ°å€æ¥ä¼ å…¥æˆ–ä¼ å‡ºæ•°æ®ï¼Œæ¥çœ‹çœ‹fstatç³»ç»Ÿè°ƒç”¨å¦‚ä½•ä¼ å‡ºstruct statç»“æ„ä½“åˆ°ç”¨æˆ·æ€ï¼Œçœ‹å…¶æºç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 uint64 sys_fstat(void) { struct file *f; uint64 st; // user pointer to struct stat if(argfd(0, 0, \u0026amp;f) \u0026lt; 0 || argaddr(1, \u0026amp;st) \u0026lt; 0) // è¿™é‡Œè°ƒç”¨argaddr(1,\u0026amp;st)åï¼Œstå³å­˜ç€ç”¨æˆ·ä¼ å…¥çš„struct stat*æŒ‡é’ˆçš„å€¼ return -1; return filestat(f, st); } å†çœ‹çœ‹filestatçš„å®ç°\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Get metadata about file f. // addr is a user virtual address, pointing to a struct stat. int filestat(struct file *f, uint64 addr) { struct proc *p = myproc(); struct stat st; if(f-\u0026gt;type == FD_INODE || f-\u0026gt;type == FD_DEVICE){ ilock(f-\u0026gt;ip); stati(f-\u0026gt;ip, \u0026amp;st); iunlock(f-\u0026gt;ip); if(copyout(p-\u0026gt;pagetable, addr, (char *)\u0026amp;st, sizeof(st)) \u0026lt; 0) // æ³¨æ„è¿™é‡Œå°†å†…æ ¸æ€çš„ç»“æ„å¤åˆ¶åˆ°ç”¨æˆ·æ€çš„åœ°å€å¤„ return -1; return 0; } return -1; } å¯ä»¥çœ‹åˆ°éœ€è¦é€šè¿‡copyoutå‡½æ•°æ¥å°†å†…æ ¸åœ°å€ç©ºé—´çš„æ•°æ®å¤åˆ¶åˆ°ç”¨æˆ·çš„åœ°å€ç©ºé—´ï¼Œå…¶ä¸­ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ç”¨æˆ·è¿›ç¨‹çš„é¡µè¡¨ã€‚\nå®éªŒ trace çœ‹çœ‹å®éªŒè¦åšä»€ä¹ˆ\nIn this assignment you will add a system call tracing feature that may help you when debugging later labs. You\u0026rsquo;ll create a new trace system call that will control tracing. It should take one argument, an integer \u0026ldquo;mask\u0026rdquo;, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls trace(1 \u0026lt;\u0026lt; SYS_fork), where SYS_fork is a syscall number from kernel/syscall.h. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call\u0026rsquo;s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don\u0026rsquo;t need to print the system call arguments. The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.\nå®éªŒåº”è¯¥è¾¾åˆ°çš„æ•ˆæœ\n1 2 3 4 5 $ trace 32 grep hello README # 32 å°±æ˜¯ 1 \u0026lt;\u0026lt; SYS_read 3: syscall read -\u0026gt; 1023 3: syscall read -\u0026gt; 966 3: syscall read -\u0026gt; 70 3: syscall read -\u0026gt; 0 æœ‰äº†å‰æ–‡çš„åŸºç¡€ï¼Œè¿™ä¸ªå®éªŒå…¶å®å¾ˆç®€å•ï¼Œé¦–å…ˆè¦æ‰¾ä¸ªåœ°æ–¹è®°å½•æŸä¸ªè¿›ç¨‹è¦traceçš„ç³»ç»Ÿè°ƒç”¨ï¼Œæ˜¾ç„¶åœ¨PCBå³struct procä¸­è®°å½•è¿™ä¸ªmaskæ¯”è¾ƒå¥½ï¼Œåœ¨è¯¥ç»“æ„ä¸­æ·»åŠ ä¸€ä¸ªmaskå­—æ®µå¦‚ä¸‹\n1 2 3 4 5 6 // Per-process state struct proc { ... // for syscall trace int trace_mask; // save the trace mask for a process }; é‚£ä¹ˆæ·»åŠ çš„ç³»ç»Ÿè°ƒç”¨åŠŸèƒ½å°±æ˜¯è®¾ç½®è¿›ç¨‹çš„trace_maskï¼Œåœ¨sysproc.cä¸­æ·»åŠ å¦‚ä¸‹ç³»ç»Ÿè°ƒç”¨å‡½æ•°å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 uint64 sys_trace(void) { struct proc *p = myproc(); int mask; argint(0,\u0026amp;mask); // get the mask argment p-\u0026gt;trace_mask = mask; // save the trace mask return 0; } åœ¨syscall.hä¸­æ·»åŠ ç³»ç»Ÿè°ƒç”¨å·ï¼Œå¦‚ä¸‹\n1 2 3 4 5 // System call numbers ... // added system call #define SYS_trace 22 æ¥ç€ä¿®æ”¹syscall.cä¸­çš„ç³»ç»Ÿè°ƒç”¨è¡¨ï¼Œæ·»åŠ ä¸€æ¡å¦‚ä¸‹\n1 2 3 4 5 6 7 8 // added system call extern uint64 sys_trace(void); // declaration static uint64 (*syscalls[])(void) = { ... // added syscall [SYS_trace] sys_trace, // æ·»åŠ ä¸€æ¡ç³»ç»Ÿè°ƒç”¨ }; ä¸ºäº†åœ¨è°ƒç”¨ç³»ç»Ÿè°ƒç”¨æ—¶è¾“å‡ºç›¸å…³ä¿¡æ¯ï¼Œä»”ç»†æƒ³æƒ³ï¼Œæ¯ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨éƒ½è¦ç»è¿‡syscallï¼Œé‚£ä¹ˆå¯ä»¥ä¿®æ”¹syscallï¼Œåœ¨ç³»ç»Ÿè°ƒç”¨åè¾“å‡ºtraceçš„ä¿¡æ¯ï¼Œä¿®æ”¹è¯¥å‡½æ•°å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // è®°å½•ç³»ç»Ÿè°ƒç”¨åå­— static char *syscalls_names[] = { \u0026#34;none\u0026#34;,\u0026#34;fork\u0026#34;,\u0026#34;exit\u0026#34;,\u0026#34;wait\u0026#34;,\u0026#34;pipe\u0026#34;,\u0026#34;read\u0026#34;,\u0026#34;kill\u0026#34;,\u0026#34;exec\u0026#34;,\u0026#34;fstat\u0026#34;,\u0026#34;chdir\u0026#34;,\u0026#34;dup\u0026#34;,\u0026#34;getpid\u0026#34;,\u0026#34;sbrk\u0026#34;, \u0026#34;sleep\u0026#34;,\u0026#34;uptime\u0026#34;,\u0026#34;open\u0026#34;,\u0026#34;write\u0026#34;,\u0026#34;mknod\u0026#34;,\u0026#34;unlink\u0026#34;,\u0026#34;link\u0026#34;,\u0026#34;mkdir\u0026#34;,\u0026#34;close\u0026#34;,\u0026#34;trace\u0026#34;,\u0026#34;sysinfo\u0026#34; }; void syscall(void) { int num; struct proc *p = myproc(); num = p-\u0026gt;trapframe-\u0026gt;a7; if(num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt; NELEM(syscalls) \u0026amp;\u0026amp; syscalls[num]) { p-\u0026gt;trapframe-\u0026gt;a0 = syscalls[num](); // a0 ä¸­å­˜ç€è¿”å›å€¼ if((p-\u0026gt;trace_mask \u0026amp; (1 \u0026lt;\u0026lt; num)) != 0){ // it is a traced system call // å¦‚æœè¯¥ç³»ç»Ÿè°ƒç”¨çš„maskè®¾ç½®è¿‡äº†ï¼Œåˆ™è¾“å‡ºä¿¡æ¯ printf(\u0026#34;%d: syscall %s -\u0026gt; %d\\n\u0026#34;,p-\u0026gt;pid,syscalls_names[num],p-\u0026gt;trapframe-\u0026gt;a0); } } else { printf(\u0026#34;%d %s: unknown sys call %d\\n\u0026#34;, p-\u0026gt;pid, p-\u0026gt;name, num); p-\u0026gt;trapframe-\u0026gt;a0 = -1; } } æ³¨æ„æŒ‰ç…§ä»»åŠ¡è¦æ±‚ï¼Œå¦‚æœä¸€ä¸ªè¿›ç¨‹traceæŸäº›ç³»ç»Ÿè°ƒç”¨ï¼Œé‚£ä¹ˆè¯¥è¿›è¡Œforkå‡ºæ¥çš„å­è¿›ç¨‹ä¹Ÿè¦traceè¿™äº›ç³»ç»Ÿè°ƒç”¨ï¼Œforkç³»ç»Ÿè°ƒç”¨ä»£ç å¦‚ä¸‹\n1 2 3 4 5 uint64 sys_fork(void) { return fork(); } æŸ¥çœ‹è¿™ä¸ªforkå‡½æ•°ä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // Create a new process, copying the parent. // Sets up child kernel stack to return as if from fork() system call. int fork(void) { int i, pid; struct proc *np; struct proc *p = myproc(); // Allocate process. if((np = allocproc()) == 0){ return -1; } // Copy user memory from parent to child. if(uvmcopy(p-\u0026gt;pagetable, np-\u0026gt;pagetable, p-\u0026gt;sz) \u0026lt; 0){ freeproc(np); release(\u0026amp;np-\u0026gt;lock); return -1; } np-\u0026gt;sz = p-\u0026gt;sz; np-\u0026gt;parent = p; // copy saved user registers. *(np-\u0026gt;trapframe) = *(p-\u0026gt;trapframe); // Cause fork to return 0 in the child. np-\u0026gt;trapframe-\u0026gt;a0 = 0; // increment reference counts on open file descriptors. for(i = 0; i \u0026lt; NOFILE; i++) if(p-\u0026gt;ofile[i]) np-\u0026gt;ofile[i] = filedup(p-\u0026gt;ofile[i]); np-\u0026gt;cwd = idup(p-\u0026gt;cwd); safestrcpy(np-\u0026gt;name, p-\u0026gt;name, sizeof(p-\u0026gt;name)); pid = np-\u0026gt;pid; np-\u0026gt;state = RUNNABLE; release(\u0026amp;np-\u0026gt;lock); return pid; } å…·ä½“ç»†èŠ‚ä¸è°ˆï¼Œä½†ä»ä¸Šé¢çš„ä»£ç å¯ä»¥çœ‹å‡ºï¼Œpæ˜¯å½“å‰è¿›ç¨‹PCBï¼Œnpæ˜¯forkå‡ºæ¥çš„ï¼Œæ–°çš„è¿›ç¨‹çš„PCBï¼Œè¯¥å‡½æ•°å°±æ˜¯åœ¨æ‰§è¡Œå¤åˆ¶è¿›ç¨‹çš„å·¥ä½œã€‚ä¸ºäº†è®©å­è¿›ç¨‹å¯ä»¥traceå’Œçˆ¶è¿›ç¨‹åŒæ ·çš„ç³»ç»Ÿè°ƒç”¨ï¼Œéœ€è¦å°†çˆ¶è¿›ç¨‹çš„trace_maskä¹Ÿå¤åˆ¶ä¸€ä¸‹ï¼Œæ·»åŠ ä¸€è¡Œä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 // Create a new process, copying the parent. // Sets up child kernel stack to return as if from fork() system call. int fork(void) { ... // copy trace mask np-\u0026gt;trace_mask = p-\u0026gt;trace_mask; ... return pid; } è‡³æ­¤å®Œæˆäº†æ·»åŠ å‡½æ•°è°ƒç”¨çš„ä»»åŠ¡ï¼Œæ¥ä¸‹æ¥è¿˜éœ€è¦ç»™ç”¨æˆ·å¢åŠ æ¥å£ï¼Œæ•…åœ¨usys.plä¸­æœ«å°¾æ·»åŠ ä»£ç å¦‚ä¸‹(ä½œç”¨è§ ç”¨æˆ·æ€stub é‚£ä¸€å°èŠ‚)\n1 2 3 ... # added system call entry(\u0026#34;trace\u0026#34;); åœ¨å¤´æ–‡ä»¶user/user.hä¸­æ·»åŠ è¯¥ç³»ç»Ÿè°ƒç”¨åŸå‹å¦‚ä¸‹\n1 2 // added system call int trace(int mask); ä¸€åˆ‡å®Œæˆåæµ‹è¯•èƒ½å¦é€šè¿‡æµ‹è¯•ï¼Œå¦‚ä¸‹\nsysinfo ç¬¬äºŒä¸ªæ·»åŠ çš„ç³»ç»Ÿè°ƒç”¨æ ¹æ®å®éªŒæŒ‡å¯¼ä¹¦æè¿°å¦‚ä¸‹\nIn this assignment you will add a system call, sysinfo, that collects information about the running system. The system call takes one argument: a pointer to a struct sysinfo (see kernel/sysinfo.h). The kernel should fill out the fields of this struct: the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED. We provide a test program sysinfotest; you pass this assignment if it prints \u0026ldquo;sysinfotest: OK\u0026rdquo;.\nå¯ä»¥çœ‹åˆ°ï¼Œsysinfoç³»ç»Ÿè°ƒç”¨è¦æ±‚ç»™ç”¨æˆ·è¿”å›å¦‚ä¸‹ç»“æ„\n1 2 3 4 struct sysinfo { uint64 freemem; // amount of free memory (bytes) uint64 nproc; // number of process }; æŒ‡å¯¼ä¹¦ä¸Šæ¯”è¾ƒå…³é”®çš„å‡ å¥æç¤ºå¦‚ä¸‹\nsysinfo needs to copy a struct sysinfo back to user space; see sys_fstat() (kernel/sysfile.c) and filestat() (kernel/file.c) for examples of how to do that using copyout(). To collect the amount of free memory, add a function to kernel/kalloc.c To collect the number of processes, add a function to kernel/proc.c å…¶ä¸­ç¬¬ä¸€ç‚¹åœ¨å‰æ–‡ä¸­æœ‰æ‰€æè¿°ã€‚\nä½†éå¸¸ç¾æ„§çš„æ˜¯ï¼Œç¬¬äºŒç¬¬ä¸‰ç‚¹ï¼Œé“ç†æˆ‘éƒ½æ‡‚ï¼Œå¯æ˜¯å…³äºxv6æˆ‘è¿˜ä¸€æ— æ‰€çŸ¥ï¼Œæˆ‘æ€ä¹ˆçŸ¥é“æ€ä¹ˆè·å–ç³»ç»Ÿè¿›ç¨‹æ•°å’Œç©ºé—²å†…å­˜å‘€ğŸ˜…ï¼Œä¹Ÿæ²¡æœ‰ä¸€ç‚¹æç¤ºï¼Œè¿˜æ²¡çœ‹åˆ°xv6çš„å†…å­˜ç®¡ç†å’Œè¿›ç¨‹è°ƒåº¦å‘¢ğŸ¤¡\næ— å¥ˆç¨å¾®åœ¨ç½‘ä¸ŠæŸ¥äº†ä¸€ä¸‹ğŸ™ƒï¼Œç¼–å†™è·å–ç©ºé—²å†…å­˜çš„ä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // kalloc.c struct run { struct run *next; }; struct { struct spinlock lock; struct run *freelist; } kmem; // return number of free bytes uint64 free_bytes(){ struct run *p = kmem.freelist; uint64 num_of_free_page = 0; while(p){ num_of_free_page ++; p = p-\u0026gt;next; } return num_of_free_page * PGSIZE; } ä¸Šé¢ä»£ç ä¸­çš„kmemç”¨äºç®¡ç†å†…å­˜ï¼Œè¯¥ç»“æ„å†…æœ‰ä¸€ä¸ªlockå’Œfreelistï¼Œé¡¾åæ€ä¹‰freeliståº”è¯¥å°±æ˜¯ä¸²èµ·ç©ºé—²é¡µçš„ç»“æ„(ç°å¸¸å¥‡æ€ªï¼Œè¿™ä¸ªé“¾è¡¨èŠ‚ç‚¹struct runä¸ºæ¯›åªæœ‰ä¸€ä¸ªæŒ‡é’ˆ\u0026hellip;)ï¼Œä½†æ€»ä¹‹å…ˆè¿™æ ·å§ï¼Œåé¢åšå†…å­˜ç®¡ç†æ—¶ä¼šçŸ¥é“æ€ä¹ˆå›äº‹çš„ğŸ¤£\nä¸Šé¢ä»£ç çš„free_byteså³è·å–ç©ºé—²å†…å­˜å­—èŠ‚æ•°çš„å‡½æ•°ã€‚\næ¥ä¸‹æ¥å†çœ‹çœ‹æ€ä¹ˆè·å–ç³»ç»Ÿè¿›ç¨‹æ•°ç›®ï¼Œä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 struct proc proc[NPROC]; // get the number of process uint64 num_proc(){ uint64 sum = 0; for(int i = 0;i \u0026lt; NPROC;i ++) if(proc[i].state != UNUSED) sum ++; return sum; } ä¸Šé¢ä»£ç ä¸­çš„procç»“æ„ä½“å°±æ˜¯å­˜æ‰€æœ‰è¿›ç¨‹çš„çŠ¶æ€çš„ï¼Œstruct procè¿™ä¸ªç»“æ„ä½“åœ¨å‰æ–‡ä¹Ÿçœ‹åˆ°è¿‡ï¼Œå†æ¬¡å±•ç¤ºå¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 enum procstate { UNUSED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE }; // Per-process state struct proc { struct spinlock lock; // p-\u0026gt;lock must be held when using these: enum procstate state; // Process state struct proc *parent; // Parent process void *chan; // If non-zero, sleeping on chan int killed; // If non-zero, have been killed int xstate; // Exit status to be returned to parent\u0026#39;s wait int pid; // Process ID // these are private to the process, so p-\u0026gt;lock need not be held. uint64 kstack; // Virtual address of kernel stack uint64 sz; // Size of process memory (bytes) pagetable_t pagetable; // User page table struct trapframe *trapframe; // data page for trampoline.S struct context context; // swtch() here to run process struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory char name[16]; // Process name (debugging) // for syscall trace int trace_mask; }; å…¶ä¸­stateä¸ºè¿›ç¨‹çŠ¶æ€ï¼ŒUNUSEDè¡¨ç¤ºprocæ•°ç»„ä¸­è¯¥é¡¹è¿˜æœªè¢«ä½¿ç”¨ï¼Œæ•…è¦å¾—åˆ°è¿›ç¨‹æ•°ï¼Œåªéœ€è¦éå†procæ•°ç»„ï¼Œçœ‹çœ‹ä¸æ˜¯UNUSEDçš„æœ‰å¤šå°‘ä¸ªå³å¯ï¼Œå…·ä½“ä»£ç è§ä¸Šé¢çš„num_proc.\nå†™äº†num_procå’Œfree_bytesè¿™ä¿©å‡½æ•°åï¼Œæ¥ç€å°±å¾ˆå®¹æ˜“ç¼–å†™æˆ‘ä»¬çš„ç³»ç»Ÿè°ƒç”¨äº†ï¼Œåœ¨kernel/sysproc.cæ·»åŠ å¦‚ä¸‹ç³»ç»Ÿè°ƒç”¨ä»£ç \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 uint64 sys_sysinfo(void) { uint64 info; // user pointer to struct sysinfo struct sysinfo si; struct proc *p = myproc(); uint64 num_proc(); uint64 free_bytes(); si.freemem = free_bytes(); si.nproc = num_proc(); argaddr(0,\u0026amp;info); // get user\u0026#39;s pointer to struct sysinfo if(copyout(p-\u0026gt;pagetable,info,(char *)\u0026amp;si,sizeof(si)) \u0026lt; 0) // use copyout to copy si to user address space return -1; return 0; } å…¶ä»–æ“ä½œåœ¨æ­¤ç•¥è¿‡ï¼Œè¯¦è§ä¸Šä¸€å°èŠ‚ï¼ˆå¦‚æ·»åŠ ç³»ç»Ÿè°ƒç”¨å·ï¼Œä¿®æ”¹syscall.cç­‰ç­‰ï¼‰.\nå°¾å£° è¿™ä¸ªç³»åˆ—å¯è°“æ˜¯å†™ä¸€ç¯‡å°‘ä¸€ç¯‡å•¦ğŸ˜†\nå¯æŒ‡ä¸å‡†å•¥æ—¶å€™å°±â€œä¸­é“å´©æ®‚â€äº†ï¼Œä¸è¿‡ä¸ç®¡æ€ä¹ˆè¯´ï¼Œå‰ä¸¤ä¸ªå®éªŒåšå®Œå•¦ï¼\nè¿™ä¸¤ä¸ªå®éªŒéƒ½åªæ˜¯æ‘¸æ‘¸xv6çš„è¡¨é¢ï¼Œä¸‹ä¸€ä¸ªå®éªŒç»ˆäºæ­£å¼å’Œæ“ä½œç³»ç»Ÿç›¸å…³å•¦ï¼è¿›å…¥å†…å­˜ç®¡ç†é˜¶æ®µï¼ï¼\n","date":"2023-01-06T22:37:47+08:00","image":"https://XieWeikai.github.io/aniya_blog/p/lab2-system-calls/cover_hu7ace472778f385b50e7c8f287dbb6c46_2544271_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/lab2-system-calls/","title":"lab2: system calls"},{"content":"xv6 util lab åœ¨é—²æš‡ä¹‹ä½™ï¼ŒæŠ½å‡ºäº†ä¸€éƒ¨åˆ†æ—¶é—´çœ‹äº†çœ‹MIT 6.S081è¯¾ç¨‹çš„å®éªŒä¸€ï¼Œè¿™ä¸ªå®éªŒå¯èƒ½ä¹Ÿè®¸æ˜¯æœ€ç®€å•çš„ä¸€ä¸ªå®éªŒäº†å§ï¼Œå®Œå…¨æ²¡æœ‰æ¶‰åŠåˆ°æ“ä½œç³»ç»Ÿå†…éƒ¨åŸç†ç›¸å…³çš„çŸ¥è¯†ï¼Œåªæ˜¯ç”¨xv6çš„ç³»ç»Ÿè°ƒç”¨ç¼–å†™ç”¨æˆ·æ€çš„ç¨‹åºã€‚æˆ‘ä¹Ÿä¸çŸ¥é“èŠ±äº†ä¸çŸ¥é“å¤šä¹…ï¼Œæ–­æ–­ç»­ç»­çš„æŠŠå®éªŒä¸€å¹²å®Œäº†ã€‚è¯¥å®éªŒçš„å®éªŒè¦æ±‚è§ https://pdos.csail.mit.edu/6.828/2020/labs/util.html.\nå‡†å¤‡ ç¼–è¯‘å¹¶ä½¿ç”¨qemuæ¨¡æ‹Ÿå¯åŠ¨æ“ä½œç³»ç»Ÿæ–¹æ³•ä¸º\n1 make qemu æ‰“åˆ†æµ‹è¯•çš„å‘½ä»¤å¦‚ä¸‹\n1 make grade æµ‹è¯•æŸä¸ªå…·ä½“çš„ç”¨ä¾‹ï¼Œå¦‚æµ‹è¯•sleepï¼Œæ–¹æ³•æœ‰ä¸¤ç§\n1 2 ./grade-lab-util sleep # ç¬¬ä¸€ç§æ–¹æ³• make GRADEFLAGS=sleep grade # ç¬¬äºŒç§æ–¹æ³• sleep è¯¥ä»»åŠ¡éå¸¸ç®€å•ï¼Œå†™ä¸€ä¸ªsleepç¨‹åºï¼Œèƒ½é€šè¿‡å‘½ä»¤è¡Œå‚æ•°æŒ‡å®šsleepçš„tickæ•°(tickæŒ‡ä¸€ä¸ªæ—¶é’Ÿå‘¨æœŸ)ã€‚ç¨‹åºéå¸¸ç®€å•ï¼Œåœ¨userç›®å½•ä¸‹æ–°å»ºæ–‡ä»¶sleep.cï¼Œç¼–å†™ä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; int main(int argc, char *argv[]) { if(argc \u0026lt;= 1){ write(1,\u0026#34;error: no input from user !\\n\u0026#34;,28); exit(-1); } sleep(atoi(argv[1])); // sleep ä¸ºç³»ç»Ÿè°ƒç”¨ å‚æ•°ä¸ºtickæ•°ï¼Œå°†å‘½ä»¤è¡Œå‚æ•°é€šè¿‡atoiè½¬ä¸ºæ•´æ•°å³å¯ exit(0); } ç¼–å†™å®Œæˆåè¿˜éœ€è¦ä¿®æ”¹Makefileä¸­çš„UPROGS(è¿™åº”è¯¥æ˜¯user programsçš„æ„æ€)ï¼Œæ·»åŠ sleepï¼Œå¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 U=user # ç”¨æˆ·æ€ç¨‹åºç›®å½• UPROGS=\\ $U/_cat\\ $U/_echo\\ $U/_forktest\\ $U/_grep\\ $U/_init\\ $U/_kill\\ $U/_ln\\ $U/_ls\\ $U/_mkdir\\ $U/_rm\\ $U/_sh\\ $U/_stressfs\\ $U/_usertests\\ $U/_grind\\ $U/_wc\\ $U/_zombie\\ $U/_sleep # è¿™æ˜¯æ·»åŠ çš„ä¸€è¡Œå†…å®¹ ä¿®æ”¹åmake qemuè¿›å…¥xv6ç³»ç»Ÿå¯ä»¥çœ‹åˆ°å¤šå‡ºäº†ä¸€ä¸ªsleepç¨‹åºã€‚è¯¥ç¨‹åºèƒ½é€šè¿‡æ‰“åˆ†ç¨‹åºã€‚\npingpong è¿™ä¸ªä¹Ÿå¾ˆç®€å•ï¼Œç›´æ¥è´´ä¸Šuser/pingpong.cä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; int main(int argc, char *argv[]) { int p1[2],p2[2]; char byte; // byte // ä¸¤æ¡ç®¡é“ åŒå‘é€šä¿¡ pipe(p1); // parent to child pipe(p2); // child to parent if(fork() != 0){ // parent close(p2[1]); close(p1[0]); write(p1[1],\u0026#34;0\u0026#34;,1); // write a byte read(p2[0],\u0026amp;byte,1); // read a byte printf(\u0026#34;%d: received pong\\n\u0026#34;,getpid()); close(p2[0]); close(p1[1]); exit(0); }else{ // child close(p2[0]); close(p1[1]); read(p1[0],\u0026amp;byte,1); // read a byte printf(\u0026#34;%d: received ping\\n\u0026#34;,getpid()); write(p2[1],\u0026amp;byte,1); // write a byte close(p2[1]); close(p1[0]); exit(0); } } primes è¯¥ä»»åŠ¡éœ€è¦ç¼–å†™ç¨‹åºè¾“å‡º2~35ä¸­çš„æ‰€æœ‰è´¨æ•°ï¼Œæ¯”è¾ƒç‰¹æ®Šçš„è¦æ±‚æ˜¯ä½¿ç”¨å¹¶å‘çš„æ–¹å¼æ¥ç­›é€‰è´¨æ•°ï¼Œç®—æ³•æè¿°è§ http://swtch.com/~rsc/thread/\nç®—æ³•æè¿° ç”¨ä¸€å¼ å›¾æ¥æè¿°è¿™ä¸ªç­›é€‰è´¨æ•°çš„å¹¶å‘ç®—æ³•ï¼Œå¦‚ä¸‹\nä¸Šå›¾ä¸­æ¯ä¸€ä¸ªæ¡†æ¡†ä¸ºä¸€ä¸ªç‹¬ç«‹æ‰§è¡Œçš„ä¾‹ç¨‹(å¯ä»¥æ˜¯processã€threadæˆ–è€…åˆ«çš„ä»€ä¹ˆæ¯”å¦‚golangä¸­çš„goroutineï¼Œæ€»ä¹‹æ˜¯å¯ä»¥å¹¶å‘æ‰§è¡Œçš„ä¸€æ®µç¨‹åº)ï¼Œæ¯ä¸€ä¸ªä¾‹ç¨‹å¯ä»¥ç»™å³è¾¹çš„é‚»å±…å‘é€ç­›é€‰å‡ºæ¥çš„æœ‰å¯èƒ½æ˜¯è´¨æ•°çš„æ•°ï¼Œæ¯ä¸€ä¸ªä¾‹ç¨‹éƒ½ä¼šè¿›è¡Œç›¸åº”çš„ç­›é€‰ï¼Œé€‰å‡ºæ¥çš„æ•°å‘ç»™å³è¾¹çš„é‚»å±…ã€‚\nå…¶ä¸­ç¬¬ä¸€ä¸ªä¾‹ç¨‹ä¼šæ”¶åˆ°2-MAXæ‰€æœ‰çš„æ•°å­—ï¼Œæ”¶åˆ°çš„ç¬¬ä¸€ä¸ªæ•°å­—å½“åšè´¨æ•°è¾“å‡º(æ˜¾ç„¶ç¬¬ä¸€ä¸ªæ•°æ˜¯2ï¼Œæ˜¯è´¨æ•°)ã€‚ç¬¬ä¸€ä¸ªä¾‹ç¨‹çŸ¥é“2æ˜¯è´¨æ•°äº†ï¼Œé‚£ç¬¬ä¸€ä¸ªä¾‹ç¨‹æ¥ä¸‹æ¥æ”¶åˆ°çš„æ‰€æœ‰æ•°å­—ï¼Œå¦‚æœå¯ä»¥è¢«2æ•´é™¤ï¼Œé‚£ä¸€å®šä¸æ˜¯è´¨æ•°ï¼Œä¸èƒ½è¢«2æ•´é™¤çš„æœ‰å¯èƒ½æ˜¯è´¨æ•°ï¼Œå°†æœ‰å¯èƒ½æ˜¯è´¨æ•°çš„æ•°å‘é€ç»™å³è¾¹çš„é‚»å±…ï¼Œå³è¾¹çš„é‚»å±…åšè¿›ä¸€æ­¥çš„ç­›é€‰ã€‚\næ¥ä¸‹æ¥çœ‹ç¬¬äºŒä¸ªä¾‹ç¨‹ï¼Œå¯ä»¥ç¡®å®šçš„æ˜¯ï¼Œç¬¬äºŒä¸ªä¾‹ç¨‹æ”¶åˆ°çš„ç¬¬ä¸€ä¸ªä¾‹ç¨‹çš„ç¬¬ä¸€ä¸ªæ•°å­—ä¸€å®šä¹Ÿæ˜¯ä¸ªè´¨æ•°ã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Ÿç¬¬äºŒä¸ªä¾‹ç¨‹æ”¶åˆ°çš„ç¬¬ä¸€ä¸ªæ•°å­—(è®°ä½œp)ä¸€å®šå¤§äº2(å¤§äºå‰ä¸€ä¸ªä¾‹ç¨‹è®¤å®šäº†æ˜¯è´¨æ•°çš„æ•°)ï¼Œæ‰€æœ‰å°äºpçš„è´¨æ•°(ç›®å‰æ¥çœ‹å°±æ˜¯2)éƒ½ä¸æ˜¯pçš„å› å­ï¼Œé‚£pè‚¯å®šä¹Ÿæ˜¯è´¨æ•°ã€‚æ‰€ä»¥ç¬¬äºŒä¸ªä¾‹ç¨‹å¯ä»¥å°†æ”¶åˆ°çš„ç¬¬ä¸€ä¸ªæ•°è®¤å®šä¸ºè´¨æ•°ï¼Œå°†å…¶è¾“å‡ºã€‚æ¥ä¸‹æ¥æ”¶åˆ°çš„æ•°å­—ï¼Œç¬¬äºŒä¸ªä¾‹ç¨‹å°†æ£€æµ‹æ˜¯å¦èƒ½è¢«pæ•´é™¤ï¼Œè‹¥ä¸èƒ½æ‰å¯èƒ½æ˜¯è´¨æ•°ï¼Œç¬¬äºŒä¸ªä¾‹ç¨‹ä¼šå°†æœ‰å¯èƒ½æ˜¯è´¨æ•°çš„æ•°å‘ç»™å³è¾¹çš„é‚»å±…ï¼ˆå³ç¬¬ä¸‰ä¸ªä¾‹ç¨‹ï¼‰ã€‚æ˜¾ç„¶ç¬¬ä¸‰ä¸ªä¾‹ç¨‹æ”¶åˆ°çš„æ•°å­—ä¸€å®šä¸ä¼šè¢«å‰ä¸¤ä¸ªè´¨æ•°æ•´é™¤ï¼Œé‚£ä¹ˆç¬¬ä¸‰ä¸ªä¾‹ç¨‹æ”¶åˆ°çš„ç¬¬ä¸€ä¸ªæ•°å­—ä¹Ÿæ˜¯ä¸ªè´¨æ•°\u0026hellip;\u0026hellip;\nç”¨æ•°å­¦å½’çº³æ³•å¯ä»¥å®¹æ˜“çœ‹å‡ºï¼Œæ¯ä¸ªä¾‹ç¨‹æ”¶åˆ°çš„ç¬¬ä¸€ä¸ªæ•°éƒ½æ˜¯è´¨æ•°ï¼Œä¸”æ¯ä¸€ä¸ªä¾‹ç¨‹éƒ½ä¼šæŠŠå¯èƒ½æ˜¯è´¨æ•°çš„æ•°å‘ç»™å³é‚»å±…è¿›ä¸€æ­¥ç­›é€‰ï¼Œæ¯ä¸€ä¸ªä¾‹ç¨‹è¡Œä¸ºçš„ä¼ªä»£ç æè¿°ä¸º\n1 2 3 4 5 6 p = get a number from left neighbor print p loop: n = get a number from left neighbor if (p does not divide n) send n to right neighbor ç®—æ³•å®ç° è¿™ä¸ªä»»åŠ¡å°±è¦å®ç°è¿™ä¸€ä¸ªç®—æ³•ã€‚åœ¨æˆ‘çš„å®ç°ä¸­ï¼Œä½¿ç”¨è¿›ç¨‹ä½œä¸ºä¸€ä¸ªç‹¬ç«‹çš„ä¾‹ç¨‹ï¼Œä¸»è¿›ç¨‹è´Ÿè´£å‘é€2-35æ‰€æœ‰çš„æ•°å­—ï¼Œç„¶åå¼€å¯ç¬¬ä¸€ä¸ªè¿›ç¨‹è¿›è¡Œç­›é€‰ï¼Œæ¥ç€æ¯ä¸€ä¸ªè¿›ç¨‹æ ¹æ®éœ€è¦åˆ¤æ–­æ˜¯å¦éœ€è¦å¼€å¯å³é‚»å±…ï¼Œå…ˆçœ‹ä¸»è¿›ç¨‹ä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main(int argc,char *argv[]){ int p; int to[2]; int status; pipe(to); // to æ˜¯ä¸»è¿›ç¨‹å‘é€2~35æ‰€æœ‰æ•°å­—ç»™ç¬¬ä¸€ä¸ªä¾‹ç¨‹æ‰€ç”¨çš„ç®¡é“ if(fork() != 0){ // parent close(to[0]); // do not read ä¸ç”¨çš„èµ„æºå°½å¿«close ä¸»è¿›ç¨‹ç”¨è¯¥ç®¡é“ä¸éœ€è¦è¯» for(p = 2;p \u0026lt;= 35;p++) write(to[1],\u0026amp;p,sizeof(p)); // å°†2~35æ‰€æœ‰æ•°å­—å†™å…¥ç®¡é“ close(to[1]); }else{ // child worker(to); // å­è¿›ç¨‹ï¼Œå³ä¸Šé¢ç¤ºæ„å›¾ä¸­çš„ä¾‹ç¨‹ï¼Œæ¥æ”¶çˆ¶è¿›ç¨‹å‘é€çš„æ•°å­— exit(0); } wait(\u0026amp;status); // ä¸»è¿›ç¨‹ç­‰å¾…å­è¿›ç¨‹ç»“æŸ exit(0); } æ¥ç€æ¥çœ‹çœ‹æ¯ä¸€ä¸ªä¾‹ç¨‹çš„æè¿°å‡½æ•°workerçš„å®ç°ï¼Œworkerå®Œå…¨æŒ‰ç…§å‰æ–‡çš„ä¼ªä»£ç å®ç°\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void worker(int from[]){ // å‚æ•°ä¸ºæ¥æ”¶å·¦é‚»å±…æ•°å­—çš„ç®¡é“ int forked = 0; // æ ‡è®°æ˜¯å¦å¼€å¯è¿‡å³é‚»å±…è¿›ç¨‹ int to[2]; close(from[1]); // do not write to from è¯¥ç®¡é“æˆ‘åªä½¿ç”¨è¯»ç«¯ï¼Œä¸ä½¿ç”¨å†™ç«¯ï¼Œæ²¡ç”¨çš„èµ„æºå°½å¿«é‡Šæ”¾ int p; // æ¥æ”¶ç¬¬ä¸€ä¸ªæ•°å­— read(from[0],\u0026amp;p,sizeof(p)); // read first p printf(\u0026#34;prime %d\\n\u0026#34;,p); // ç¬¬ä¸€ä¸ªæ•°å­—ä¸€å®šæ˜¯è´¨æ•° int t; // æ¥æ”¶æ•°å­— while(read(from[0],\u0026amp;t,sizeof(t) != 0)){ // è¯¥å¾ªç¯é‡Œé¢ä¸æ–­æ¥æ”¶æ•°å­—ï¼ŒæŒ‘å‡ºå¯èƒ½æ˜¯è´¨æ•°çš„æ•°å­—å‘ç»™å³é‚»å±… if(t % p != 0){ // tæœ‰å¯èƒ½æ˜¯è´¨æ•° è¿™éœ€è¦å‘ç»™å³é‚»å±…äº† if(!forked){ // è¿˜æ²¡æœ‰å³é‚»å±… pipe(to); // åˆ›å»ºå’Œå³é‚»å±…é€šä¿¡çš„ç®¡é“ if(fork() != 0){ // parent close(to[0]);// æœ¬è¿›ç¨‹å…³é—­ç®¡é“è¯»ç«¯ }else{ // child worker(to); // å­è¿›ç¨‹ä»toè¯»å–æ•°å­— exit(0); } forked = 1; // æ ‡è®°å·²ç»å¼€å¯è¿‡å­è¿›ç¨‹ } write(to[1],\u0026amp;t,sizeof(t)); // å‘é€tç»™å­è¿›ç¨‹ } } // é‡Šæ”¾èµ„æº close(from[0]); close(to[1]); // ç­‰å¾…å³é‚»å±…é€€å‡º int status; wait(\u0026amp;status); } ä»¥ä¸Šä¸¤æ®µä»£ç å®ç°äº†è¯¥ä»»åŠ¡ã€‚\nå¦å¤–åæ§½ä¸€ä¸‹ï¼Œç»è¿‡æˆ‘çš„å°è¯•ï¼Œä¸‹é¢è¿™æ®µä»£ç ä¹Ÿæ˜¯å¯ä»¥é€šè¿‡æµ‹è¯•çš„ï¼Œçœ‹æ¥MITçš„æµ‹è¯•ä¹Ÿä¸è¿‡æ˜¯éªŒè¯è¾“å‡ºç½¢äº†\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int is_prime(int n){ int p = n/2; for(int i = 2; i \u0026lt;= p;i++){ if(n % p == 0) return 0; } return 1; } int main(int argc, char *argv[]) { for(int i =2;i \u0026lt;= 35;i++){ if(is_prime(i)) printf(\u0026#34;prime %d\\n\u0026#34;,i); } exit(0); } find è¯¥ä»»åŠ¡éœ€è¦å®ç°ä¸€ä¸ªæç®€ç‰ˆçš„findï¼ŒåŠŸèƒ½å¦‚ä¸‹æ‰€è¿°\n1 find \u0026lt;path\u0026gt; \u0026lt;filename\u0026gt; åœ¨\u0026lt;path\u0026gt;è·¯å¾„ä¸­æœç´¢æ–‡ä»¶åä¸º\u0026lt;filename\u0026gt;çš„æ–‡ä»¶ï¼Œç¤ºä¾‹å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 $ make qemu ... init: starting sh $ echo \u0026gt; b $ mkdir a $ echo \u0026gt; a/b $ find . b ./b ./a/b $ xv6çš„ç›®å½•é¡¹ åœ¨ç±»unixç³»ç»Ÿä¸­ä¸€èˆ¬ä½¿ç”¨åŸºäºinodeçš„æ–‡ä»¶ç³»ç»Ÿ(å¯ä»¥å‚è€ƒä¸Šäº¤çš„ã€Šç°ä»£æ“ä½œç³»ç»Ÿ:åŸç†ä¸å®ç°ã€‹ä¸ªäººæ„Ÿè§‰æŒºä¸é”™)ï¼Œåœ¨è¿™ç§æ–‡ä»¶ç³»ç»Ÿä¸‹ï¼Œinodeè®°å½•äº†ä¸€ä¸ªæ–‡ä»¶çš„æ‰€æœ‰å†…å®¹å­˜åœ¨diskçš„ä½ç½®ï¼Œæ‰€ä»¥çŸ¥é“äº†inodeå°±çŸ¥é“äº†æŸä¸€ä¸ªæ–‡ä»¶ã€‚åœ¨ç±»UNIXç³»ç»Ÿä¸‹ç›®å½•ä¹Ÿæ˜¯æ™®é€šçš„æ–‡ä»¶ï¼Œæ–‡ä»¶å†…å­˜ç€ä¸€ä¸ªä¸ªç›®å½•é¡¹ï¼Œå³è®°å½•ç€inodeå·å’Œå…¶ä»–ä¸€äº›æ–‡ä»¶ä¿¡æ¯ï¼Œåœ¨xv6å†…ï¼Œç›®å½•é¡¹å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 // kernel/fs.h // Directory is a file containing a sequence of dirent structures. #define DIRSIZ 14 struct dirent { ushort inum; // inode number char name[DIRSIZ]; // filename }; fstatå’Œstat xv6ä¸­è·å–æ–‡ä»¶ä¿¡æ¯çš„ç³»ç»Ÿè°ƒç”¨ä¸ºfstatï¼Œä½¿ç”¨è¯¥å‡½æ•°è¿˜å°è£…äº†ä¸€ä¸ªç”¨æˆ·æ€ä¸‹çš„å·¥å…·å‡½æ•°statï¼Œä¸¤ä¸ªå‡½æ•°åŸå‹å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // system call int fstat(int fd, struct stat*); // fd ä¸ºæ–‡ä»¶æè¿°ç¬¦ // ulib.c int stat(const char*, struct stat*); int stat(const char *n, struct stat *st) // å‡½æ•°å®šä¹‰ { int fd; int r; fd = open(n, O_RDONLY); if(fd \u0026lt; 0) return -1; r = fstat(fd, st); close(fd); return r; } å…¶ä¸­æè¿°æ–‡ä»¶ä¿¡æ¯çš„ç»“æ„å®šä¹‰å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 #define T_DIR 1 // Directory #define T_FILE 2 // File #define T_DEVICE 3 // Device struct stat { int dev; // File system\u0026#39;s disk device uint ino; // Inode number short type; // Type of file short nlink; // Number of links to file uint64 size; // Size of file in bytes }; å®ç° æœ‰äº†ä¸Šé¢çš„é“ºå«ï¼Œå®¹æ˜“ç¼–å†™findä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 void find(char *path,char *filename){ // è¯¥å‡½æ•°åœ¨ path å†…æ‰¾ æ–‡ä»¶åä¸ºfilenameçš„æ–‡ä»¶ int fd; struct stat st; struct dirent de; char buff[512]; char *p; strcpy(buff,path); // è·¯å¾„å¤åˆ¶åˆ°buffé‡Œ p = buff + strlen(buff); *p ++ = \u0026#39;/\u0026#39;; // path ååŠ ä¸€ä¸ª / if((fd = open(path,0)) \u0026lt; 0){ // æ‰“å¼€pathè¿™ä¸ªç›®å½•æ–‡ä»¶ fprintf(2,\u0026#34;find: cannot open file:%s\\n\u0026#34;,path); return; } if(fstat(fd,\u0026amp;st) \u0026lt; 0){ // æ²¡èƒ½è·å–æ–‡ä»¶ä¿¡æ¯ fprintf(2,\u0026#34;find: cannot stat\\n\u0026#34;); close(fd); return; } if(st.type != T_DIR){ // path ä¸æ˜¯ç›®å½•æ–‡ä»¶ fprintf(2,\u0026#34;find: path:%s is not a directory\\n\u0026#34;,path); close(fd); return; } while(read(fd,\u0026amp;de,sizeof(de)) == sizeof(de)){ // éå†æ¯ä¸€ä¸ªç›®å½•é¡¹ // æ— æ•ˆçš„inode æˆ–è€…. å’Œ ..éƒ½ä¸ç»§ç»­æœç´¢ if(de.inum == 0 || strcmp(de.name,\u0026#34;.\u0026#34;) == 0 || strcmp(de.name,\u0026#34;..\u0026#34;) == 0) continue; strcpy(p,de.name); // path/filename stat(buff,\u0026amp;st); // è·å–æ–‡ä»¶ä¿¡æ¯ switch (st.type) { case T_FILE: // æ™®é€šæ–‡ä»¶ if(strcmp(de.name,filename) == 0) printf(\u0026#34;%s\\n\u0026#34;,buff); break; case T_DIR: // ç›®å½•æ–‡ä»¶åˆ™é€’å½’æœç´¢ find(buff,filename); // find recursively break; default: break; } } } ä¸»å‡½æ•°ç¼–å†™å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 int main(int argc,char *argv[]){ if(argc \u0026lt;= 2){ fprintf(2,\u0026#34;find: no enough argument\\n\u0026#34;); exit(-1); } find(argv[1],argv[2]); exit(0); } xargs è¯¥ä»»åŠ¡è¦æ±‚å®ç°ä¸€ä¸ªæç®€ç‰ˆçš„xargsï¼Œè²Œä¼¼ä¹Ÿæ²¡ä»€ä¹ˆå¥½è§£é‡Šçš„ï¼Œå°±æ˜¯ç†Ÿæ‚‰forkå’Œexecå³å¯ï¼Œç›´æ¥ç²˜ä»£ç å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; #include \u0026#34;kernel/fs.h\u0026#34; #include \u0026#34;kernel/param.h\u0026#34; #define EOF -1 int getchar(){ char ch; if(read(0,\u0026amp;ch,sizeof(ch)) \u0026lt;= 0) return EOF; return (int)ch; } int readline(char *buf){ int ch; while((ch = getchar()) != \u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; ch != EOF) *buf++ = ch; *buf = 0; if(ch == EOF) return EOF; return 1; } int main(int argc,char *argv[]){ char buf[512]; if(argc \u0026lt;= 1){ fprintf(2,\u0026#34;xarg: no enough arguments\\n\u0026#34;); exit(-1); } int p = 0,q; char *command = argv[1]; char *args[MAXARG]; args[p++] = command; for(int i = 2;i \u0026lt; argc;i++) args[p++] = argv[i]; // arguments from argv q = p; while(readline(buf) != EOF){ args[q] = malloc(strlen(buf)); strcpy(args[q++],buf); } args[q] = 0; int status; if(fork() == 0){ // child exec(command,args); }else{ // father wait(\u0026amp;status); } for(;p \u0026lt; q;p ++) free(args[p]); exit(0); } å°¾å£° è¯´å®è¯ä¸çŸ¥é“è¿™ä¸ªMIT 6.S081è¿˜èƒ½åšæŒå¤šä¹…ï¼Œèƒ½åšæŒä¸€ä¸ªlabå°±å¤šåšæŒä¸€ä¸ªå§â˜ºï¸\nä»£ç æ”¾åˆ° https://github.com/XieWeikai/xv6_lab çš„ lab1åˆ†æ”¯å•¦ï¼Œä½†ç›®å‰è¯¥ä»“åº“è¿˜æ˜¯privateçš„ï¼Œç­‰åˆ°è¿™ä¸ªè¯¾ç¨‹çœŸçš„å®Œæˆçš„å·®ä¸å¤šäº†å†å‡†å¤‡å…¬å¼€äº†å“ˆå“ˆå“ˆã€‚\n","date":"2023-01-05T16:44:26+08:00","image":"https://XieWeikai.github.io/aniya_blog/p/os_util_lab/saber2_hu583263cbbee05d2c263b501713a891d4_83776_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/os_util_lab/","title":"OS_util_lab"},{"content":"Xv6 ç¯å¢ƒé…ç½® å‡æœŸå¼€å§‹ï¼Œå…ˆè¯•ç€æŠŠxv6çš„å®éªŒç¯å¢ƒæ­å»ºèµ·æ¥ï¼Œä¹‹ååšä¸åšå®éªŒç­‰åˆ°ä»¥åå†è¯´\u0026hellip;\u0026hellip;\næ ¹æ®å®˜æ–¹çš„æŒ‡å¯¼æ•™ç¨‹ï¼Œåœ¨macOSä¸‹é…ç½®å®éªŒç¯å¢ƒéœ€è¦åšå¦‚ä¸‹å‡†å¤‡\nå®‰è£…git æ—©å°±å®‰è£…å¥½äº† å®‰è£…qemu å®‰è£…risc-vçš„å·¥å…·é“¾ å®‰è£…risc-vå·¥å…·é“¾ ä½¿ç”¨å¦‚ä¸‹å‘½ä»¤å®‰è£… (è§ https://github.com/riscv-software-src/homebrew-riscv)\n1 2 brew tap riscv-software-src/riscv brew install riscv-tools åœ¨å®é™…å®‰è£…æ—¶å‘ç°brewç»å¸¸ä¼šåœ¨æŸä¸ªåœ°æ–¹å¡ä½å®Œå…¨ä¸åŠ¨äº†(gitä¸‹è½½ä»“åº“æ—¶)ï¼Œä¸­æ–­åé‡è¯•å‡ æ¬¡éƒ½æ˜¯ä¸€æ ·ã€‚åæ¥åœ¨ç½‘ä¸Šå‘ç°åˆ«äººä¹Ÿç¢°åˆ°äº†ç±»ä¼¼çš„é—®é¢˜(è§ https://zhayujie.com/mit6828-env.html)ï¼ŒæŒ‰ç…§è¯¥åšä¸»çš„è¯´æ³•ï¼Œæˆ‘ä»¬åªéœ€è¦å®‰è£…riscv-gnu-toolchainå³å¯ã€‚ä½†ä¸‹è½½å¥½æºç ç¼–è¯‘æ—¶å‡ºç°äº†å„ç§warningï¼Œç”šè‡³è¿˜æœ‰error(ä½†è²Œä¼¼è¿˜æ˜¯å¯ä»¥ç¼–è¯‘å‡ºå¯æ‰§è¡Œæ–‡ä»¶çš„ï¼Œå¯èƒ½ä¼šå°‘ä¸€äº›ä¸œè¥¿)ï¼Œæ ¹æ®å®˜ç½‘çš„æè¿°(è§ https://github.com/riscv-collab/riscv-gnu-toolchain)ï¼Œåœ¨OS Xä¸Šç¼–è¯‘éœ€è¦ä¿è¯æ–‡ä»¶ç³»ç»Ÿæ˜¯å¤§å°å†™æ•æ„Ÿçš„ï¼Œä½†å¾ˆå¯æƒœmacOSä½¿ç”¨çš„æ–‡ä»¶ç³»ç»Ÿä¸æ˜¯å¤§å°å†™æ•æ„Ÿçš„\u0026hellip;\u0026hellip;\nè¦è§£å†³å¦‚ä¸Šé—®é¢˜å¯ä»¥åˆ›å»ºä¸€ä¸ªå¤§å°å†™æ•æ„Ÿçš„æ–‡ä»¶ç³»ç»Ÿé•œåƒå¹¶æŒ‚è½½åˆ°æœ¬åœ°çš„æŸä¸ªç›®å½•ä¸Šï¼Œæ–¹æ³•è§ https://github.com/spryker/spryker-docs/blob/master/docs/scos/dev/tutorials-and-howtos/howtos/howto-handle-case-sensitive-file-system-on-mac-os.md ï¼Œå°†æºç æ”¾åˆ°è¯¥ç›®å½•ä¸‹å†ç¼–è¯‘å³å¯ã€‚\næœ€åæ„Ÿè§‰å¤ªéº»çƒ¦äº†ï¼Œè¿˜æ˜¯å†³å®šè¯•ä¸€è¯•brewèƒ½å¦æˆåŠŸï¼Œæ‰§è¡Œå¦‚ä¸‹å‘½ä»¤\n1 2 brew tap riscv-software-src/riscv brew install riscv-tools æ‰§è¡Œå¼€å§‹åæœ¬äººå°±å»æ‘†çƒ‚äº†ï¼Œç»ˆäºåœ¨å…­ä¸ªå°æ—¶(å·¦å³)åï¼Œå®‰è£…æˆåŠŸå®Œæˆäº†\nè‡³æ­¤riscvå·¥å…·é“¾å®‰è£…å®Œæ¯•ã€‚\nå®‰è£…qemu ç†è®ºä¸Šæ¥è¯´éå¸¸ç®€å•ï¼Œä¸€æ¡å‘½ä»¤æå®š\n1 brew install qemu å®‰è£…å®Œæ¯•ï¼Œæå®šã€‚\nå°è¯•å¯åŠ¨xv6ï¼Œå¦‚ä¸‹\n1 2 3 4 cd path/to/lab git clone git://g.csail.mit.edu/xv6-labs-2020 git checkout util make qemu åœ¨macOSä¸‹ç¼–è¯‘æ—¶ç¼–è¯‘å™¨ä¼šæŠ¥å¦‚ä¸‹é”™è¯¯\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie -c -o user/sh.o user/sh.c user/sh.c: In function \u0026#39;runcmd\u0026#39;: user/sh.c:58:1: error: infinite recursion detected [-Werror=infinite-recursion] 58 | runcmd(struct cmd *cmd) | ^~~~~~ user/sh.c:89:5: note: recursive call 89 | runcmd(rcmd-\u0026gt;cmd); | ^~~~~~~~~~~~~~~~~ user/sh.c:109:7: note: recursive call 109 | runcmd(pcmd-\u0026gt;left); | ^~~~~~~~~~~~~~~~~~ user/sh.c:116:7: note: recursive call 116 | runcmd(pcmd-\u0026gt;right); | ^~~~~~~~~~~~~~~~~~~ user/sh.c:95:7: note: recursive call 95 | runcmd(lcmd-\u0026gt;left); | ^~~~~~~~~~~~~~~~~~ user/sh.c:97:5: note: recursive call 97 | runcmd(lcmd-\u0026gt;right); | ^~~~~~~~~~~~~~~~~~~ user/sh.c:127:7: note: recursive call 127 | runcmd(bcmd-\u0026gt;cmd); | ^~~~~~~~~~~~~~~~~ cc1: all warnings being treated as errors make: *** [\u0026lt;builtin\u0026gt;: user/sh.o] Error 1 å°†Makefileä¸­CFLAGSçš„-Werroré€‰é¡¹å»æ‰å³å¯ã€‚\nä½†ç¼–è¯‘å®Œæˆåæ‚²æƒ¨çš„å‘ç°ï¼Œå¯åŠ¨qemuåç¨‹åºå°±å¡ä½äº†ï¼Œæ²¡æœ‰ä»»ä½•äº¤äº’è¡Œä¸ºã€‚æ ¹æ®å®˜æ–¹æŒ‡å¯¼çš„æè¿°ï¼Œqemuç‰ˆæœ¬å¤ªæ–°å¯èƒ½ä¼šå‡ºç°è¿™ä¸ªé—®é¢˜ã€‚ç»è¿‡æŸ¥æ‰¾èµ„æ–™ï¼Œbrewè²Œä¼¼æ²¡æœ‰åŠæ³•å®‰è£…æ—§ç‰ˆæœ¬çš„qemuï¼Œåªå¥½åœ¨qemuå®˜ç½‘ä¸Šä¸‹è½½qemu 4.2åé€šè¿‡æºç æ¥å®‰è£…qemuäº†ï¼Œæ–¹æ³•å¦‚ä¸‹\n1 2 3 4 5 6 7 8 cd path/to/lab mkdir qemu-build # åœ¨è¯¥ç›®å½•ä¸‹ä¸‹è½½æºç å¹¶å®‰è£… cd qemu-build wget https://download.qemu.org/qemu-4.2.1.tar.xz # ä¸‹è½½æºç å‹ç¼©åŒ… tar xvJf qemu-4.2.1.tar.xz # è§£å‹ cd qemu-4.2.1 ./configure make # ç¼–è¯‘ éœ€è¦èŠ±è´¹å‡ ååˆ†é’Ÿæ¥å®Œæˆç¼–è¯‘ï¼Œç¼–è¯‘åriscv64-softmmuç›®å½•å†…çš„qemu-system-riscv64å³ä¸ºéœ€è¦çš„å¯æ‰§è¡Œæ–‡ä»¶ï¼Œåšä¸€ä¸ªè½¯è¿æ¥å¦‚ä¸‹\n1 2 cd riscv64-softmmu ln -s $(pwd)/qemu-system-riscv64 /usr/local/bin/qemu-system-riscv64 ä¹‹åé‡æ–°å°è¯•make qemuï¼Œå¯ä»¥æ­£å¸¸å¯åŠ¨xv6æ“ä½œç³»ç»Ÿã€‚\nåœ¨dockerä¸‹é…ç½®ç¯å¢ƒ åœ¨dockerä¸‹æ‹‰å–ubuntué•œåƒï¼Œä»¥è¯¥é•œåƒå¯åŠ¨å®¹å™¨\n1 2 3 4 docker run -it --name xv6 \\ -v ...:.../path/to/lab \\ # æŒ‚è½½æœ¬åœ°ç›®å½• -p ...:... \\ # ç«¯å£æ˜ å°„ ubuntu:latest æ¥ç€åœ¨è¯¥å®¹å™¨å†…å…ˆè£…äº›æœ€åŸºæœ¬çš„ä¸œè¥¿ c/c++çš„å·¥å…·é“¾(gcc/c++å’Œå„ç§åº“ã€åŒ…)ã€gitã€cmakeã€ç­‰å„ç§ä¸œè¥¿ã€‚\nå®‰è£…riscv-tools æ ¹æ®å®˜æ–¹æŒ‡å¯¼ï¼Œä½¿ç”¨å¦‚ä¸‹å‘½ä»¤å®‰è£…\n1 apt-get install gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu è¿™ä¸ªå®‰è£…é€Ÿåº¦æ¯”macä¸‹ç”¨brewæ‹‰å–æºç ç¼–è¯‘å¿«å¾—å¤šäº†ã€‚\né¡ºå¸¦å®‰è£…ä¸€äº›å¯èƒ½æ˜¯è°ƒè¯•å·¥å…·çš„åŒ…\n1 apt-get install gdb-multiarch å®‰è£…qemu æ ¹æ®å®˜æ–¹æŒ‡å¯¼ï¼Œä½¿ç”¨å¦‚ä¸‹å‘½ä»¤å®‰è£…\n1 apt-get install qemu-system-misc å¾ˆé—æ†¾ï¼Œç°åœ¨çš„qemuç»è¿‡ä¸¤å¹´çš„æ”¹è¿›ï¼Œå’ŒmacOSä¸Šä¸€æ ·ï¼Œæ–°ç‰ˆæœ¬çš„qemuå¯åŠ¨åå°±å¡æ­»ã€‚æŒ‰ç…§æŒ‡å¯¼ï¼Œä½¿ç”¨å¦‚ä¸‹å‘½ä»¤å¸è½½å¹¶å®‰è£…è€ç‰ˆæœ¬\n1 2 apt-get remove qemu-system-misc # å¸è½½ apt-get install qemu-system-misc=1:4.2-3ubuntu6 # å®‰è£…è€ç‰ˆæœ¬ ä½†ä»Šéæ˜”æ¯”äº†ï¼Œä¸Šè¿°å®‰è£…æ–¹æ³•ä¼šæç¤ºæ‰¾ä¸åˆ°è¯¥ç‰ˆæœ¬çš„qemuã€‚\næŒ‰ç…§æŒ‡å¯¼ï¼Œä¹Ÿå¯ä»¥è¿›è¡Œæºç å®‰è£…\n1 2 3 4 5 6 wget https://download.qemu.org/qemu-5.1.0.tar.xz # ä¸‹è½½æºç  qemu 5.1.0 tar xf qemu-5.1.0.tar.xz # è§£å‹ cd qemu-5.1.0 ./configure --disable-kvm --disable-werror --prefix=/usr/local --target-list=\u0026#34;riscv64-softmmu\u0026#34; make make install åœ¨ubuntuç¯å¢ƒä¸‹make qemuä¸ä¼šæŠ¥infinite recursionçš„é”™è¯¯ã€‚\nå°¾å£° åˆ°æ­¤xv6å°±å¯ä»¥æ­£å¸¸å¯åŠ¨äº†ï¼Œæœ‰å¯èƒ½ä»¥åè¿˜ä¼šç¢°åˆ°å…¶ä»–çš„é—®é¢˜ï¼Œç­‰åˆ°ä»¥åå†è¯´å§ã€‚\n","date":"2023-01-03T21:11:14+08:00","image":"https://XieWeikai.github.io/aniya_blog/p/xv6-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/wallpaper_hu0ff37ebbb98d2b42bafbb67ed8d5243a_153541_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/xv6-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","title":"xv6 ç¯å¢ƒé…ç½®"},{"content":"OS å¯’å‡å¼€å§‹äº†ï¼Œå¦‚æœæ¯å¤©çœ‹ä¸€ç‚¹å…³äºæ“ä½œç³»ç»Ÿçš„ä¸œè¥¿ï¼Œè¯´ä¸å®šå°±å¯ä»¥å®Œæˆ 25%çš„ä¸‹ä¸ªå­¦æœŸçš„æ“ä½œç³»ç»Ÿè¯¾ç¨‹è®¾è®¡å‘¢ï¼Ÿ\n","date":"2023-01-01T16:38:36+08:00","image":"https://XieWeikai.github.io/aniya_blog/p/os-flag/ostep-fun_hu25d333fcded103db2f52f7476cb1420a_52206_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/os-flag/","title":"OS flag"},{"content":"æ­£æ–‡æµ‹è¯• è€Œè¿™äº›å¹¶ä¸æ˜¯å®Œå…¨é‡è¦ï¼Œæ›´åŠ é‡è¦çš„é—®é¢˜æ˜¯ï¼Œ å¸¦ç€è¿™äº›é—®é¢˜ï¼Œæˆ‘ä»¬æ¥å®¡è§†ä¸€ä¸‹å­¦ç”Ÿä¼šé€€ä¼šã€‚ æ—¢ç„¶å¦‚ä½•ï¼Œ å¯¹æˆ‘ä¸ªäººè€Œè¨€ï¼Œå­¦ç”Ÿä¼šé€€ä¼šä¸ä»…ä»…æ˜¯ä¸€ä¸ªé‡å¤§çš„äº‹ä»¶ï¼Œè¿˜å¯èƒ½ä¼šæ”¹å˜æˆ‘çš„äººç”Ÿã€‚ æˆ‘ä»¬ä¸å¾—ä¸é¢å¯¹ä¸€ä¸ªéå¸¸å°´å°¬çš„äº‹å®ï¼Œé‚£å°±æ˜¯ï¼Œ å¯æ˜¯ï¼Œå³ä½¿æ˜¯è¿™æ ·ï¼Œå­¦ç”Ÿä¼šé€€ä¼šçš„å‡ºç°ä»ç„¶ä»£è¡¨äº†ä¸€å®šçš„æ„ä¹‰ã€‚ å­¦ç”Ÿä¼šé€€ä¼šï¼Œå‘ç”Ÿäº†ä¼šå¦‚ä½•ï¼Œä¸å‘ç”Ÿåˆä¼šå¦‚ä½•ã€‚ ç»è¿‡ä¸Šè¿°è®¨è®ºï¼Œ ç”Ÿæ´»ä¸­ï¼Œè‹¥å­¦ç”Ÿä¼šé€€ä¼šå‡ºç°äº†ï¼Œæˆ‘ä»¬å°±ä¸å¾—ä¸è€ƒè™‘å®ƒå‡ºç°äº†çš„äº‹å®ã€‚ å­¦ç”Ÿä¼šé€€ä¼šï¼Œåˆ°åº•åº”è¯¥å¦‚ä½•å®ç°ã€‚ è¿™æ ·çœ‹æ¥ï¼Œ åœ¨è¿™ç§å›°éš¾çš„æŠ‰æ‹©ä¸‹ï¼Œæœ¬äººæ€æ¥æƒ³å»ï¼Œå¯é£Ÿéš¾å®‰ã€‚ å¯¹æˆ‘ä¸ªäººè€Œè¨€ï¼Œå­¦ç”Ÿä¼šé€€ä¼šä¸ä»…ä»…æ˜¯ä¸€ä¸ªé‡å¤§çš„äº‹ä»¶ï¼Œè¿˜å¯èƒ½ä¼šæ”¹å˜æˆ‘çš„äººç”Ÿã€‚ å°±æˆ‘ä¸ªäººæ¥è¯´ï¼Œå­¦ç”Ÿä¼šé€€ä¼šå¯¹æˆ‘çš„æ„ä¹‰ï¼Œä¸èƒ½ä¸è¯´éå¸¸é‡å¤§ã€‚ èå£«æ¯”äºšæ›¾ç»æåˆ°è¿‡ï¼Œäººçš„ä¸€ç”Ÿæ˜¯çŸ­çš„ï¼Œä½†å¦‚æœå‘åŠ£åœ°è¿‡è¿™ä¸€ç”Ÿï¼Œå°±å¤ªé•¿äº†ã€‚è¿™ä¼¼ä¹è§£ç­”äº†æˆ‘çš„ç–‘æƒ‘ã€‚ è«æ‰ç‰¹è¯´è¿‡ä¸€å¥å¯Œæœ‰å“²ç†çš„è¯ï¼Œè°å’Œæˆ‘ä¸€æ ·ç”¨åŠŸï¼Œè°å°±ä¼šå’Œæˆ‘ä¸€æ ·æˆåŠŸã€‚è¿™å¯å‘äº†æˆ‘ï¼Œ å¯¹æˆ‘ä¸ªäººè€Œè¨€ï¼Œå­¦ç”Ÿä¼šé€€ä¼šä¸ä»…ä»…æ˜¯ä¸€ä¸ªé‡å¤§çš„äº‹ä»¶ï¼Œè¿˜å¯èƒ½ä¼šæ”¹å˜æˆ‘çš„äººç”Ÿã€‚ å­¦ç”Ÿä¼šé€€ä¼šï¼Œåˆ°åº•åº”è¯¥å¦‚ä½•å®ç°ã€‚ ä¸€èˆ¬æ¥è¯´ï¼Œ ä»è¿™ä¸ªè§’åº¦æ¥çœ‹ï¼Œ è¿™ç§äº‹å®å¯¹æœ¬äººæ¥è¯´æ„ä¹‰é‡å¤§ï¼Œç›¸ä¿¡å¯¹è¿™ä¸ªä¸–ç•Œä¹Ÿæ˜¯æœ‰ä¸€å®šæ„ä¹‰çš„ã€‚ åœ¨è¿™ç§å›°éš¾çš„æŠ‰æ‹©ä¸‹ï¼Œæœ¬äººæ€æ¥æƒ³å»ï¼Œå¯é£Ÿéš¾å®‰ã€‚ äº†è§£æ¸…æ¥šå­¦ç”Ÿä¼šé€€ä¼šåˆ°åº•æ˜¯ä¸€ç§æ€ä¹ˆæ ·çš„å­˜åœ¨ï¼Œæ˜¯è§£å†³ä¸€åˆ‡é—®é¢˜çš„å…³é”®ã€‚ ä¸€èˆ¬æ¥è¯´ï¼Œ ç”Ÿæ´»ä¸­ï¼Œè‹¥å­¦ç”Ÿä¼šé€€ä¼šå‡ºç°äº†ï¼Œæˆ‘ä»¬å°±ä¸å¾—ä¸è€ƒè™‘å®ƒå‡ºç°äº†çš„äº‹å®ã€‚ é—®é¢˜çš„å…³é”®ç©¶ç«Ÿä¸ºä½•ï¼Ÿ è€Œè¿™äº›å¹¶ä¸æ˜¯å®Œå…¨é‡è¦ï¼Œæ›´åŠ é‡è¦çš„é—®é¢˜æ˜¯ã€‚\nå¥¥æ–¯ç‰¹æ´›å¤«æ–¯åŸºæ›¾ç»è¯´è¿‡ï¼Œå…±åŒçš„äº‹ä¸šï¼Œå…±åŒçš„æ–—äº‰ï¼Œå¯ä»¥ä½¿äººä»¬äº§ç”Ÿå¿å—ä¸€åˆ‡çš„åŠ›é‡ã€‚ã€€å¸¦ç€è¿™å¥è¯ï¼Œæˆ‘ä»¬è¿˜è¦æ›´åŠ æ…é‡çš„å®¡è§†è¿™ä¸ªé—®é¢˜ï¼š ä¸€èˆ¬æ¥è®²ï¼Œæˆ‘ä»¬éƒ½å¿…é¡»åŠ¡å¿…æ…é‡çš„è€ƒè™‘è€ƒè™‘ã€‚ æ—¢ç„¶å¦‚æ­¤ï¼Œ è¿™ç§äº‹å®å¯¹æœ¬äººæ¥è¯´æ„ä¹‰é‡å¤§ï¼Œç›¸ä¿¡å¯¹è¿™ä¸ªä¸–ç•Œä¹Ÿæ˜¯æœ‰ä¸€å®šæ„ä¹‰çš„ã€‚ å¸¦ç€è¿™äº›é—®é¢˜ï¼Œæˆ‘ä»¬æ¥å®¡è§†ä¸€ä¸‹å­¦ç”Ÿä¼šé€€ä¼šã€‚ æˆ‘è®¤ä¸ºï¼Œ æˆ‘è®¤ä¸ºï¼Œ åœ¨è¿™ç§å›°éš¾çš„æŠ‰æ‹©ä¸‹ï¼Œæœ¬äººæ€æ¥æƒ³å»ï¼Œå¯é£Ÿéš¾å®‰ã€‚ é—®é¢˜çš„å…³é”®ç©¶ç«Ÿä¸ºä½•ï¼Ÿ æ¯ä¸ªäººéƒ½ä¸å¾—ä¸é¢å¯¹è¿™äº›é—®é¢˜ã€‚ åœ¨é¢å¯¹è¿™ç§é—®é¢˜æ—¶ï¼Œ è¦æƒ³æ¸…æ¥šï¼Œå­¦ç”Ÿä¼šé€€ä¼šï¼Œåˆ°åº•æ˜¯ä¸€ç§æ€ä¹ˆæ ·çš„å­˜åœ¨ã€‚ æˆ‘è®¤ä¸ºï¼Œ æ—¢ç„¶å¦‚æ­¤ï¼Œ æ¯ä¸ªäººéƒ½ä¸å¾—ä¸é¢å¯¹è¿™äº›é—®é¢˜ã€‚ åœ¨é¢å¯¹è¿™ç§é—®é¢˜æ—¶ï¼Œ é‚£ä¹ˆï¼Œ æˆ‘è®¤ä¸ºï¼Œ å­¦ç”Ÿä¼šé€€ä¼šå› ä½•è€Œå‘ç”Ÿã€‚\nå¼•ç”¨ æ€å¿µæ˜¯æœ€æš–çš„å¿§ä¼¤åƒä¸€åŒç¿…è†€\nè®©æˆ‘åœä¸äº†é£ä¸è¿œåœ¨è¿‡å¾€æ¸¸è¡\nä¸å‘Šè€Œåˆ«çš„ä½  å°±ç®—ä¸ºäº†æˆ‘ç€æƒ³\nè¿™ä¹ˆæ²‰ç—›çš„å‘µæŠ¤ æˆ‘æ€ä¹ˆèƒ½ç¿±ç¿”\næœ€æš–çš„æ†‚å‚· - ç”°é¦¥ç”„\nå›¾ç‰‡ 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) ç›¸å†Œè¯­æ³•æ¥è‡ª Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://XieWeikai.github.io/aniya_blog/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;â€”\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating. â€” Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements â€” abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://XieWeikai.github.io/aniya_blog/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nYouTube Privacy Enhanced Shortcode Twitter Simple Shortcode Vimeo Simple Shortcode bilibilibi Shortcode Gist Shortcode Gitlab Snippets Shortcode Quote Shortcode Stack adds a quote shortcode. For example:\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\nâ€• A famous person, The book they wrote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\nâ€• Anonymous book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\nâ€• Some book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\nâ€• Somebody","date":"2019-03-10T00:00:00Z","permalink":"https://XieWeikai.github.io/aniya_blog/p/rich-content/","title":"Rich Content"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://XieWeikai.github.io/aniya_blog/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\ninline math is like this $a^2+b^2=c^2$\n","date":"2019-03-08T00:00:00Z","permalink":"https://XieWeikai.github.io/aniya_blog/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://XieWeikai.github.io/aniya_blog/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/emoji-support/","title":"Emoji Support"}]