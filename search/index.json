[{"content":"OS lab syscall 时隔一天，居然又象征性的完成了一个实验😋\n本次实验需要在xv6系统内额外添加两个系统调用，分别是trace和sysinfo，trace用于跟踪某个进程使用系统调用的情况，sysinfo用于查看系统内空闲内存和进程个数。\n实验的官方指导见 https://pdos.csail.mit.edu/6.828/2020/labs/syscall.html 。\n准备 官方指导中的前置要求是\nBefore you start coding, read Chapter 2 of the xv6 book, and Sections 4.3 and 4.4 of Chapter 4, and related source files:\nThe user-space code for systems calls is in user/user.h and user/usys.pl. The kernel-space code is kernel/syscall.h, kernel/syscall.c. The process-related code is kernel/proc.h and kernel/proc.c. 指导书中的Chapter 2描述了操作系统的组织结构，内容大概是简单讲了一下操作系统的功能作用、操作系统为什么重要、有哪些组织操作系统各个部分的方法等等。\n在Chapter 2的最后大概讲了讲xv6的启动过程。\n启动流程概述 qemu模拟的机器启动时首先执行ROM中的程序，这个程序的作用应该就是将启动区的一部分代码载入内存并转交CPU使用权到载入的代码，xv6最初的代码见kernel/entry.S:6\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # qemu -kernel loads the kernel at 0x80000000 # and causes each CPU to jump there. # kernel.ld causes the following code to # be placed at 0x80000000. .section .text _entry: # set up a stack for C. # stack0 is declared in start.c, # with a 4096-byte stack per CPU. # sp = stack0 + (hartid * 4096) la sp, stack0 li a0, 1024*4 csrr a1, mhartid addi a1, a1, 1 mul a0, a0, a1 add sp, sp, a0 # jump to start() in start.c call start spin: j spin 上面的汇编代码设置好栈顶寄存器后将跳转到 kernel/start.c中的start函数，注意在机器刚启动时处在machine mode，该模式下拥有所有的权限。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // entry.S jumps here in machine mode on stack0. void start() { // set M Previous Privilege mode to Supervisor, for mret. unsigned long x = r_mstatus(); x \u0026amp;= ~MSTATUS_MPP_MASK; x |= MSTATUS_MPP_S; w_mstatus(x); // set M Exception Program Counter to main, for mret. // requires gcc -mcmodel=medany w_mepc((uint64)main); // disable paging for now. w_satp(0); // delegate all interrupts and exceptions to supervisor mode. w_medeleg(0xffff); w_mideleg(0xffff); w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE); // ask for clock interrupts. timerinit(); // keep each CPU\u0026#39;s hartid in its tp register, for cpuid(). int id = r_mhartid(); w_tp(id); // switch to supervisor mode and jump to main(). asm volatile(\u0026#34;mret\u0026#34;); } 上面的代码对机器进行了一些设置，没了解过riscv的处理器，随着实验的深入应该也许会了解更多吧，上面代码的最后一句，使用汇编mret，这一般用于supervisor mode调用machine mode的代码后从machine mode返回supervisor mode，在这个代码里通过mret进入supervisor mode，也就是操作系统内核运行的模式，在start函数前面一些代码已经将返回地址设为了main，故mret会转到main函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // start() jumps here in supervisor mode on all CPUs. void main() { if(cpuid() == 0){ consoleinit(); printfinit(); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;xv6 kernel is booting\\n\u0026#34;); printf(\u0026#34;\\n\u0026#34;); kinit(); // physical page allocator kvminit(); // create kernel page table kvminithart(); // turn on paging procinit(); // process table trapinit(); // trap vectors trapinithart(); // install kernel trap vector plicinit(); // set up interrupt controller plicinithart(); // ask PLIC for device interrupts binit(); // buffer cache iinit(); // inode cache fileinit(); // file table virtio_disk_init(); // emulated hard disk userinit(); // first user process __sync_synchronize(); started = 1; } else { while(started == 0) ; __sync_synchronize(); printf(\u0026#34;hart %d starting\\n\u0026#34;, cpuid()); kvminithart(); // turn on paging trapinithart(); // install kernel trap vector plicinithart(); // ask PLIC for device interrupts } scheduler(); } main函数内进行了一堆初始化操作，最后调用了userinit()函数启动第一个用户进程，该函数代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Set up first user process. void userinit(void) { struct proc *p; p = allocproc(); initproc = p; // allocate one user page and copy init\u0026#39;s instructions // and data into it. uvminit(p-\u0026gt;pagetable, initcode, sizeof(initcode)); p-\u0026gt;sz = PGSIZE; // prepare for the very first \u0026#34;return\u0026#34; from kernel to user. p-\u0026gt;trapframe-\u0026gt;epc = 0; // user program counter p-\u0026gt;trapframe-\u0026gt;sp = PGSIZE; // user stack pointer safestrcpy(p-\u0026gt;name, \u0026#34;initcode\u0026#34;, sizeof(p-\u0026gt;name)); p-\u0026gt;cwd = namei(\u0026#34;/\u0026#34;); p-\u0026gt;state = RUNNABLE; release(\u0026amp;p-\u0026gt;lock); } 上面的代码在对进程一些必要的东西初始化后启动了initcode这一个用户进程，该进程是用汇编写的，代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026#34;syscall.h\u0026#34; # exec(init, argv) .globl start start: la a0, init la a1, argv li a7, SYS_exec ecall # for(;;) exit(); exit: li a7, SYS_exit ecall jal exit # char init[] = \u0026#34;/init\\0\u0026#34;; init: .string \u0026#34;/init\\0\u0026#34; # char *argv[] = { init, 0 }; .p2align 2 argv: .long init .long 0 上面的代码相当于执行了c程序\n1 2 3 4 5 6 7 8 void start(){ char *init = \u0026#34;/init\u0026#34;; char *argv[] = {init,0}; exec(init,argv); for(;;) exit(); } 这个/init程序见源码user/init.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // init: The initial user-level program #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;kernel/spinlock.h\u0026#34; #include \u0026#34;kernel/sleeplock.h\u0026#34; #include \u0026#34;kernel/fs.h\u0026#34; #include \u0026#34;kernel/file.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; #include \u0026#34;kernel/fcntl.h\u0026#34; char *argv[] = { \u0026#34;sh\u0026#34;, 0 }; int main(void) { int pid, wpid; if(open(\u0026#34;console\u0026#34;, O_RDWR) \u0026lt; 0){ mknod(\u0026#34;console\u0026#34;, CONSOLE, 0); open(\u0026#34;console\u0026#34;, O_RDWR); } dup(0); // stdout dup(0); // stderr for(;;){ printf(\u0026#34;init: starting sh\\n\u0026#34;); pid = fork(); if(pid \u0026lt; 0){ printf(\u0026#34;init: fork failed\\n\u0026#34;); exit(1); } if(pid == 0){ exec(\u0026#34;sh\u0026#34;, argv); printf(\u0026#34;init: exec sh failed\\n\u0026#34;); exit(1); } for(;;){ // this call to wait() returns if the shell exits, // or if a parentless process exits. wpid = wait((int *) 0); if(wpid == pid){ // the shell exited; restart it. break; } else if(wpid \u0026lt; 0){ printf(\u0026#34;init: wait returned an error\\n\u0026#34;); exit(1); } else { // it was a parentless process; do nothing. } } } } 引用指导书的话，init程序干的事为\nInit (user/init.c:15) creates a new console device fifile if needed and then opens it as fifile descriptors 0, 1, and 2. Then it starts a shell on the console. The system is up.\nxv6大致的启动流程到此结束，其实还是比较模糊的，细节应该会在后面的实验逐渐展开 \u0026hellip; 吧🤣\n系统调用 在实验指导网站中还提到要看指导书的4.3和4.4节，这两节象征性的讲了下系统调用相关的代码，细节不表，大概流程在本节粗略的解释一下。\n首先在上一节中其实看到了汇编如何调用exec系统调用的，如下\n1 2 3 4 la a0, init la a1, argv li a7, SYS_exec ecall riscv内有a0-a7这几个寄存器（按照惯例）用于传递参数(a就是arg)，exec需要两个参数，这两个参数分别存入a0,a1中，a7用于存放系统调用号。ecall指令会陷入内核(具体哪里以后应该会知道的)，陷入内核后依次执行uservec、usertrap然后是syscall，最后这个syscall函数真正调用了系统调用。该函数见kernel/syscall.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void syscall(void) { int num; struct proc *p = myproc(); num = p-\u0026gt;trapframe-\u0026gt;a7; if(num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt; NELEM(syscalls) \u0026amp;\u0026amp; syscalls[num]) { p-\u0026gt;trapframe-\u0026gt;a0 = syscalls[num](); } else { printf(\u0026#34;%d %s: unknown sys call %d\\n\u0026#34;, p-\u0026gt;pid, p-\u0026gt;name, num); p-\u0026gt;trapframe-\u0026gt;a0 = -1; } } 先注意上面的myproc，该函数返回一个进程(使用系统调用的进程)相关的结构体(应该就是理论学习中的PCB了吧)，该结构体定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Per-process state struct proc { struct spinlock lock; // p-\u0026gt;lock must be held when using these: enum procstate state; // Process state struct proc *parent; // Parent process void *chan; // If non-zero, sleeping on chan int killed; // If non-zero, have been killed int xstate; // Exit status to be returned to parent\u0026#39;s wait int pid; // Process ID // these are private to the process, so p-\u0026gt;lock need not be held. uint64 kstack; // Virtual address of kernel stack uint64 sz; // Size of process memory (bytes) pagetable_t pagetable; // User page table struct trapframe *trapframe; // data page for trampoline.S struct context context; // swtch() here to run process struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory char name[16]; // Process name (debugging) }; 上面结构中的trapframe存着该进程的寄存器状态和其他一些信息，在回过头来看syscall中的如下代码\n1 2 3 4 5 6 7 int num; struct proc *p = myproc(); num = p-\u0026gt;trapframe-\u0026gt;a7; // a7存的是调用号，如前面汇编语言调用系统调用所示 if(num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt; NELEM(syscalls) \u0026amp;\u0026amp; syscalls[num]) { // 调用号满足一定条件才能调用系统调用 p-\u0026gt;trapframe-\u0026gt;a0 = syscalls[num](); } 解释见注释，再来看看syscalls这个变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 static uint64 (*syscalls[])(void) = { [SYS_fork] sys_fork, [SYS_exit] sys_exit, [SYS_wait] sys_wait, [SYS_pipe] sys_pipe, [SYS_read] sys_read, [SYS_kill] sys_kill, [SYS_exec] sys_exec, [SYS_fstat] sys_fstat, [SYS_chdir] sys_chdir, [SYS_dup] sys_dup, [SYS_getpid] sys_getpid, [SYS_sbrk] sys_sbrk, [SYS_sleep] sys_sleep, [SYS_uptime] sys_uptime, [SYS_open] sys_open, [SYS_write] sys_write, [SYS_mknod] sys_mknod, [SYS_unlink] sys_unlink, [SYS_link] sys_link, [SYS_mkdir] sys_mkdir, [SYS_close] sys_close, }; 这是一个指向函数的指针的数组，指向的函数形如uint64 func_name(void )，这一段代码给该数组进行初始化，其中sys_fork，sys_exit之类的为具体的函数(函数就是一堆指令，函数名其实就是这一堆指令的首地址)，SYS_fork之类的表明数组下标，这些宏定义在syscall.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // System call numbers #define SYS_fork 1 #define SYS_exit 2 #define SYS_wait 3 #define SYS_pipe 4 #define SYS_read 5 #define SYS_kill 6 #define SYS_exec 7 #define SYS_fstat 8 #define SYS_chdir 9 #define SYS_dup 10 #define SYS_getpid 11 #define SYS_sbrk 12 #define SYS_sleep 13 #define SYS_uptime 14 #define SYS_open 15 #define SYS_write 16 #define SYS_mknod 17 #define SYS_unlink 18 #define SYS_link 19 #define SYS_mkdir 20 #define SYS_close 21 获取参数 上面看到了系统调用的过程，syscall实际上是根据a7中的调用号来选择某个具体的实现系统调用的函数来完成系统调用的。上一小节看到，syscall调用的函数原型为uint64 func_name(void)，那这些函数如何拿到用户传递的参数呢？\n实际上通过陷入系统调用的代码就可以看出来了\n1 2 3 4 5 # 调用 exec(init,argv) la a0, init la a1, argv li a7, SYS_exec ecall 参数存在了该进程的a0-a5寄存器中，而通过前文可以看到，可以通过myproc拿到用户进程的PCB，也就是一个struct proc *，该结构内的trapframe内有用户进程的寄存器状态，比如exec要拿到第一个参数，只需要拿到a0即可，如下\n1 2 3 struct proc *p = myproc(); p-\u0026gt;trapframe-\u0026gt;a0 // 这个值就是第一个参数 在kernel/syscall.c中已经给我们封装好了相关的函数，如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 static uint64 argraw(int n) { struct proc *p = myproc(); switch (n) { case 0: return p-\u0026gt;trapframe-\u0026gt;a0; case 1: return p-\u0026gt;trapframe-\u0026gt;a1; case 2: return p-\u0026gt;trapframe-\u0026gt;a2; case 3: return p-\u0026gt;trapframe-\u0026gt;a3; case 4: return p-\u0026gt;trapframe-\u0026gt;a4; case 5: return p-\u0026gt;trapframe-\u0026gt;a5; } panic(\u0026#34;argraw\u0026#34;); return -1; } 可以看到，调用 argraw(n)可以拿到第n个参数，也就是an寄存器的值，在该文件中还进一步封装了另外几个函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Fetch the nth 32-bit system call argument. int argint(int n, int *ip) // 获取整数类型的参数 { *ip = argraw(n); return 0; } // Retrieve an argument as a pointer. // Doesn\u0026#39;t check for legality, since // copyin/copyout will do that. int argaddr(int n, uint64 *ip) // 获取地址(指针类型的参数) { *ip = argraw(n); return 0; } // Fetch the nth word-sized system call argument as a null-terminated string. // Copies into buf, at most max. // Returns string length if OK (including nul), -1 if error. int argstr(int n, char *buf, int max) // 获取字符串类型的参数 { uint64 addr; if(argaddr(n, \u0026amp;addr) \u0026lt; 0) return -1; // fetchstr 从用户态的地址处将字符串取出复制到内核态中的buf内 内核态和用户态 // 的地址空间不一样(页表不同) return fetchstr(addr, buf, max); } 具体功能见注释。\n用户态stub 作为用户，如果希望进行系统调用，肯定不希望写汇编来调用，那么在用户态下需要封装一层函数来陷入内核进行系统调用，如用户希望调用文件相关的系统调用只需按照下面的代码书写\n1 2 3 fd = open(\u0026#34;hello.txt\u0026#34;,O_CREAT|O_WRONLY); write(fd,\u0026#34;Hello,xv6!\u0026#34;,10); 那么上面这些open、write的代码究竟在哪里呢？这些代码详见user/usys.S，截取这两个函数代码如下\n1 2 3 4 5 6 7 8 9 10 11 .global open open: li a7, SYS_open ecall ret .global write write: li a7, SYS_write ecall ret 在用户态编写代码func(a,b,c)时，其实就是将a,b,c的值装入a0,a1,a2寄存器，然后将下一跳指令地址保存在ra寄存器，然后跳转到func地址处执行，上面的open和write函数只需要向a7寄存器装入调用号，再用ecall就可以陷入内核进行系统调用了。\n可以看见这些代码都非常的一致，自己手写显得太傻了，故xv6源码中用usys.pl这个perl脚本自动生成usys.S，该脚本如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/usr/bin/perl -w # Generate usys.S, the stubs for syscalls. print \u0026#34;# generated by usys.pl - do not edit\\n\u0026#34;; print \u0026#34;#include \\\u0026#34;kernel/syscall.h\\\u0026#34;\\n\u0026#34;; sub entry { my $name = shift; print \u0026#34;.global $name\\n\u0026#34;; print \u0026#34;${name}:\\n\u0026#34;; print \u0026#34; li a7, SYS_${name}\\n\u0026#34;; print \u0026#34; ecall\\n\u0026#34;; print \u0026#34; ret\\n\u0026#34;; } entry(\u0026#34;fork\u0026#34;); entry(\u0026#34;exit\u0026#34;); ... # 每一个系统调用写一个entry(\u0026#34;syscall_name\u0026#34;)即可 到这里就基本知道系统调用是怎么回事了，虽然具体细节不太清楚，但知道个大概流程就可以开始做本次实验了。\n用户态和内核态数据传输 由于用户态和内核态地址空间不一样，故不能简单的通过地址来传入或传出数据，来看看fstat系统调用如何传出struct stat结构体到用户态，看其源码如下\n1 2 3 4 5 6 7 8 9 10 11 uint64 sys_fstat(void) { struct file *f; uint64 st; // user pointer to struct stat if(argfd(0, 0, \u0026amp;f) \u0026lt; 0 || argaddr(1, \u0026amp;st) \u0026lt; 0) // 这里调用argaddr(1,\u0026amp;st)后，st即存着用户传入的struct stat*指针的值 return -1; return filestat(f, st); } 再看看filestat的实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Get metadata about file f. // addr is a user virtual address, pointing to a struct stat. int filestat(struct file *f, uint64 addr) { struct proc *p = myproc(); struct stat st; if(f-\u0026gt;type == FD_INODE || f-\u0026gt;type == FD_DEVICE){ ilock(f-\u0026gt;ip); stati(f-\u0026gt;ip, \u0026amp;st); iunlock(f-\u0026gt;ip); if(copyout(p-\u0026gt;pagetable, addr, (char *)\u0026amp;st, sizeof(st)) \u0026lt; 0) // 注意这里将内核态的结构复制到用户态的地址处 return -1; return 0; } return -1; } 可以看到需要通过copyout函数来将内核地址空间的数据复制到用户的地址空间，其中第一个参数是用户进程的页表。\n实验 trace 看看实验要做什么\nIn this assignment you will add a system call tracing feature that may help you when debugging later labs. You\u0026rsquo;ll create a new trace system call that will control tracing. It should take one argument, an integer \u0026ldquo;mask\u0026rdquo;, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls trace(1 \u0026lt;\u0026lt; SYS_fork), where SYS_fork is a syscall number from kernel/syscall.h. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call\u0026rsquo;s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don\u0026rsquo;t need to print the system call arguments. The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.\n实验应该达到的效果\n1 2 3 4 5 $ trace 32 grep hello README # 32 就是 1 \u0026lt;\u0026lt; SYS_read 3: syscall read -\u0026gt; 1023 3: syscall read -\u0026gt; 966 3: syscall read -\u0026gt; 70 3: syscall read -\u0026gt; 0 有了前文的基础，这个实验其实很简单，首先要找个地方记录某个进程要trace的系统调用，显然在PCB即struct proc中记录这个mask比较好，在该结构中添加一个mask字段如下\n1 2 3 4 5 6 // Per-process state struct proc { ... // for syscall trace int trace_mask; // save the trace mask for a process }; 那么添加的系统调用功能就是设置进程的trace_mask，在sysproc.c中添加如下系统调用函数如下\n1 2 3 4 5 6 7 8 9 uint64 sys_trace(void) { struct proc *p = myproc(); int mask; argint(0,\u0026amp;mask); // get the mask argment p-\u0026gt;trace_mask = mask; // save the trace mask return 0; } 在syscall.h中添加系统调用号，如下\n1 2 3 4 5 // System call numbers ... // added system call #define SYS_trace 22 接着修改syscall.c中的系统调用表，添加一条如下\n1 2 3 4 5 6 7 8 // added system call extern uint64 sys_trace(void); // declaration static uint64 (*syscalls[])(void) = { ... // added syscall [SYS_trace] sys_trace, // 添加一条系统调用 }; 为了在调用系统调用时输出相关信息，仔细想想，每一个系统调用都要经过syscall，那么可以修改syscall，在系统调用后输出trace的信息，修改该函数如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 记录系统调用名字 static char *syscalls_names[] = { \u0026#34;none\u0026#34;,\u0026#34;fork\u0026#34;,\u0026#34;exit\u0026#34;,\u0026#34;wait\u0026#34;,\u0026#34;pipe\u0026#34;,\u0026#34;read\u0026#34;,\u0026#34;kill\u0026#34;,\u0026#34;exec\u0026#34;,\u0026#34;fstat\u0026#34;,\u0026#34;chdir\u0026#34;,\u0026#34;dup\u0026#34;,\u0026#34;getpid\u0026#34;,\u0026#34;sbrk\u0026#34;, \u0026#34;sleep\u0026#34;,\u0026#34;uptime\u0026#34;,\u0026#34;open\u0026#34;,\u0026#34;write\u0026#34;,\u0026#34;mknod\u0026#34;,\u0026#34;unlink\u0026#34;,\u0026#34;link\u0026#34;,\u0026#34;mkdir\u0026#34;,\u0026#34;close\u0026#34;,\u0026#34;trace\u0026#34;,\u0026#34;sysinfo\u0026#34; }; void syscall(void) { int num; struct proc *p = myproc(); num = p-\u0026gt;trapframe-\u0026gt;a7; if(num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt; NELEM(syscalls) \u0026amp;\u0026amp; syscalls[num]) { p-\u0026gt;trapframe-\u0026gt;a0 = syscalls[num](); // a0 中存着返回值 if((p-\u0026gt;trace_mask \u0026amp; (1 \u0026lt;\u0026lt; num)) != 0){ // it is a traced system call // 如果该系统调用的mask设置过了，则输出信息 printf(\u0026#34;%d: syscall %s -\u0026gt; %d\\n\u0026#34;,p-\u0026gt;pid,syscalls_names[num],p-\u0026gt;trapframe-\u0026gt;a0); } } else { printf(\u0026#34;%d %s: unknown sys call %d\\n\u0026#34;, p-\u0026gt;pid, p-\u0026gt;name, num); p-\u0026gt;trapframe-\u0026gt;a0 = -1; } } 注意按照任务要求，如果一个进程trace某些系统调用，那么该进行fork出来的子进程也要trace这些系统调用，fork系统调用代码如下\n1 2 3 4 5 uint64 sys_fork(void) { return fork(); } 查看这个fork函数代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // Create a new process, copying the parent. // Sets up child kernel stack to return as if from fork() system call. int fork(void) { int i, pid; struct proc *np; struct proc *p = myproc(); // Allocate process. if((np = allocproc()) == 0){ return -1; } // Copy user memory from parent to child. if(uvmcopy(p-\u0026gt;pagetable, np-\u0026gt;pagetable, p-\u0026gt;sz) \u0026lt; 0){ freeproc(np); release(\u0026amp;np-\u0026gt;lock); return -1; } np-\u0026gt;sz = p-\u0026gt;sz; np-\u0026gt;parent = p; // copy saved user registers. *(np-\u0026gt;trapframe) = *(p-\u0026gt;trapframe); // Cause fork to return 0 in the child. np-\u0026gt;trapframe-\u0026gt;a0 = 0; // increment reference counts on open file descriptors. for(i = 0; i \u0026lt; NOFILE; i++) if(p-\u0026gt;ofile[i]) np-\u0026gt;ofile[i] = filedup(p-\u0026gt;ofile[i]); np-\u0026gt;cwd = idup(p-\u0026gt;cwd); safestrcpy(np-\u0026gt;name, p-\u0026gt;name, sizeof(p-\u0026gt;name)); pid = np-\u0026gt;pid; np-\u0026gt;state = RUNNABLE; release(\u0026amp;np-\u0026gt;lock); return pid; } 具体细节不谈，但从上面的代码可以看出，p是当前进程PCB，np是fork出来的，新的进程的PCB，该函数就是在执行复制进程的工作。为了让子进程可以trace和父进程同样的系统调用，需要将父进程的trace_mask也复制一下，添加一行代码如下\n1 2 3 4 5 6 7 8 9 10 11 // Create a new process, copying the parent. // Sets up child kernel stack to return as if from fork() system call. int fork(void) { ... // copy trace mask np-\u0026gt;trace_mask = p-\u0026gt;trace_mask; ... return pid; } 至此完成了添加函数调用的任务，接下来还需要给用户增加接口，故在usys.pl中末尾添加代码如下(作用见 用户态stub 那一小节)\n1 2 3 ... # added system call entry(\u0026#34;trace\u0026#34;); 在头文件user/user.h中添加该系统调用原型如下\n1 2 // added system call int trace(int mask); 一切完成后测试能否通过测试，如下\nsysinfo 第二个添加的系统调用根据实验指导书描述如下\nIn this assignment you will add a system call, sysinfo, that collects information about the running system. The system call takes one argument: a pointer to a struct sysinfo (see kernel/sysinfo.h). The kernel should fill out the fields of this struct: the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED. We provide a test program sysinfotest; you pass this assignment if it prints \u0026ldquo;sysinfotest: OK\u0026rdquo;.\n可以看到，sysinfo系统调用要求给用户返回如下结构\n1 2 3 4 struct sysinfo { uint64 freemem; // amount of free memory (bytes) uint64 nproc; // number of process }; 指导书上比较关键的几句提示如下\nsysinfo needs to copy a struct sysinfo back to user space; see sys_fstat() (kernel/sysfile.c) and filestat() (kernel/file.c) for examples of how to do that using copyout(). To collect the amount of free memory, add a function to kernel/kalloc.c To collect the number of processes, add a function to kernel/proc.c 其中第一点在前文中有所描述。\n但非常羞愧的是，第二第三点，道理我都懂，可是关于xv6我还一无所知，我怎么知道怎么获取系统进程数和空闲内存呀😅，也没有一点提示，还没看到xv6的内存管理和进程调度呢🤡\n无奈稍微在网上查了一下🙃，编写获取空闲内存的代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // kalloc.c struct run { struct run *next; }; struct { struct spinlock lock; struct run *freelist; } kmem; // return number of free bytes uint64 free_bytes(){ struct run *p = kmem.freelist; uint64 num_of_free_page = 0; while(p){ num_of_free_page ++; p = p-\u0026gt;next; } return num_of_free_page * PGSIZE; } 上面代码中的kmem用于管理内存，该结构内有一个lock和freelist，顾名思义freelist应该就是串起空闲页的结构(灰常奇怪，这个链表节点struct run为毛只有一个指针\u0026hellip;)，但总之先这样吧，后面做内存管理时会知道怎么回事的🤣\n上面代码的free_bytes即获取空闲内存字节数的函数。\n接下来再看看怎么获取系统进程数目，代码如下\n1 2 3 4 5 6 7 8 9 10 11 struct proc proc[NPROC]; // get the number of process uint64 num_proc(){ uint64 sum = 0; for(int i = 0;i \u0026lt; NPROC;i ++) if(proc[i].state != UNUSED) sum ++; return sum; } 上面代码中的proc结构体就是存所有进程的状态的，struct proc这个结构体在前文也看到过，再次展示如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 enum procstate { UNUSED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE }; // Per-process state struct proc { struct spinlock lock; // p-\u0026gt;lock must be held when using these: enum procstate state; // Process state struct proc *parent; // Parent process void *chan; // If non-zero, sleeping on chan int killed; // If non-zero, have been killed int xstate; // Exit status to be returned to parent\u0026#39;s wait int pid; // Process ID // these are private to the process, so p-\u0026gt;lock need not be held. uint64 kstack; // Virtual address of kernel stack uint64 sz; // Size of process memory (bytes) pagetable_t pagetable; // User page table struct trapframe *trapframe; // data page for trampoline.S struct context context; // swtch() here to run process struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory char name[16]; // Process name (debugging) // for syscall trace int trace_mask; }; 其中state为进程状态，UNUSED表示proc数组中该项还未被使用，故要得到进程数，只需要遍历proc数组，看看不是UNUSED的有多少个即可，具体代码见上面的num_proc.\n写了num_proc和free_bytes这俩函数后，接着就很容易编写我们的系统调用了，在kernel/sysproc.c添加如下系统调用代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 uint64 sys_sysinfo(void) { uint64 info; // user pointer to struct sysinfo struct sysinfo si; struct proc *p = myproc(); uint64 num_proc(); uint64 free_bytes(); si.freemem = free_bytes(); si.nproc = num_proc(); argaddr(0,\u0026amp;info); // get user\u0026#39;s pointer to struct sysinfo if(copyout(p-\u0026gt;pagetable,info,(char *)\u0026amp;si,sizeof(si)) \u0026lt; 0) // use copyout to copy si to user address space return -1; return 0; } 其他操作在此略过，详见上一小节（如添加系统调用号，修改syscall.c等等）.\n尾声 这个系列可谓是写一篇少一篇啦😆\n可指不准啥时候就“中道崩殂”了，不过不管怎么说，前两个实验做完啦！\n这两个实验都只是摸摸xv6的表面，下一个实验终于正式和操作系统相关啦！进入内存管理阶段！！\n","date":"2023-01-06T22:37:47+08:00","image":"https://XieWeikai.github.io/aniya_blog/p/lab2-system-calls/cover_hu7ace472778f385b50e7c8f287dbb6c46_2544271_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/lab2-system-calls/","title":"lab2: system calls"},{"content":"xv6 util lab 在闲暇之余，抽出了一部分时间看了看MIT 6.S081课程的实验一，这个实验可能也许是最简单的一个实验了吧，完全没有涉及到操作系统内部原理相关的知识，只是用xv6的系统调用编写用户态的程序。我也不知道花了不知道多久，断断续续的把实验一干完了。该实验的实验要求见 https://pdos.csail.mit.edu/6.828/2020/labs/util.html.\n准备 编译并使用qemu模拟启动操作系统方法为\n1 make qemu 打分测试的命令如下\n1 make grade 测试某个具体的用例，如测试sleep，方法有两种\n1 2 ./grade-lab-util sleep # 第一种方法 make GRADEFLAGS=sleep grade # 第二种方法 sleep 该任务非常简单，写一个sleep程序，能通过命令行参数指定sleep的tick数(tick指一个时钟周期)。程序非常简单，在user目录下新建文件sleep.c，编写代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; int main(int argc, char *argv[]) { if(argc \u0026lt;= 1){ write(1,\u0026#34;error: no input from user !\\n\u0026#34;,28); exit(-1); } sleep(atoi(argv[1])); // sleep 为系统调用 参数为tick数，将命令行参数通过atoi转为整数即可 exit(0); } 编写完成后还需要修改Makefile中的UPROGS(这应该是user programs的意思)，添加sleep，如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 U=user # 用户态程序目录 UPROGS=\\ $U/_cat\\ $U/_echo\\ $U/_forktest\\ $U/_grep\\ $U/_init\\ $U/_kill\\ $U/_ln\\ $U/_ls\\ $U/_mkdir\\ $U/_rm\\ $U/_sh\\ $U/_stressfs\\ $U/_usertests\\ $U/_grind\\ $U/_wc\\ $U/_zombie\\ $U/_sleep # 这是添加的一行内容 修改后make qemu进入xv6系统可以看到多出了一个sleep程序。该程序能通过打分程序。\npingpong 这个也很简单，直接贴上user/pingpong.c代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; int main(int argc, char *argv[]) { int p1[2],p2[2]; char byte; // byte // 两条管道 双向通信 pipe(p1); // parent to child pipe(p2); // child to parent if(fork() != 0){ // parent close(p2[1]); close(p1[0]); write(p1[1],\u0026#34;0\u0026#34;,1); // write a byte read(p2[0],\u0026amp;byte,1); // read a byte printf(\u0026#34;%d: received pong\\n\u0026#34;,getpid()); close(p2[0]); close(p1[1]); exit(0); }else{ // child close(p2[0]); close(p1[1]); read(p1[0],\u0026amp;byte,1); // read a byte printf(\u0026#34;%d: received ping\\n\u0026#34;,getpid()); write(p2[1],\u0026amp;byte,1); // write a byte close(p2[1]); close(p1[0]); exit(0); } } primes 该任务需要编写程序输出2~35中的所有质数，比较特殊的要求是使用并发的方式来筛选质数，算法描述见 http://swtch.com/~rsc/thread/\n算法描述 用一张图来描述这个筛选质数的并发算法，如下\n上图中每一个框框为一个独立执行的例程(可以是process、thread或者别的什么比如golang中的goroutine，总之是可以并发执行的一段程序)，每一个例程可以给右边的邻居发送筛选出来的有可能是质数的数，每一个例程都会进行相应的筛选，选出来的数发给右边的邻居。\n其中第一个例程会收到2-MAX所有的数字，收到的第一个数字当做质数输出(显然第一个数是2，是质数)。第一个例程知道2是质数了，那第一个例程接下来收到的所有数字，如果可以被2整除，那一定不是质数，不能被2整除的有可能是质数，将有可能是质数的数发送给右边的邻居，右边的邻居做进一步的筛选。\n接下来看第二个例程，可以确定的是，第二个例程收到的第一个例程的第一个数字一定也是个质数。为什么呢？第二个例程收到的第一个数字(记作p)一定大于2(大于前一个例程认定了是质数的数)，所有小于p的质数(目前来看就是2)都不是p的因子，那p肯定也是质数。所以第二个例程可以将收到的第一个数认定为质数，将其输出。接下来收到的数字，第二个例程将检测是否能被p整除，若不能才可能是质数，第二个例程会将有可能是质数的数发给右边的邻居（即第三个例程）。显然第三个例程收到的数字一定不会被前两个质数整除，那么第三个例程收到的第一个数字也是个质数\u0026hellip;\u0026hellip;\n用数学归纳法可以容易看出，每个例程收到的第一个数都是质数，且每一个例程都会把可能是质数的数发给右邻居进一步筛选，每一个例程行为的伪代码描述为\n1 2 3 4 5 6 p = get a number from left neighbor print p loop: n = get a number from left neighbor if (p does not divide n) send n to right neighbor 算法实现 这个任务就要实现这一个算法。在我的实现中，使用进程作为一个独立的例程，主进程负责发送2-35所有的数字，然后开启第一个进程进行筛选，接着每一个进程根据需要判断是否需要开启右邻居，先看主进程代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main(int argc,char *argv[]){ int p; int to[2]; int status; pipe(to); // to 是主进程发送2~35所有数字给第一个例程所用的管道 if(fork() != 0){ // parent close(to[0]); // do not read 不用的资源尽快close 主进程用该管道不需要读 for(p = 2;p \u0026lt;= 35;p++) write(to[1],\u0026amp;p,sizeof(p)); // 将2~35所有数字写入管道 close(to[1]); }else{ // child worker(to); // 子进程，即上面示意图中的例程，接收父进程发送的数字 exit(0); } wait(\u0026amp;status); // 主进程等待子进程结束 exit(0); } 接着来看看每一个例程的描述函数worker的实现，worker完全按照前文的伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void worker(int from[]){ // 参数为接收左邻居数字的管道 int forked = 0; // 标记是否开启过右邻居进程 int to[2]; close(from[1]); // do not write to from 该管道我只使用读端，不使用写端，没用的资源尽快释放 int p; // 接收第一个数字 read(from[0],\u0026amp;p,sizeof(p)); // read first p printf(\u0026#34;prime %d\\n\u0026#34;,p); // 第一个数字一定是质数 int t; // 接收数字 while(read(from[0],\u0026amp;t,sizeof(t) != 0)){ // 该循环里面不断接收数字，挑出可能是质数的数字发给右邻居 if(t % p != 0){ // t有可能是质数 这需要发给右邻居了 if(!forked){ // 还没有右邻居 pipe(to); // 创建和右邻居通信的管道 if(fork() != 0){ // parent close(to[0]);// 本进程关闭管道读端 }else{ // child worker(to); // 子进程从to读取数字 exit(0); } forked = 1; // 标记已经开启过子进程 } write(to[1],\u0026amp;t,sizeof(t)); // 发送t给子进程 } } // 释放资源 close(from[0]); close(to[1]); // 等待右邻居退出 int status; wait(\u0026amp;status); } 以上两段代码实现了该任务。\n另外吐槽一下，经过我的尝试，下面这段代码也是可以通过测试的，看来MIT的测试也不过是验证输出罢了\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int is_prime(int n){ int p = n/2; for(int i = 2; i \u0026lt;= p;i++){ if(n % p == 0) return 0; } return 1; } int main(int argc, char *argv[]) { for(int i =2;i \u0026lt;= 35;i++){ if(is_prime(i)) printf(\u0026#34;prime %d\\n\u0026#34;,i); } exit(0); } find 该任务需要实现一个极简版的find，功能如下所述\n1 find \u0026lt;path\u0026gt; \u0026lt;filename\u0026gt; 在\u0026lt;path\u0026gt;路径中搜索文件名为\u0026lt;filename\u0026gt;的文件，示例如下\n1 2 3 4 5 6 7 8 9 10 $ make qemu ... init: starting sh $ echo \u0026gt; b $ mkdir a $ echo \u0026gt; a/b $ find . b ./b ./a/b $ xv6的目录项 在类unix系统中一般使用基于inode的文件系统(可以参考上交的《现代操作系统:原理与实现》个人感觉挺不错)，在这种文件系统下，inode记录了一个文件的所有内容存在disk的位置，所以知道了inode就知道了某一个文件。在类UNIX系统下目录也是普通的文件，文件内存着一个个目录项，即记录着inode号和其他一些文件信息，在xv6内，目录项如下\n1 2 3 4 5 6 7 8 9 // kernel/fs.h // Directory is a file containing a sequence of dirent structures. #define DIRSIZ 14 struct dirent { ushort inum; // inode number char name[DIRSIZ]; // filename }; fstat和stat xv6中获取文件信息的系统调用为fstat，使用该函数还封装了一个用户态下的工具函数stat，两个函数原型如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // system call int fstat(int fd, struct stat*); // fd 为文件描述符 // ulib.c int stat(const char*, struct stat*); int stat(const char *n, struct stat *st) // 函数定义 { int fd; int r; fd = open(n, O_RDONLY); if(fd \u0026lt; 0) return -1; r = fstat(fd, st); close(fd); return r; } 其中描述文件信息的结构定义如下\n1 2 3 4 5 6 7 8 9 10 11 #define T_DIR 1 // Directory #define T_FILE 2 // File #define T_DEVICE 3 // Device struct stat { int dev; // File system\u0026#39;s disk device uint ino; // Inode number short type; // Type of file short nlink; // Number of links to file uint64 size; // Size of file in bytes }; 实现 有了上面的铺垫，容易编写find代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 void find(char *path,char *filename){ // 该函数在 path 内找 文件名为filename的文件 int fd; struct stat st; struct dirent de; char buff[512]; char *p; strcpy(buff,path); // 路径复制到buff里 p = buff + strlen(buff); *p ++ = \u0026#39;/\u0026#39;; // path 后加一个 / if((fd = open(path,0)) \u0026lt; 0){ // 打开path这个目录文件 fprintf(2,\u0026#34;find: cannot open file:%s\\n\u0026#34;,path); return; } if(fstat(fd,\u0026amp;st) \u0026lt; 0){ // 没能获取文件信息 fprintf(2,\u0026#34;find: cannot stat\\n\u0026#34;); close(fd); return; } if(st.type != T_DIR){ // path 不是目录文件 fprintf(2,\u0026#34;find: path:%s is not a directory\\n\u0026#34;,path); close(fd); return; } while(read(fd,\u0026amp;de,sizeof(de)) == sizeof(de)){ // 遍历每一个目录项 // 无效的inode 或者. 和 ..都不继续搜索 if(de.inum == 0 || strcmp(de.name,\u0026#34;.\u0026#34;) == 0 || strcmp(de.name,\u0026#34;..\u0026#34;) == 0) continue; strcpy(p,de.name); // path/filename stat(buff,\u0026amp;st); // 获取文件信息 switch (st.type) { case T_FILE: // 普通文件 if(strcmp(de.name,filename) == 0) printf(\u0026#34;%s\\n\u0026#34;,buff); break; case T_DIR: // 目录文件则递归搜索 find(buff,filename); // find recursively break; default: break; } } } 主函数编写如下\n1 2 3 4 5 6 7 8 9 int main(int argc,char *argv[]){ if(argc \u0026lt;= 2){ fprintf(2,\u0026#34;find: no enough argument\\n\u0026#34;); exit(-1); } find(argv[1],argv[2]); exit(0); } xargs 该任务要求实现一个极简版的xargs，貌似也没什么好解释的，就是熟悉fork和exec即可，直接粘代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; #include \u0026#34;kernel/fs.h\u0026#34; #include \u0026#34;kernel/param.h\u0026#34; #define EOF -1 int getchar(){ char ch; if(read(0,\u0026amp;ch,sizeof(ch)) \u0026lt;= 0) return EOF; return (int)ch; } int readline(char *buf){ int ch; while((ch = getchar()) != \u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; ch != EOF) *buf++ = ch; *buf = 0; if(ch == EOF) return EOF; return 1; } int main(int argc,char *argv[]){ char buf[512]; if(argc \u0026lt;= 1){ fprintf(2,\u0026#34;xarg: no enough arguments\\n\u0026#34;); exit(-1); } int p = 0,q; char *command = argv[1]; char *args[MAXARG]; args[p++] = command; for(int i = 2;i \u0026lt; argc;i++) args[p++] = argv[i]; // arguments from argv q = p; while(readline(buf) != EOF){ args[q] = malloc(strlen(buf)); strcpy(args[q++],buf); } args[q] = 0; int status; if(fork() == 0){ // child exec(command,args); }else{ // father wait(\u0026amp;status); } for(;p \u0026lt; q;p ++) free(args[p]); exit(0); } 尾声 说实话不知道这个MIT 6.S081还能坚持多久，能坚持一个lab就多坚持一个吧☺️\n代码放到 https://github.com/XieWeikai/xv6_lab 的 lab1分支啦，但目前该仓库还是private的，等到这个课程真的完成的差不多了再准备公开了哈哈哈。\n","date":"2023-01-05T16:44:26+08:00","image":"https://XieWeikai.github.io/aniya_blog/p/os_util_lab/saber2_hu583263cbbee05d2c263b501713a891d4_83776_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/os_util_lab/","title":"OS_util_lab"},{"content":"Xv6 环境配置 假期开始，先试着把xv6的实验环境搭建起来，之后做不做实验等到以后再说\u0026hellip;\u0026hellip;\n根据官方的指导教程，在macOS下配置实验环境需要做如下准备\n安装git 早就安装好了 安装qemu 安装risc-v的工具链 安装risc-v工具链 使用如下命令安装 (见 https://github.com/riscv-software-src/homebrew-riscv)\n1 2 brew tap riscv-software-src/riscv brew install riscv-tools 在实际安装时发现brew经常会在某个地方卡住完全不动了(git下载仓库时)，中断后重试几次都是一样。后来在网上发现别人也碰到了类似的问题(见 https://zhayujie.com/mit6828-env.html)，按照该博主的说法，我们只需要安装riscv-gnu-toolchain即可。但下载好源码编译时出现了各种warning，甚至还有error(但貌似还是可以编译出可执行文件的，可能会少一些东西)，根据官网的描述(见 https://github.com/riscv-collab/riscv-gnu-toolchain)，在OS X上编译需要保证文件系统是大小写敏感的，但很可惜macOS使用的文件系统不是大小写敏感的\u0026hellip;\u0026hellip;\n要解决如上问题可以创建一个大小写敏感的文件系统镜像并挂载到本地的某个目录上，方法见 https://github.com/spryker/spryker-docs/blob/master/docs/scos/dev/tutorials-and-howtos/howtos/howto-handle-case-sensitive-file-system-on-mac-os.md ，将源码放到该目录下再编译即可。\n最后感觉太麻烦了，还是决定试一试brew能否成功，执行如下命令\n1 2 brew tap riscv-software-src/riscv brew install riscv-tools 执行开始后本人就去摆烂了，终于在六个小时(左右)后，安装成功完成了\n至此riscv工具链安装完毕。\n安装qemu 理论上来说非常简单，一条命令搞定\n1 brew install qemu 安装完毕，搞定。\n尝试启动xv6，如下\n1 2 3 4 cd path/to/lab git clone git://g.csail.mit.edu/xv6-labs-2020 git checkout util make qemu 在macOS下编译时编译器会报如下错误\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie -c -o user/sh.o user/sh.c user/sh.c: In function \u0026#39;runcmd\u0026#39;: user/sh.c:58:1: error: infinite recursion detected [-Werror=infinite-recursion] 58 | runcmd(struct cmd *cmd) | ^~~~~~ user/sh.c:89:5: note: recursive call 89 | runcmd(rcmd-\u0026gt;cmd); | ^~~~~~~~~~~~~~~~~ user/sh.c:109:7: note: recursive call 109 | runcmd(pcmd-\u0026gt;left); | ^~~~~~~~~~~~~~~~~~ user/sh.c:116:7: note: recursive call 116 | runcmd(pcmd-\u0026gt;right); | ^~~~~~~~~~~~~~~~~~~ user/sh.c:95:7: note: recursive call 95 | runcmd(lcmd-\u0026gt;left); | ^~~~~~~~~~~~~~~~~~ user/sh.c:97:5: note: recursive call 97 | runcmd(lcmd-\u0026gt;right); | ^~~~~~~~~~~~~~~~~~~ user/sh.c:127:7: note: recursive call 127 | runcmd(bcmd-\u0026gt;cmd); | ^~~~~~~~~~~~~~~~~ cc1: all warnings being treated as errors make: *** [\u0026lt;builtin\u0026gt;: user/sh.o] Error 1 将Makefile中CFLAGS的-Werror选项去掉即可。\n但编译完成后悲惨的发现，启动qemu后程序就卡住了，没有任何交互行为。根据官方指导的描述，qemu版本太新可能会出现这个问题。经过查找资料，brew貌似没有办法安装旧版本的qemu，只好在qemu官网上下载qemu 4.2后通过源码来安装qemu了，方法如下\n1 2 3 4 5 6 7 8 cd path/to/lab mkdir qemu-build # 在该目录下下载源码并安装 cd qemu-build wget https://download.qemu.org/qemu-4.2.1.tar.xz # 下载源码压缩包 tar xvJf qemu-4.2.1.tar.xz # 解压 cd qemu-4.2.1 ./configure make # 编译 需要花费几十分钟来完成编译，编译后riscv64-softmmu目录内的qemu-system-riscv64即为需要的可执行文件，做一个软连接如下\n1 2 cd riscv64-softmmu ln -s $(pwd)/qemu-system-riscv64 /usr/local/bin/qemu-system-riscv64 之后重新尝试make qemu，可以正常启动xv6操作系统。\n在docker下配置环境 在docker下拉取ubuntu镜像，以该镜像启动容器\n1 2 3 4 docker run -it --name xv6 \\ -v ...:.../path/to/lab \\ # 挂载本地目录 -p ...:... \\ # 端口映射 ubuntu:latest 接着在该容器内先装些最基本的东西 c/c++的工具链(gcc/c++和各种库、包)、git、cmake、等各种东西。\n安装riscv-tools 根据官方指导，使用如下命令安装\n1 apt-get install gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu 这个安装速度比mac下用brew拉取源码编译快得多了。\n顺带安装一些可能是调试工具的包\n1 apt-get install gdb-multiarch 安装qemu 根据官方指导，使用如下命令安装\n1 apt-get install qemu-system-misc 很遗憾，现在的qemu经过两年的改进，和macOS上一样，新版本的qemu启动后就卡死。按照指导，使用如下命令卸载并安装老版本\n1 2 apt-get remove qemu-system-misc # 卸载 apt-get install qemu-system-misc=1:4.2-3ubuntu6 # 安装老版本 但今非昔比了，上述安装方法会提示找不到该版本的qemu。\n按照指导，也可以进行源码安装\n1 2 3 4 5 6 wget https://download.qemu.org/qemu-5.1.0.tar.xz # 下载源码 qemu 5.1.0 tar xf qemu-5.1.0.tar.xz # 解压 cd qemu-5.1.0 ./configure --disable-kvm --disable-werror --prefix=/usr/local --target-list=\u0026#34;riscv64-softmmu\u0026#34; make make install 在ubuntu环境下make qemu不会报infinite recursion的错误。\n尾声 到此xv6就可以正常启动了，有可能以后还会碰到其他的问题，等到以后再说吧。\n","date":"2023-01-03T21:11:14+08:00","image":"https://XieWeikai.github.io/aniya_blog/p/xv6-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/wallpaper_hu0ff37ebbb98d2b42bafbb67ed8d5243a_153541_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/xv6-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","title":"xv6 环境配置"},{"content":"OS 寒假开始了，如果每天看一点关于操作系统的东西，说不定就可以完成 25%的下个学期的操作系统课程设计呢？\n","date":"2023-01-01T16:38:36+08:00","image":"https://XieWeikai.github.io/aniya_blog/p/os-flag/ostep-fun_hu25d333fcded103db2f52f7476cb1420a_52206_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/os-flag/","title":"OS flag"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://XieWeikai.github.io/aniya_blog/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating. — Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://XieWeikai.github.io/aniya_blog/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nYouTube Privacy Enhanced Shortcode Twitter Simple Shortcode Vimeo Simple Shortcode bilibilibi Shortcode Gist Shortcode Gitlab Snippets Shortcode Quote Shortcode Stack adds a quote shortcode. For example:\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Anonymous book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Some book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Somebody","date":"2019-03-10T00:00:00Z","permalink":"https://XieWeikai.github.io/aniya_blog/p/rich-content/","title":"Rich Content"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://XieWeikai.github.io/aniya_blog/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\ninline math is like this $a^2+b^2=c^2$\n","date":"2019-03-08T00:00:00Z","permalink":"https://XieWeikai.github.io/aniya_blog/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://XieWeikai.github.io/aniya_blog/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/emoji-support/","title":"Emoji Support"}]