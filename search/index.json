[{"content":"xv6 page table相关代码解析 距离上一次实验过了12天啦🤣，险些就中道崩殂了🙃\n不过虽然久了点，好歹还是完成了第三个实验，也就是传说中的page table相关的实验。这部分实验需要理解riscv处理器的寻址方式，并明白xv6源码中和page table相关的部分代码是如何工作的。\n在本篇内容中先不讲实现，先看看源码中的相关部分究竟在做什么😤\nriscv 寻址方式 首先要弄清楚riscv的寻址方式，寻址示意图如下\nriscv中虚拟地址为64位，物理地址为56位(做硬件的设计的，他们觉得目前以及短时间的未来够用了吧)，内存相关硬件可以使用分页机制，规定一页内存大小为4096 bytes($2^{12}$字节)。由于一页4096字节，故虚拟地址(virtual address，简称 va)和物理地址(physical address，简称pa)使用12位作为页内偏移(offset)。pa的高44位为物理页号(physical page number，简称ppn).\nsatp寄存器 从前面的那张图可以看到，riscv采用三级页表，将三级页表分别记为L2、L1、L0其中2级为最高，0级为最低。每一张页表占据4096字节，即占据一个页的大小，故页表首地址设计为按页对齐，这样就只需要记录ppn即可知道页表的位置了。\nL2页表的ppn记录在一个特殊的寄存器中，寄存器全程为:Supervisor Address Translation and Protection (satp) Register，根据手册，该寄存器结构如下图所示\n在这里先解释一些概念如下\nCSR: Control and Status Register，顾名思义，有着控制作用或者记录状态的寄存器，即有着特殊作用的寄存器，一般只有特权指令会用到这些寄存器。 WARL: Write Any Values, Reads Legal Values.即可以写入任何值，但只能读到合法值，也就是说如果写入不合法值，那写入不会生效的，下次读到的还是合法值。 satp就是一个CSR，其中包含三个部分：MODE、ASID和PPN，作用如下\nPPN:即L2页表的ppn，该ppn低位填12个0即为L2页表所在的物理地址。 ASID：不太清楚具体干啥的，手册描述为: an address space identififier (ASID), which facilitates address-translation fences on a per-address-space basis. MODE:控制va到pa的转换模式。 MODE字段可选值即作用如下\n其中8即为xv6使用的MODE，即使用基于分页机制的39位虚拟地址。从图1也可以看出，虚拟地址虽然有64位，但只有低39位有用，这就是因为xv6将MODE设为了8.\n页表、页表项 如图1所示，一张页表包含512项，每一项称为页表项(Page Table Entry, PTE)，每一项占64 bits，如前面所述，一张页表占$512 \\times 64 \\ bits = 4096 \\ bytes$，为一页的大小。\n$PTE$的结构如下\n其中54-63为保留位，10-53这44 bits为低一级页表的ppn或直接是最终物理地址的ppn(L0页表内的$PTE$中的ppn为最终物理地址ppn).\n0-9这10位为权限设置标志，作用顾名思义。注意，在读代码时发现，L2、L1这两级页表中貌似只用到V这个位，L0级页表才用到别的各个位。\n寻址方式 如前文所说，xv6使用$Sv39$，虚拟地址只使用低39位，低12位为$offset$，剩下$27\\ bits$分为三部分，每一部分$9\\ bits$(对应512个$PTE$)，分别为三级页表的索引，产生最终物理地址方式见下图\n物理地址layout 由之前学过的数字逻辑、计算机组成原理可以知道，地址不仅仅可以用来映射到RAM，其实还可以通过MUX(multiplexer 多路选择器)来将不同地址映射到不同硬件设备，如ROM、RAM、别的IO设备等等，xv6系统使用的模拟环境下物理地址空间的布局如下图右半部分所示\n上图中$KERNBASE$和$PHYSTOP$之间的空间即为xv6使用的RAM空间，$KERNBASE$之下的空间要么没用，要么是别的一些硬件，如$0x1000$处为启动代码所在的ROM.\n物理内存分配 riscv采用分页机制，内存分配以页为单位，如前文所示，从KERNBASE开始为RAM，到PHYSTOP为止。内核的代码和数据库从KERNBASE开始装载，内核代码和数据结束后一直到PHYSTOP都是空闲的可以分配的内存空间，xv6的内存分配器就从这一块空间来分配空闲页。\n在启动流程概述中说过，内核代码最从entry.S开始执行，初始化各个处理器的sp寄存器(即栈)，然后跳到start.c中的start()，在对硬件进行一些设置后，通过mret指令跳转到main.c中的main()函数，同时进入supervisor模式，main()函数截取部分如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // start() jumps here in supervisor mode on all CPUs. void main() { if(cpuid() == 0){ consoleinit(); #if defined(LAB_PGTBL) || defined(LAB_LOCK) statsinit(); #endif printfinit(); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;xv6 kernel is booting\\n\u0026#34;); printf(\u0026#34;\\n\u0026#34;); kinit(); // physical page allocator ... } else { ... } scheduler(); } **（注意在执行这部分代码的时候，satp寄存器的mode还没有设置成开启分页机制，此时虚拟地址不经翻译直接作为物理地址，故下面用到的地址均为前文中物理内存布局描述的那样）**其中kinit()函数就是对空闲页分配器的初始化操作，接下来看看这个分配器的实现，源码见kalloc.c，kinit()函数如下\n1 2 3 4 5 6 7 8 9 extern char end[]; // first address after kernel. // defined by kernel.ld. void kinit() { initlock(\u0026amp;kmem.lock, \u0026#34;kmem\u0026#34;); freerange(end, (void*)PHYSTOP); } 由于还没学到锁，第一句initlock先不管，end为内核代码和数据结束后的首地址，定义见链接脚本kernel.ld（暂时没学过链接脚本，可以参考 该文章，PHYSTOP意义见前一节，定义在memlayout.h中。接着看看接受了end和PHYSTOP参数的freerange干了啥，该函数如下\n1 2 3 4 5 6 7 8 9 10 11 // define in riscv.h #define PGROUNDUP(sz) (((sz)+PGSIZE-1) \u0026amp; ~(PGSIZE-1)) void freerange(void *pa_start, void *pa_end) { char *p; p = (char*)PGROUNDUP((uint64)pa_start); for(; p + PGSIZE \u0026lt;= (char*)pa_end; p += PGSIZE) kfree(p); } 可以看到，该函数对pa_start到pa_end之间所有完整的页的首地址均调用了一次kfree函数，接着在看看kfree干什么，如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 struct run { struct run *next; }; struct { struct spinlock lock; struct run *freelist; } kmem; // Free the page of physical memory pointed at by v, // which normally should have been returned by a // call to kalloc(). (The exception is when // initializing the allocator; see kinit above.) void kfree(void *pa) { struct run *r; if(((uint64)pa % PGSIZE) != 0 || (char*)pa \u0026lt; end || (uint64)pa \u0026gt;= PHYSTOP) panic(\u0026#34;kfree\u0026#34;); // Fill with junk to catch dangling refs. memset(pa, 1, PGSIZE); r = (struct run*)pa; acquire(\u0026amp;kmem.lock); r-\u0026gt;next = kmem.freelist; kmem.freelist = r; release(\u0026amp;kmem.lock); } 在这篇文章中先忽略lock是怎么实现的，就算他是对的。上面的kfree函数首先检测给的地址是不是页的首地址以及给定地址范围是否正确，接着往该要释放的空间填入垃圾数据(这是为了让使用已释放内存的程序尽快崩溃)，最后使用该页的开头一小部分空间填充一个struct run结构，将该节点串进kmem.freelist这个链表内。\n故执行完freerange后，可用的空闲页均被串进了kmem.freelist这个空闲链表内了，分配器初始化完毕。\nkinit分配器初始化函数分析完毕，顺带将释放页的函数kfree也看过了，接着看看分配空闲页的函数，如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Allocate one 4096-byte page of physical memory. // Returns a pointer that the kernel can use. // Returns 0 if the memory cannot be allocated. void * kalloc(void) { struct run *r; acquire(\u0026amp;kmem.lock); r = kmem.freelist; if(r) kmem.freelist = r-\u0026gt;next; release(\u0026amp;kmem.lock); if(r) memset((char*)r, 5, PGSIZE); // fill with junk return (void*)r; } 可以看到该分配函数非常简单，从kmem.freelist中取出一个空闲页返回即可。\n本小节看到了一个极简内存分配器的工作方式，书上学过的理论知识一点都没有用到捏😀，毕竟xv6只是个极简的教学操作系统。不过也看到了真正的一个分配器也算有所收获。\n内核地址空间 注意：指令中用到的所有地址均为虚拟地址，虚拟地址如何转换为物理地址由satp中的MODE决定，到目前为止，我们还没有开启分页机制，不进行地址翻译，即虚拟地址直接作为物理地址。\nwalk 该函数在xv6和page table相关的代码中可以说是基石般的存在，因此本文先从该函数讲起，该函数的行为就是模拟MMU的行为，找到一个VA在page table中对应的pte对应的条目，具体细节待会再说。\n相关的宏 在riscv.h中定义了很多相关的宏，挑选一些列举如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #define PGSIZE 4096 // bytes per page #define PGSHIFT 12 // bits of offset within a page #define PGROUNDUP(sz) (((sz)+PGSIZE-1) \u0026amp; ~(PGSIZE-1)) #define PGROUNDDOWN(a) (((a)) \u0026amp; ~(PGSIZE-1)) // shift a physical address to the right place for a PTE. #define PA2PTE(pa) ((((uint64)pa) \u0026gt;\u0026gt; 12) \u0026lt;\u0026lt; 10) #define PTE2PA(pte) (((pte) \u0026gt;\u0026gt; 10) \u0026lt;\u0026lt; 12) // extract the three 9-bit page table indices from a virtual address. #define PXMASK 0x1FF // 9 bits #define PXSHIFT(level) (PGSHIFT+(9*(level))) #define PX(level, va) ((((uint64) (va)) \u0026gt;\u0026gt; PXSHIFT(level)) \u0026amp; PXMASK) // one beyond the highest possible virtual address. // MAXVA is actually one bit less than the max allowed by // Sv39, to avoid having to sign-extend virtual addresses // that have the high bit set. #define MAXVA (1L \u0026lt;\u0026lt; (9 + 9 + 9 + 12 - 1)) #define PTE_V (1L \u0026lt;\u0026lt; 0) // valid #define PTE_R (1L \u0026lt;\u0026lt; 1) #define PTE_W (1L \u0026lt;\u0026lt; 2) #define PTE_X (1L \u0026lt;\u0026lt; 3) #define PTE_U (1L \u0026lt;\u0026lt; 4) // 1 -\u0026gt; user can access 各个宏的意义都比较明显，从名字就可以看出功能。在这里解释一下PX这个宏，这个宏是用来取出一个va中L2、L1、L0这几部分对应的数字的\n如上图，PX(2,va)即为图中L2部分的数字，同理PX(1,va)和PX(0,va)为上图中L1和L0对应的数字。\n类型定义 同样在riscv.h中定义了几个有用的类型\n1 2 typedef uint64 pte_t; typedef uint64 *pagetable_t; // 512 PTEs 其中pte_t即为前面讲过的Page table entry，一个pte64位，故其实就是uint64.而一个pagetable_t即一张页表的首地址，故其实际类型为uint64 *，其实就是pte_t *，前文说到过，一张页表占一页，即4096 bytes，有512个pte.\nwalk功能 walk函数功能其实就是给定一个va和根页表(即前文说的L2级的页表)，根据va找到对应的pte，并将该pte的地址返回，函数定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 pte_t * walk(pagetable_t pagetable, uint64 va, int alloc) { if(va \u0026gt;= MAXVA) // va 超范围 panic panic(\u0026#34;walk\u0026#34;); for(int level = 2; level \u0026gt; 0; level--) { // 从最高一级页表开始逐层找pte pte_t *pte = \u0026amp;pagetable[PX(level, va)]; // 找到该层对应的pte if(*pte \u0026amp; PTE_V) { // 该pte有效则找到了，往下走一层 pagetable = (pagetable_t)PTE2PA(*pte); } else { if(!alloc || (pagetable = (pde_t*)kalloc()) == 0) // 如果alloc != 0则会分配一张页表 return 0; // alloc == 0 或者 分配空闲页失败 返回0 memset(pagetable, 0, PGSIZE); // 分配的页做空页表，pte全设为0 *pte = PA2PTE(pagetable) | PTE_V; // 接着往下走 } } return \u0026amp;pagetable[PX(0, va)]; // 返回pte对应的地址 } 上面的walk函数不仅可以模仿MMU找到pte，还可以通过alloc参数控制分配本来不存在的页表。这个功能非常有用，比如现在某个va在页表中没有对应的项，可以通过walk(pg,va,1)来在页表中创建原本没有的页表，最后返回va对应的pte地址，设置pte即可配置va映射到哪个物理地址以及对应的权限了。从这里也可以看出三级页表的好处，没用到的项不会分配空间，相比一级页表占用空间少。\nmappages 有了walk函数，可以很容易的把某个va映射到对应的pa上并设置对应权限，具体方法在上面描述了一下，在源码中，封装了一个mappages函数专门做va到pa的映射，该函数定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Create PTEs for virtual addresses starting at va that refer to // physical addresses starting at pa. va and size might not // be page-aligned. Returns 0 on success, -1 if walk() couldn\u0026#39;t // allocate a needed page-table page. int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm) { uint64 a, last; pte_t *pte; a = PGROUNDDOWN(va); // 开始要做映射的虚拟页 last = PGROUNDDOWN(va + size - 1); // 最后一页要做映射的虚拟页 for(;;){ if((pte = walk(pagetable, a, 1)) == 0) // 此处walk的alloc 为1 需要分配本来没有的页表 return -1; // 分配失败 if(*pte \u0026amp; PTE_V) // 这个va已经映射过了，重新映射也许是无意为之，panic以提前发现错误 panic(\u0026#34;remap\u0026#34;); *pte = PA2PTE(pa) | perm | PTE_V; // 设置ppn和flag，即映射到的物理地址和访问权限 if(a == last) // 分配完毕 break; a += PGSIZE; // 下一页 pa += PGSIZE; // 下一页 } return 0; } 有了mappages，可以很容易的将一块连续的虚拟地址空间映射到一块连续的物理地址空间上。\nkvmmap 命名有迹可循，k是指kernel，vm是virtual memory，kvm开头的函数和内核的虚拟地址空间有关。u是user，uvm开头的函数和用户的虚拟地址空间有关，其中kvmmap是给内核使用的页表做映射，其实就是对mappages的封装，其定义如下\n1 2 3 4 5 6 7 8 9 // add a mapping to the kernel page table. // only used when booting. // does not flush TLB or enable paging. void kvmmap(uint64 va, uint64 pa, uint64 sz, int perm) { if(mappages(kernel_pagetable, va, sz, pa, perm) != 0) panic(\u0026#34;kvmmap\u0026#34;); } 其中的kernel_pagetable是一个全局变量，即内核的页表，在后面会看到该变量在哪里初始化。\n内核地址空间初始化 在物理内存分配那一小节说过，系统启动时，main通过调用kinit初始化了内存分配器，再回过头看看main如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // start() jumps here in supervisor mode on all CPUs. void main() { if(cpuid() == 0){ consoleinit(); #if defined(LAB_PGTBL) || defined(LAB_LOCK) statsinit(); #endif printfinit(); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;xv6 kernel is booting\\n\u0026#34;); printf(\u0026#34;\\n\u0026#34;); kinit(); // physical page allocator kvminit(); // create kernel page table kvminithart(); // turn on paging procinit(); // process table ... userinit(); // first user process ... } else { ... } scheduler(); } kinit函数接下去就是kvminit，该函数初始化内核的虚拟地址空间，即设置内核的页表，其定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 辅助函数，定义在string.c 顾名思义，设置内存的 void* memset(void *dst, int c, uint n) { char *cdst = (char *) dst; int i; for(i = 0; i \u0026lt; n; i++){ cdst[i] = c; } return dst; } /* * the kernel\u0026#39;s page table. */ pagetable_t kernel_pagetable; void kvminit() { kernel_pagetable = (pagetable_t) kalloc(); // 根页表首先需要分配一页空间 memset(kernel_pagetable, 0, PGSIZE); // 全部pte设为0 // uart registers kvmmap(UART0, UART0, PGSIZE, PTE_R | PTE_W); // virtio mmio disk interface kvmmap(VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W); // CLINT kvmmap(CLINT, CLINT, 0x10000, PTE_R | PTE_W); // PLIC kvmmap(PLIC, PLIC, 0x400000, PTE_R | PTE_W); // map kernel text executable and read-only. kvmmap(KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X); // map kernel data and the physical RAM we\u0026#39;ll make use of. kvmmap((uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W); // map the trampoline for trap entry/exit to // the highest virtual address in the kernel. kvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X); } kvminit将虚拟地址空间的各个地址映射到物理地址空间的各个部分，具体关系如下图所示\n由上图很容易理解kvminit的功能😋，特别注意到除了虚拟地址空间中非常高位的那部分(MAXVA向下的Trampoline和Kstack)，其他的部分均为恒等映射，即va映射后的pa与va相同。\n启动分页机制 从main代码可以看到，kvminit后下一个是kvminithart，这个函数设置了satp寄存器，开启页表并清除TLB缓存(TLB就是计组和csapp里说的那个缓存页表内容的缓存)，如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // use riscv\u0026#39;s sv39 page table scheme. #define SATP_SV39 (8L \u0026lt;\u0026lt; 60) #define MAKE_SATP(pagetable) (SATP_SV39 | (((uint64)pagetable) \u0026gt;\u0026gt; 12)) // supervisor address translation and protection; // holds the address of the page table. static inline void w_satp(uint64 x) { asm volatile(\u0026#34;csrw satp, %0\u0026#34; : : \u0026#34;r\u0026#34; (x)); } // flush the TLB. static inline void sfence_vma() { // the zero, zero means flush all TLB entries. asm volatile(\u0026#34;sfence.vma zero, zero\u0026#34;); } // Switch h/w page table register to the kernel\u0026#39;s page table, // and enable paging. void kvminithart() { w_satp(MAKE_SATP(kernel_pagetable)); sfence_vma(); } 如上，w_satp是用内联汇编写的函数，作用就是写satp寄存器，这行代码将satp的MODE设为sv39，ppn设为kernel_pagetable的ppn.下一行的sfence_vma清除TLB缓存.kvminithart后，分页机制启动，接下来所有指令用到的地址都会通过页表翻译为pa.\n到这里，页表的基本使用和内核地址空间分布均介绍完毕，接下来看看和进程相关的内容。\n进程初始化 在kvminithart后是procinit，该函数定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // Per-process state struct proc { struct spinlock lock; // p-\u0026gt;lock must be held when using these: enum procstate state; // Process state struct proc *parent; // Parent process void *chan; // If non-zero, sleeping on chan int killed; // If non-zero, have been killed int xstate; // Exit status to be returned to parent\u0026#39;s wait int pid; // Process ID // these are private to the process, so p-\u0026gt;lock need not be held. uint64 kstack; // Virtual address of kernel stack uint64 sz; // Size of process memory (bytes) pagetable_t pagetable; // User page table struct trapframe *trapframe; // data page for trampoline.S struct context context; // swtch() here to run process struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory char name[16]; // Process name (debugging) }; struct proc proc[NPROC]; // initialize the proc table at boot time. void procinit(void) { struct proc *p; initlock(\u0026amp;pid_lock, \u0026#34;nextpid\u0026#34;); for(p = proc; p \u0026lt; \u0026amp;proc[NPROC]; p++) { initlock(\u0026amp;p-\u0026gt;lock, \u0026#34;proc\u0026#34;); // Allocate a page for the process\u0026#39;s kernel stack. // Map it high in memory, followed by an invalid // guard page. char *pa = kalloc(); if(pa == 0) panic(\u0026#34;kalloc\u0026#34;); uint64 va = KSTACK((int) (p - proc)); kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W); p-\u0026gt;kstack = va; } kvminithart(); } 上面代码给每个proc初始化了一个锁，并分了一页作为kernel stack，kernel stack在虚拟地址空间所处位置见内核地址空间初始化中的布局图。\n上面代码中的宏KSTACK定义如下\n1 2 3 // map kernel stacks beneath the trampoline, // each surrounded by invalid guard pages. #define KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE) 从前面布局图中容易看出，从trampoline向下，每两页中使用一页作为kstack，另一页用作guard page(若访问超过栈空间，就会访问到guard page的地址，该地址在页表中没有对应的映射，故产生页错误，中断进行处理)。\n这个kernel stack的作用暂时还不清楚是什么，看名字可能是某个进程使用内核(如系统调用)时内核使用的栈吧。\n第一个用户进程 给每一个用户进程均分配一个页表，即每一个进程有它自己的虚拟地址空间，该空间布局如下图所示\n在启动流程概述中说过，第一个用户进程见initcode.S，其内容如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # Initial process that execs /init. # This code runs in user space. #include \u0026#34;syscall.h\u0026#34; # exec(init, argv) .globl start start: la a0, init la a1, argv li a7, SYS_exec ecall # for(;;) exit(); exit: li a7, SYS_exit ecall jal exit # char init[] = \u0026#34;/init\\0\u0026#34;; init: .string \u0026#34;/init\\0\u0026#34; # char *argv[] = { init, 0 }; .p2align 2 argv: .long init .long 0 接下来看看第一个进程具体是如何启动起来的，在main函数中，有如下初始化代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // start() jumps here in supervisor mode on all CPUs. void main() { if(cpuid() == 0){ ... userinit(); // first user process __sync_synchronize(); started = 1; } else { ... } scheduler(); } 可以看到最后一步初始化为userinit，该函数初始化了第一个进程，定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Set up first user process. void userinit(void) { struct proc *p; p = allocproc(); // set trampoline and trapframe initproc = p; // allocate one user page and copy init\u0026#39;s instructions // and data into it. uvminit(p-\u0026gt;pagetable, initcode, sizeof(initcode)); // allocate one page and copy data in it p-\u0026gt;sz = PGSIZE; // prepare for the very first \u0026#34;return\u0026#34; from kernel to user. p-\u0026gt;trapframe-\u0026gt;epc = 0; // user program counter p-\u0026gt;trapframe-\u0026gt;sp = PGSIZE; // user stack pointer safestrcpy(p-\u0026gt;name, \u0026#34;initcode\u0026#34;, sizeof(p-\u0026gt;name)); p-\u0026gt;cwd = namei(\u0026#34;/\u0026#34;); p-\u0026gt;state = RUNNABLE; release(\u0026amp;p-\u0026gt;lock); } 该函数首先调用allocproc返回了一个可用的struct proc*，该函数定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // Look in the process table for an UNUSED proc. // If found, initialize state required to run in the kernel, // and return with p-\u0026gt;lock held. // If there are no free procs, or a memory allocation fails, return 0. static struct proc* allocproc(void) { struct proc *p; // 从proc中找一个UNUSED的空位 for(p = proc; p \u0026lt; \u0026amp;proc[NPROC]; p++) { acquire(\u0026amp;p-\u0026gt;lock); if(p-\u0026gt;state == UNUSED) { goto found; } else { release(\u0026amp;p-\u0026gt;lock); } } return 0; found: // 找到UNUSED的可供使用 p-\u0026gt;pid = allocpid(); // 分配一个pid ,也就是当前没有用的最小的整数 // Allocate a trapframe page. if((p-\u0026gt;trapframe = (struct trapframe *)kalloc()) == 0){ release(\u0026amp;p-\u0026gt;lock); return 0; } // An empty user page table. p-\u0026gt;pagetable = proc_pagetable(p); // proc_pagetable映射了虚拟内存的trapframe 和trampoline if(p-\u0026gt;pagetable == 0){ freeproc(p); release(\u0026amp;p-\u0026gt;lock); return 0; } // Set up new context to start executing at forkret, // which returns to user space. memset(\u0026amp;p-\u0026gt;context, 0, sizeof(p-\u0026gt;context)); p-\u0026gt;context.ra = (uint64)forkret; // ra是return address p-\u0026gt;context.sp = p-\u0026gt;kstack + PGSIZE; // sp是stack pointer return p; } (功能见代码和注释) 接着userinit调用uvminit(initcode)，定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 void uvminit(pagetable_t pagetable, uchar *src, uint sz) { char *mem; if(sz \u0026gt;= PGSIZE) panic(\u0026#34;inituvm: more than a page\u0026#34;); mem = kalloc(); memset(mem, 0, PGSIZE); mappages(pagetable, 0, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U); memmove(mem, src, sz); } 该函数分配一页并将src的内容复制进这一页中，复制的大小为sz，在userinit中，src为initcode，内容如下\n1 2 3 4 5 6 7 8 9 10 11 // a user program that calls exec(\u0026#34;/init\u0026#34;) // od -t xC initcode uchar initcode[] = { 0x17, 0x05, 0x00, 0x00, 0x13, 0x05, 0x45, 0x02, 0x97, 0x05, 0x00, 0x00, 0x93, 0x85, 0x35, 0x02, 0x93, 0x08, 0x70, 0x00, 0x73, 0x00, 0x00, 0x00, 0x93, 0x08, 0x20, 0x00, 0x73, 0x00, 0x00, 0x00, 0xef, 0xf0, 0x9f, 0xff, 0x2f, 0x69, 0x6e, 0x69, 0x74, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; 额\u0026hellip;其实就是那个initcode.S编译后对应的二进制内容🤣🤣，userinit最后设置了proc中一些字段就结束了，第一个进程就此初始化完毕。\n进程调度 main中的最后一个函数为scheduler，即进程调度器，定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // Per-CPU process scheduler. // Each CPU calls scheduler() after setting itself up. // Scheduler never returns. It loops, doing: // - choose a process to run. // - swtch to start running that process. // - eventually that process transfers control // via swtch back to the scheduler. void scheduler(void) { struct proc *p; struct cpu *c = mycpu(); c-\u0026gt;proc = 0; for(;;){ // Avoid deadlock by ensuring that devices can interrupt. intr_on(); int found = 0; for(p = proc; p \u0026lt; \u0026amp;proc[NPROC]; p++) { acquire(\u0026amp;p-\u0026gt;lock); if(p-\u0026gt;state == RUNNABLE) { // Switch to chosen process. It is the process\u0026#39;s job // to release its lock and then reacquire it // before jumping back to us. p-\u0026gt;state = RUNNING; c-\u0026gt;proc = p; swtch(\u0026amp;c-\u0026gt;context, \u0026amp;p-\u0026gt;context); // Process is done running for now. // It should have changed its p-\u0026gt;state before coming back. c-\u0026gt;proc = 0; found = 1; } release(\u0026amp;p-\u0026gt;lock); } #if !defined (LAB_FS) if(found == 0) { intr_on(); asm volatile(\u0026#34;wfi\u0026#34;); } #else ; #endif } } 这个函数是一个无限循环，从proc中找一个RUNNABLE的进程进行调度，其中swtch函数神奇的将cpu转移到了某个进程，看看该函数实现，如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 .globl swtch swtch: sd ra, 0(a0) sd sp, 8(a0) sd s0, 16(a0) sd s1, 24(a0) sd s2, 32(a0) sd s3, 40(a0) sd s4, 48(a0) sd s5, 56(a0) sd s6, 64(a0) sd s7, 72(a0) sd s8, 80(a0) sd s9, 88(a0) sd s10, 96(a0) sd s11, 104(a0) ld ra, 0(a1) ld sp, 8(a1) ld s0, 16(a1) ld s1, 24(a1) ld s2, 32(a1) ld s3, 40(a1) ld s4, 48(a1) ld s5, 56(a1) ld s6, 64(a1) ld s7, 72(a1) ld s8, 80(a1) ld s9, 88(a1) ld s10, 96(a1) ld s11, 104(a1) ret 看看context结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // Saved registers for kernel context switches. struct context { uint64 ra; uint64 sp; // callee-saved uint64 s0; uint64 s1; uint64 s2; uint64 s3; uint64 s4; uint64 s5; uint64 s6; uint64 s7; uint64 s8; uint64 s9; uint64 s10; uint64 s11; }; 到这就知道swtch干了什么了，该函数先将现在的需要保存的各个寄存器放到c-\u0026gt;context内，接着将p-\u0026gt;context中的保存的各个寄存器值放入寄存器中，最后是一个ret指令。注意这里的ret指令不会返回到scheduler中调用该函数的位置了，因为ra(return address)寄存器的值已经改变了，该函数会返回到p-\u0026gt;context-\u0026gt;ra位置处。注意到刚刚在userinit内有这样两句\n1 2 3 4 5 // Set up new context to start executing at forkret, // which returns to user space. memset(\u0026amp;p-\u0026gt;context, 0, sizeof(p-\u0026gt;context)); p-\u0026gt;context.ra = (uint64)forkret; // ra是return address p-\u0026gt;context.sp = p-\u0026gt;kstack + PGSIZE; // sp是stack pointer 所以swtch函数返回的位置是forkret，该函数定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // A fork child\u0026#39;s very first scheduling by scheduler() // will swtch to forkret. void forkret(void) { static int first = 1; // Still holding p-\u0026gt;lock from scheduler. release(\u0026amp;myproc()-\u0026gt;lock); if (first) { // File system initialization must be run in the context of a // regular process (e.g., because it calls sleep), and thus cannot // be run from main(). first = 0; fsinit(ROOTDEV); } usertrapret(); } 可以看到首先释放了锁，接着通过usertrapret将cpu交给用户进程，由于下一节课才是trap，还没有开始看，故此处不再深入，只需要知道usertrapret将cpu返回到用户进程即可。\n创建进程 类unix系统均使用fork()创建新的进程，要启动一个新进程，一般方式为fork创建子进程，接着用exec来执行指定进程，接下来看看相关实现。\nfork fork函数实现如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // Create a new process, copying the parent. // Sets up child kernel stack to return as if from fork() system call. int fork(void) { int i, pid; struct proc *np; struct proc *p = myproc(); // Allocate process. if((np = allocproc()) == 0){ return -1; } // Copy user memory from parent to child. if(uvmcopy(p-\u0026gt;pagetable, np-\u0026gt;pagetable, p-\u0026gt;sz) \u0026lt; 0){ freeproc(np); release(\u0026amp;np-\u0026gt;lock); return -1; } np-\u0026gt;sz = p-\u0026gt;sz; np-\u0026gt;parent = p; // copy saved user registers. *(np-\u0026gt;trapframe) = *(p-\u0026gt;trapframe); // Cause fork to return 0 in the child. np-\u0026gt;trapframe-\u0026gt;a0 = 0; // increment reference counts on open file descriptors. for(i = 0; i \u0026lt; NOFILE; i++) if(p-\u0026gt;ofile[i]) np-\u0026gt;ofile[i] = filedup(p-\u0026gt;ofile[i]); np-\u0026gt;cwd = idup(p-\u0026gt;cwd); safestrcpy(np-\u0026gt;name, p-\u0026gt;name, sizeof(p-\u0026gt;name)); pid = np-\u0026gt;pid; np-\u0026gt;state = RUNNABLE; release(\u0026amp;np-\u0026gt;lock); return pid; } 干的事几乎就是将父进程复制了一遍，首先还是allocproc找到UNUSED的proc分配基本的trampoline和trapframe页，然后复制页表，复制trapframe内容，复制文件描述符，设置pid，设置进程状态。其中和page table相关的uvmcopy代码实现如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // Given a parent process\u0026#39;s page table, copy // its memory into a child\u0026#39;s page table. // Copies both the page table and the // physical memory. // returns 0 on success, -1 on failure. // frees any allocated pages on failure. int uvmcopy(pagetable_t old, pagetable_t new, uint64 sz) { pte_t *pte; uint64 pa, i; uint flags; char *mem; for(i = 0; i \u0026lt; sz; i += PGSIZE){ if((pte = walk(old, i, 0)) == 0) panic(\u0026#34;uvmcopy: pte should exist\u0026#34;); if((*pte \u0026amp; PTE_V) == 0) panic(\u0026#34;uvmcopy: page not present\u0026#34;); pa = PTE2PA(*pte); flags = PTE_FLAGS(*pte); if((mem = kalloc()) == 0) goto err; memmove(mem, (char*)pa, PGSIZE); if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){ kfree(mem); goto err; } } return 0; err: uvmunmap(new, 0, i / PGSIZE, 1); return -1; } 其实就是从0到sz，对每一页进行以下操作\n找到该页对应的pa 分配一个空闲页mem，将pa内容复制到mem 给新页表同样的地址映射到mem处 可以看到这个复制并没有用到理论教材上提到的copy on page 技术😀，xv6果然太粗糙了🤣。\n还有一个uvmunmap函数也值得看一眼，用于去除某块虚拟地址的映射的，定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Remove npages of mappings starting from va. va must be // page-aligned. The mappings must exist. // Optionally free the physical memory. void uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free) { uint64 a; pte_t *pte; if((va % PGSIZE) != 0) panic(\u0026#34;uvmunmap: not aligned\u0026#34;); for(a = va; a \u0026lt; va + npages*PGSIZE; a += PGSIZE){ if((pte = walk(pagetable, a, 0)) == 0) panic(\u0026#34;uvmunmap: walk\u0026#34;); if((*pte \u0026amp; PTE_V) == 0) panic(\u0026#34;uvmunmap: not mapped\u0026#34;); if(PTE_FLAGS(*pte) == PTE_V) panic(\u0026#34;uvmunmap: not a leaf\u0026#34;); if(do_free){ uint64 pa = PTE2PA(*pte); kfree((void*)pa); } *pte = 0; } } 可以看到就是将va开始的npages个页对应页表中的pte设为0，若do_free不为0，则同时释放对应的物理页(使用kfree，即将页放回freelist中)；注意到从上面的if(PTE_FLAGS(*pte) == PTE_V)那句可以看出L2、L1级页表的flag均只设置V这一位，只有L0级页表会设置别的权限位。\nexec xv6中可执行文件也采用elf格式，关于这个格式，可以参考如下几个链接\nhttps://www.bookstack.cn/read/linux-c/3bb12105f3887f7b.md https://docs.oracle.com/cd/E19683-01/816-1386/chapter6-83432/index.html exec函数实现如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 int exec(char *path, char **argv) { char *s, *last; int i, off; uint64 argc, sz = 0, sp, ustack[MAXARG+1], stackbase; struct elfhdr elf; struct inode *ip; struct proghdr ph; pagetable_t pagetable = 0, oldpagetable; struct proc *p = myproc(); begin_op(); // filesystem 接口 if((ip = namei(path)) == 0){ // 找到path相应的inode end_op(); return -1; } ilock(ip); // Check ELF header if(readi(ip, 0, (uint64)\u0026amp;elf, 0, sizeof(elf)) != sizeof(elf)) goto bad; if(elf.magic != ELF_MAGIC) goto bad; if((pagetable = proc_pagetable(p)) == 0) // 给新进程初始化pagetable 即映射trampoline 和 trapframe goto bad; // Load program into memory. for(i=0, off=elf.phoff; i\u0026lt;elf.phnum; i++, off+=sizeof(ph)){ // 读program header 中的一个个条目 if(readi(ip, 0, (uint64)\u0026amp;ph, off, sizeof(ph)) != sizeof(ph)) goto bad; if(ph.type != ELF_PROG_LOAD) // 不需要加载的条目略 continue; if(ph.memsz \u0026lt; ph.filesz) goto bad; if(ph.vaddr + ph.memsz \u0026lt; ph.vaddr) goto bad; uint64 sz1; if((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == 0) // 给用户分配空间 goto bad; sz = sz1; if(ph.vaddr % PGSIZE != 0) goto bad; if(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) \u0026lt; 0) // 将段装入之前分配的空间 goto bad; } iunlockput(ip); end_op(); ip = 0; p = myproc(); uint64 oldsz = p-\u0026gt;sz; // Allocate two pages at the next page boundary. // Use the second as the user stack. sz = PGROUNDUP(sz); uint64 sz1; if((sz1 = uvmalloc(pagetable, sz, sz + 2*PGSIZE)) == 0) // 多分配两页，一页为用户stack 一页为guard page goto bad; sz = sz1; uvmclear(pagetable, sz-2*PGSIZE); // 清除guard page 对应的U位 sp = sz; stackbase = sp - PGSIZE; // Push argument strings, prepare rest of stack in ustack. for(argc = 0; argv[argc]; argc++) { // 初始化用户的参数 即argc argv if(argc \u0026gt;= MAXARG) goto bad; sp -= strlen(argv[argc]) + 1; sp -= sp % 16; // riscv sp must be 16-byte aligned if(sp \u0026lt; stackbase) goto bad; if(copyout(pagetable, sp, argv[argc], strlen(argv[argc]) + 1) \u0026lt; 0) goto bad; ustack[argc] = sp; } ustack[argc] = 0; // push the array of argv[] pointers. sp -= (argc+1) * sizeof(uint64); sp -= sp % 16; if(sp \u0026lt; stackbase) goto bad; if(copyout(pagetable, sp, (char *)ustack, (argc+1)*sizeof(uint64)) \u0026lt; 0) goto bad; // arguments to user main(argc, argv) // argc is returned via the system call return // value, which goes in a0. p-\u0026gt;trapframe-\u0026gt;a1 = sp; // Save program name for debugging. for(last=s=path; *s; s++) if(*s == \u0026#39;/\u0026#39;) last = s+1; safestrcpy(p-\u0026gt;name, last, sizeof(p-\u0026gt;name)); // Commit to the user image. oldpagetable = p-\u0026gt;pagetable; p-\u0026gt;pagetable = pagetable; p-\u0026gt;sz = sz; p-\u0026gt;trapframe-\u0026gt;epc = elf.entry; // initial program counter = main p-\u0026gt;trapframe-\u0026gt;sp = sp; // initial stack pointer proc_freepagetable(oldpagetable, oldsz); return argc; // this ends up in a0, the first argument to main(argc, argv) bad: if(pagetable) proc_freepagetable(pagetable, sz); if(ip){ iunlockput(ip); end_op(); } return -1; } 该函数实现较长，大致描述一下干了什么:读入elf文件中需要装载的各个段并分配空间装载、分配用户栈空间、初始化用户栈(即初始化argc argv)、更新proc结构的各个字段、释放旧的空间、搞定。\n其中uvmalloc函数值得一看，其实现如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // Allocate PTEs and physical memory to grow process from oldsz to // newsz, which need not be page aligned. Returns new size or 0 on error. uint64 uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz) { char *mem; uint64 a; if(newsz \u0026lt; oldsz) return oldsz; oldsz = PGROUNDUP(oldsz); // oldsz如果在一页的中间，那么这一页一定之前已经分配过给用户了，所以这里是round up for(a = oldsz; a \u0026lt; newsz; a += PGSIZE){ // 每一页分配空闲物理页并进行映射 mem = kalloc(); if(mem == 0){ uvmdealloc(pagetable, a, oldsz); return 0; } memset(mem, 0, PGSIZE); if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != 0){ kfree(mem); uvmdealloc(pagetable, a, oldsz); return 0; } } return newsz; } 该函数将用户地址空间从oldsz拓展到newsz，其实就是按照每一页来分配空闲的内存空间并做对应的映射。若空间不足，则调用uvmdealloc，将空间释放为原来那样。顺带看看uvmdealloc的实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Deallocate user pages to bring the process size from oldsz to // newsz. oldsz and newsz need not be page-aligned, nor does newsz // need to be less than oldsz. oldsz can be larger than the actual // process size. Returns the new process size. uint64 uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz) { if(newsz \u0026gt;= oldsz) return oldsz; if(PGROUNDUP(newsz) \u0026lt; PGROUNDUP(oldsz)){ int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE; uvmunmap(pagetable, PGROUNDUP(newsz), npages, 1); } return newsz; } 其实就是对之前讲过的uvmunmap的封装。\nsbrk实现 在第一个实验时使用过很多系统调用，其中有一个(我没使用过的)和page table相关，就是sbrk，描述如下\n1 char *sbrk(int n) // Grow process’s memory by n bytes. Returns start of new memory 看看该系统调用的实现，之前做过syscall lab，容易找到对应函数如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 uint64 sys_sbrk(void) { int addr; int n; if(argint(0, \u0026amp;n) \u0026lt; 0) // 获取参数 n return -1; addr = myproc()-\u0026gt;sz; // 现在进程的地址空间为 [0,sz) 故sz就是新的地址起始位置 if(growproc(n) \u0026lt; 0) // 扩大用户进程可用内存 return -1; return addr; } 可以看到关键在于这个growproc函数，查看该函数如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // Grow or shrink user memory by n bytes. // Return 0 on success, -1 on failure. int growproc(int n) { uint sz; struct proc *p = myproc(); sz = p-\u0026gt;sz; if(n \u0026gt; 0){ if((sz = uvmalloc(p-\u0026gt;pagetable, sz, sz + n)) == 0) { return -1; } } else if(n \u0026lt; 0){ sz = uvmdealloc(p-\u0026gt;pagetable, sz, sz + n); } p-\u0026gt;sz = sz; return 0; } 该函数封装了uvmalloc和uvmdealloc，分别用于增长空间和缩小空间。\n尾声 到这里大概把做pagetable lab看过的源码都扫了一遍😆\n这个实验边摆边做做的时间实在是有点长了，印象到现在还挺深，所以这一篇文章基本就是摘抄源代码，解释比较少，希望以后看到时还能记起来究竟是怎么回事🤣\n下一篇象征性写写pagetable lab的实现就完啦！！\n","date":"2023-01-18T11:13:11+08:00","image":"https://XieWeikai.github.io/aniya_blog/p/mit-6.s081-page-table-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/wallpaper_hudb94877ecea93d4ab13b1a424f076a8e_2205015_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/mit-6.s081-page-table-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/","title":"MIT 6.S081 page table 代码解析"},{"content":"闲话、gdb 闲话 自打syscall lab以来，三天都没看MIT 6.S081🤣，今天扫了一下下一节课的内容，发现居然！！！ 居然是讲实验二的内容🤡\u0026hellip;\n讲的大概就是上一篇博客中\u0026quot;准备\u0026ldquo;那一小节的内容，前几天做syscall lab时还奇怪呢，怎么这个实验内容不带讲的，全靠自己看是吧，还看了有几个小时\u0026hellip;\u0026hellip;\n官网上的课程表长这个样\n实验二并没有对应的课程，但是当你往下一看\n逆天呀，原来是先布置实验，过几天才上对应的课😨\n由于已经做过实验二了，就不仔细看这节课了，象征性的扫了一下，贴几个链接如下\n好心人的课程翻译: https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec03-os-organization-and-system-calls 课程视频: https://www.bilibili.com/video/BV19k4y1C7kA?p=2\u0026vd_source=a47945b9c45a33522fa3c242107add1e GDB 在上面讲到的那节课中，最后在描述xv6大致启动过程时，老师用到了GDB来跟踪启动时执行的代码，之前还没用过gdb来调试xv6，于是也尝试了一下\n启动 使用如下命令启动xv6\n1 make CPUS=1 qemu-gdb CPUS设定模拟的核数，设为1是因为一个CPU容易调试，启动后效果如下\ndocker环境下启动gdb 上面的xv6是跑在docker容器内的(见环境配置)，直接在docker内使用gdb，效果如下\n启动时报了这样的一个警告，说是auto-loading has been declined，gdb在启动时会自动执行当前目录内的.gdbinit内的命令，在实验目录下该文件内容如下\n执行完这些命令就已经设置好了gdb客户端，可以开始调试xv6，但是docker内的gdb说要添加safe-path，按照提示向/root/.config/gdb/gdbinit添加如下内容\n直接将/xwk目录设置为safe-path，再次启动gdb，效果如下\n结果还是有问题，这个普通的gdb都不支持riscv:rv64。回忆起之前环境配置时，安装了一个gdb-multiarch，看名字就是多architechture的gdb，尝试使用gdb-multiarch，结果如下\n上图结果和课程录像一致，也可以正常进行调试。\nmac下的gdb 尝试在实验目录下(这样才能执行.gdbinit)直接启动macOS下安装的gdb，发现macOS下用brew装的gdb居然支持riscv:rv64，真是太好了😋！\n可是docker内的25000端口没有暴露😅，只好重新开一个容器了，先把已有的容器commit，再新建容器\n1 2 3 4 5 6 docker commit -a \u0026#34;...\u0026#34; -m \u0026#34;...\u0026#34; xv6 dev:latest # 将容器commit成镜像 docker container rm xv6 # 删除xv6容器 docker run -itd --name xv6 \\ -p 8080:22 \\ # ssh端口 \\p 25000:25000 \\ # gdb服务器端口 -v ...:... # 挂载实验目录 重新执行下面语句启动xv6并启动gdb服务器\n1 make CPUS=1 qemu-gdb 接着直接在macOS下启动gdb，如下\n大功告成😤\n尾声 因为科研组的关系，接下来可能得看一些深度学习相关的东西了，那OS就会比以前更慢了😨，看一节课是一节课吧🤣\n","date":"2023-01-10T20:21:11+08:00","image":"https://XieWeikai.github.io/aniya_blog/p/%E9%97%B2%E8%B0%88gdb/piano_hu28da5375bae764b9601c6414097b4ddd_1403895_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/%E9%97%B2%E8%B0%88gdb/","title":"闲谈、gdb"},{"content":"OS lab syscall 时隔一天，居然又象征性的完成了一个实验😋\n本次实验需要在xv6系统内额外添加两个系统调用，分别是trace和sysinfo，trace用于跟踪某个进程使用系统调用的情况，sysinfo用于查看系统内空闲内存和进程个数。\n实验的官方指导见 https://pdos.csail.mit.edu/6.828/2020/labs/syscall.html 。\n准备 官方指导中的前置要求是\nBefore you start coding, read Chapter 2 of the xv6 book, and Sections 4.3 and 4.4 of Chapter 4, and related source files:\nThe user-space code for systems calls is in user/user.h and user/usys.pl. The kernel-space code is kernel/syscall.h, kernel/syscall.c. The process-related code is kernel/proc.h and kernel/proc.c. 指导书中的Chapter 2描述了操作系统的组织结构，内容大概是简单讲了一下操作系统的功能作用、操作系统为什么重要、有哪些组织操作系统各个部分的方法等等。\n在Chapter 2的最后大概讲了讲xv6的启动过程。\n启动流程概述 qemu模拟的机器启动时首先执行ROM中的程序，这个程序的作用应该就是将启动区的一部分代码载入内存并转交CPU使用权到载入的代码，xv6最初的代码见kernel/entry.S:6\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # qemu -kernel loads the kernel at 0x80000000 # and causes each CPU to jump there. # kernel.ld causes the following code to # be placed at 0x80000000. .section .text _entry: # set up a stack for C. # stack0 is declared in start.c, # with a 4096-byte stack per CPU. # sp = stack0 + (hartid * 4096) la sp, stack0 li a0, 1024*4 csrr a1, mhartid addi a1, a1, 1 mul a0, a0, a1 add sp, sp, a0 # jump to start() in start.c call start spin: j spin 上面的汇编代码设置好栈顶寄存器后将跳转到 kernel/start.c中的start函数，注意在机器刚启动时处在machine mode，该模式下拥有所有的权限。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // entry.S jumps here in machine mode on stack0. void start() { // set M Previous Privilege mode to Supervisor, for mret. unsigned long x = r_mstatus(); x \u0026amp;= ~MSTATUS_MPP_MASK; x |= MSTATUS_MPP_S; w_mstatus(x); // set M Exception Program Counter to main, for mret. // requires gcc -mcmodel=medany w_mepc((uint64)main); // disable paging for now. w_satp(0); // delegate all interrupts and exceptions to supervisor mode. w_medeleg(0xffff); w_mideleg(0xffff); w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE); // ask for clock interrupts. timerinit(); // keep each CPU\u0026#39;s hartid in its tp register, for cpuid(). int id = r_mhartid(); w_tp(id); // switch to supervisor mode and jump to main(). asm volatile(\u0026#34;mret\u0026#34;); } 上面的代码对机器进行了一些设置，没了解过riscv的处理器，随着实验的深入应该也许会了解更多吧，上面代码的最后一句，使用汇编mret，这一般用于supervisor mode调用machine mode的代码后从machine mode返回supervisor mode，在这个代码里通过mret进入supervisor mode，也就是操作系统内核运行的模式，在start函数前面一些代码已经将返回地址设为了main，故mret会转到main函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // start() jumps here in supervisor mode on all CPUs. void main() { if(cpuid() == 0){ consoleinit(); printfinit(); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;xv6 kernel is booting\\n\u0026#34;); printf(\u0026#34;\\n\u0026#34;); kinit(); // physical page allocator kvminit(); // create kernel page table kvminithart(); // turn on paging procinit(); // process table trapinit(); // trap vectors trapinithart(); // install kernel trap vector plicinit(); // set up interrupt controller plicinithart(); // ask PLIC for device interrupts binit(); // buffer cache iinit(); // inode cache fileinit(); // file table virtio_disk_init(); // emulated hard disk userinit(); // first user process __sync_synchronize(); started = 1; } else { while(started == 0) ; __sync_synchronize(); printf(\u0026#34;hart %d starting\\n\u0026#34;, cpuid()); kvminithart(); // turn on paging trapinithart(); // install kernel trap vector plicinithart(); // ask PLIC for device interrupts } scheduler(); } main函数内进行了一堆初始化操作，最后调用了userinit()函数启动第一个用户进程，该函数代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Set up first user process. void userinit(void) { struct proc *p; p = allocproc(); initproc = p; // allocate one user page and copy init\u0026#39;s instructions // and data into it. uvminit(p-\u0026gt;pagetable, initcode, sizeof(initcode)); p-\u0026gt;sz = PGSIZE; // prepare for the very first \u0026#34;return\u0026#34; from kernel to user. p-\u0026gt;trapframe-\u0026gt;epc = 0; // user program counter p-\u0026gt;trapframe-\u0026gt;sp = PGSIZE; // user stack pointer safestrcpy(p-\u0026gt;name, \u0026#34;initcode\u0026#34;, sizeof(p-\u0026gt;name)); p-\u0026gt;cwd = namei(\u0026#34;/\u0026#34;); p-\u0026gt;state = RUNNABLE; release(\u0026amp;p-\u0026gt;lock); } 上面的代码在对进程一些必要的东西初始化后启动了initcode这一个用户进程，该进程是用汇编写的，代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026#34;syscall.h\u0026#34; # exec(init, argv) .globl start start: la a0, init la a1, argv li a7, SYS_exec ecall # for(;;) exit(); exit: li a7, SYS_exit ecall jal exit # char init[] = \u0026#34;/init\\0\u0026#34;; init: .string \u0026#34;/init\\0\u0026#34; # char *argv[] = { init, 0 }; .p2align 2 argv: .long init .long 0 上面的代码相当于执行了c程序\n1 2 3 4 5 6 7 8 void start(){ char *init = \u0026#34;/init\u0026#34;; char *argv[] = {init,0}; exec(init,argv); for(;;) exit(); } 这个/init程序见源码user/init.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // init: The initial user-level program #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;kernel/spinlock.h\u0026#34; #include \u0026#34;kernel/sleeplock.h\u0026#34; #include \u0026#34;kernel/fs.h\u0026#34; #include \u0026#34;kernel/file.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; #include \u0026#34;kernel/fcntl.h\u0026#34; char *argv[] = { \u0026#34;sh\u0026#34;, 0 }; int main(void) { int pid, wpid; if(open(\u0026#34;console\u0026#34;, O_RDWR) \u0026lt; 0){ mknod(\u0026#34;console\u0026#34;, CONSOLE, 0); open(\u0026#34;console\u0026#34;, O_RDWR); } dup(0); // stdout dup(0); // stderr for(;;){ printf(\u0026#34;init: starting sh\\n\u0026#34;); pid = fork(); if(pid \u0026lt; 0){ printf(\u0026#34;init: fork failed\\n\u0026#34;); exit(1); } if(pid == 0){ exec(\u0026#34;sh\u0026#34;, argv); printf(\u0026#34;init: exec sh failed\\n\u0026#34;); exit(1); } for(;;){ // this call to wait() returns if the shell exits, // or if a parentless process exits. wpid = wait((int *) 0); if(wpid == pid){ // the shell exited; restart it. break; } else if(wpid \u0026lt; 0){ printf(\u0026#34;init: wait returned an error\\n\u0026#34;); exit(1); } else { // it was a parentless process; do nothing. } } } } 引用指导书的话，init程序干的事为\nInit (user/init.c:15) creates a new console device fifile if needed and then opens it as fifile descriptors 0, 1, and 2. Then it starts a shell on the console. The system is up.\nxv6大致的启动流程到此结束，其实还是比较模糊的，细节应该会在后面的实验逐渐展开 \u0026hellip; 吧🤣\n系统调用 在实验指导网站中还提到要看指导书的4.3和4.4节，这两节象征性的讲了下系统调用相关的代码，细节不表，大概流程在本节粗略的解释一下。\n首先在上一节中其实看到了汇编如何调用exec系统调用的，如下\n1 2 3 4 la a0, init la a1, argv li a7, SYS_exec ecall riscv内有a0-a7这几个寄存器（按照惯例）用于传递参数(a就是arg)，exec需要两个参数，这两个参数分别存入a0,a1中，a7用于存放系统调用号。ecall指令会陷入内核(具体哪里以后应该会知道的)，陷入内核后依次执行uservec、usertrap然后是syscall，最后这个syscall函数真正调用了系统调用。该函数见kernel/syscall.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void syscall(void) { int num; struct proc *p = myproc(); num = p-\u0026gt;trapframe-\u0026gt;a7; if(num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt; NELEM(syscalls) \u0026amp;\u0026amp; syscalls[num]) { p-\u0026gt;trapframe-\u0026gt;a0 = syscalls[num](); } else { printf(\u0026#34;%d %s: unknown sys call %d\\n\u0026#34;, p-\u0026gt;pid, p-\u0026gt;name, num); p-\u0026gt;trapframe-\u0026gt;a0 = -1; } } 先注意上面的myproc，该函数返回一个进程(使用系统调用的进程)相关的结构体(应该就是理论学习中的PCB了吧)，该结构体定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Per-process state struct proc { struct spinlock lock; // p-\u0026gt;lock must be held when using these: enum procstate state; // Process state struct proc *parent; // Parent process void *chan; // If non-zero, sleeping on chan int killed; // If non-zero, have been killed int xstate; // Exit status to be returned to parent\u0026#39;s wait int pid; // Process ID // these are private to the process, so p-\u0026gt;lock need not be held. uint64 kstack; // Virtual address of kernel stack uint64 sz; // Size of process memory (bytes) pagetable_t pagetable; // User page table struct trapframe *trapframe; // data page for trampoline.S struct context context; // swtch() here to run process struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory char name[16]; // Process name (debugging) }; 上面结构中的trapframe存着该进程的寄存器状态和其他一些信息，在回过头来看syscall中的如下代码\n1 2 3 4 5 6 7 int num; struct proc *p = myproc(); num = p-\u0026gt;trapframe-\u0026gt;a7; // a7存的是调用号，如前面汇编语言调用系统调用所示 if(num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt; NELEM(syscalls) \u0026amp;\u0026amp; syscalls[num]) { // 调用号满足一定条件才能调用系统调用 p-\u0026gt;trapframe-\u0026gt;a0 = syscalls[num](); } 解释见注释，再来看看syscalls这个变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 static uint64 (*syscalls[])(void) = { [SYS_fork] sys_fork, [SYS_exit] sys_exit, [SYS_wait] sys_wait, [SYS_pipe] sys_pipe, [SYS_read] sys_read, [SYS_kill] sys_kill, [SYS_exec] sys_exec, [SYS_fstat] sys_fstat, [SYS_chdir] sys_chdir, [SYS_dup] sys_dup, [SYS_getpid] sys_getpid, [SYS_sbrk] sys_sbrk, [SYS_sleep] sys_sleep, [SYS_uptime] sys_uptime, [SYS_open] sys_open, [SYS_write] sys_write, [SYS_mknod] sys_mknod, [SYS_unlink] sys_unlink, [SYS_link] sys_link, [SYS_mkdir] sys_mkdir, [SYS_close] sys_close, }; 这是一个指向函数的指针的数组，指向的函数形如uint64 func_name(void )，这一段代码给该数组进行初始化，其中sys_fork，sys_exit之类的为具体的函数(函数就是一堆指令，函数名其实就是这一堆指令的首地址)，SYS_fork之类的表明数组下标，这些宏定义在syscall.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // System call numbers #define SYS_fork 1 #define SYS_exit 2 #define SYS_wait 3 #define SYS_pipe 4 #define SYS_read 5 #define SYS_kill 6 #define SYS_exec 7 #define SYS_fstat 8 #define SYS_chdir 9 #define SYS_dup 10 #define SYS_getpid 11 #define SYS_sbrk 12 #define SYS_sleep 13 #define SYS_uptime 14 #define SYS_open 15 #define SYS_write 16 #define SYS_mknod 17 #define SYS_unlink 18 #define SYS_link 19 #define SYS_mkdir 20 #define SYS_close 21 获取参数 上面看到了系统调用的过程，syscall实际上是根据a7中的调用号来选择某个具体的实现系统调用的函数来完成系统调用的。上一小节看到，syscall调用的函数原型为uint64 func_name(void)，那这些函数如何拿到用户传递的参数呢？\n实际上通过陷入系统调用的代码就可以看出来了\n1 2 3 4 5 # 调用 exec(init,argv) la a0, init la a1, argv li a7, SYS_exec ecall 参数存在了该进程的a0-a5寄存器中，而通过前文可以看到，可以通过myproc拿到用户进程的PCB，也就是一个struct proc *，该结构内的trapframe内有用户进程的寄存器状态，比如exec要拿到第一个参数，只需要拿到a0即可，如下\n1 2 3 struct proc *p = myproc(); p-\u0026gt;trapframe-\u0026gt;a0 // 这个值就是第一个参数 在kernel/syscall.c中已经给我们封装好了相关的函数，如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 static uint64 argraw(int n) { struct proc *p = myproc(); switch (n) { case 0: return p-\u0026gt;trapframe-\u0026gt;a0; case 1: return p-\u0026gt;trapframe-\u0026gt;a1; case 2: return p-\u0026gt;trapframe-\u0026gt;a2; case 3: return p-\u0026gt;trapframe-\u0026gt;a3; case 4: return p-\u0026gt;trapframe-\u0026gt;a4; case 5: return p-\u0026gt;trapframe-\u0026gt;a5; } panic(\u0026#34;argraw\u0026#34;); return -1; } 可以看到，调用 argraw(n)可以拿到第n个参数，也就是an寄存器的值，在该文件中还进一步封装了另外几个函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Fetch the nth 32-bit system call argument. int argint(int n, int *ip) // 获取整数类型的参数 { *ip = argraw(n); return 0; } // Retrieve an argument as a pointer. // Doesn\u0026#39;t check for legality, since // copyin/copyout will do that. int argaddr(int n, uint64 *ip) // 获取地址(指针类型的参数) { *ip = argraw(n); return 0; } // Fetch the nth word-sized system call argument as a null-terminated string. // Copies into buf, at most max. // Returns string length if OK (including nul), -1 if error. int argstr(int n, char *buf, int max) // 获取字符串类型的参数 { uint64 addr; if(argaddr(n, \u0026amp;addr) \u0026lt; 0) return -1; // fetchstr 从用户态的地址处将字符串取出复制到内核态中的buf内 内核态和用户态 // 的地址空间不一样(页表不同) return fetchstr(addr, buf, max); } 具体功能见注释。\n用户态stub 作为用户，如果希望进行系统调用，肯定不希望写汇编来调用，那么在用户态下需要封装一层函数来陷入内核进行系统调用，如用户希望调用文件相关的系统调用只需按照下面的代码书写\n1 2 3 fd = open(\u0026#34;hello.txt\u0026#34;,O_CREAT|O_WRONLY); write(fd,\u0026#34;Hello,xv6!\u0026#34;,10); 那么上面这些open、write的代码究竟在哪里呢？这些代码详见user/usys.S，截取这两个函数代码如下\n1 2 3 4 5 6 7 8 9 10 11 .global open open: li a7, SYS_open ecall ret .global write write: li a7, SYS_write ecall ret 在用户态编写代码func(a,b,c)时，其实就是将a,b,c的值装入a0,a1,a2寄存器，然后将下一跳指令地址保存在ra寄存器，然后跳转到func地址处执行，上面的open和write函数只需要向a7寄存器装入调用号，再用ecall就可以陷入内核进行系统调用了。\n可以看见这些代码都非常的一致，自己手写显得太傻了，故xv6源码中用usys.pl这个perl脚本自动生成usys.S，该脚本如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/usr/bin/perl -w # Generate usys.S, the stubs for syscalls. print \u0026#34;# generated by usys.pl - do not edit\\n\u0026#34;; print \u0026#34;#include \\\u0026#34;kernel/syscall.h\\\u0026#34;\\n\u0026#34;; sub entry { my $name = shift; print \u0026#34;.global $name\\n\u0026#34;; print \u0026#34;${name}:\\n\u0026#34;; print \u0026#34; li a7, SYS_${name}\\n\u0026#34;; print \u0026#34; ecall\\n\u0026#34;; print \u0026#34; ret\\n\u0026#34;; } entry(\u0026#34;fork\u0026#34;); entry(\u0026#34;exit\u0026#34;); ... # 每一个系统调用写一个entry(\u0026#34;syscall_name\u0026#34;)即可 到这里就基本知道系统调用是怎么回事了，虽然具体细节不太清楚，但知道个大概流程就可以开始做本次实验了。\n用户态和内核态数据传输 由于用户态和内核态地址空间不一样，故不能简单的通过地址来传入或传出数据，来看看fstat系统调用如何传出struct stat结构体到用户态，看其源码如下\n1 2 3 4 5 6 7 8 9 10 11 uint64 sys_fstat(void) { struct file *f; uint64 st; // user pointer to struct stat if(argfd(0, 0, \u0026amp;f) \u0026lt; 0 || argaddr(1, \u0026amp;st) \u0026lt; 0) // 这里调用argaddr(1,\u0026amp;st)后，st即存着用户传入的struct stat*指针的值 return -1; return filestat(f, st); } 再看看filestat的实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Get metadata about file f. // addr is a user virtual address, pointing to a struct stat. int filestat(struct file *f, uint64 addr) { struct proc *p = myproc(); struct stat st; if(f-\u0026gt;type == FD_INODE || f-\u0026gt;type == FD_DEVICE){ ilock(f-\u0026gt;ip); stati(f-\u0026gt;ip, \u0026amp;st); iunlock(f-\u0026gt;ip); if(copyout(p-\u0026gt;pagetable, addr, (char *)\u0026amp;st, sizeof(st)) \u0026lt; 0) // 注意这里将内核态的结构复制到用户态的地址处 return -1; return 0; } return -1; } 可以看到需要通过copyout函数来将内核地址空间的数据复制到用户的地址空间，其中第一个参数是用户进程的页表。\n实验 trace 看看实验要做什么\nIn this assignment you will add a system call tracing feature that may help you when debugging later labs. You\u0026rsquo;ll create a new trace system call that will control tracing. It should take one argument, an integer \u0026ldquo;mask\u0026rdquo;, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls trace(1 \u0026lt;\u0026lt; SYS_fork), where SYS_fork is a syscall number from kernel/syscall.h. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call\u0026rsquo;s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don\u0026rsquo;t need to print the system call arguments. The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.\n实验应该达到的效果\n1 2 3 4 5 $ trace 32 grep hello README # 32 就是 1 \u0026lt;\u0026lt; SYS_read 3: syscall read -\u0026gt; 1023 3: syscall read -\u0026gt; 966 3: syscall read -\u0026gt; 70 3: syscall read -\u0026gt; 0 有了前文的基础，这个实验其实很简单，首先要找个地方记录某个进程要trace的系统调用，显然在PCB即struct proc中记录这个mask比较好，在该结构中添加一个mask字段如下\n1 2 3 4 5 6 // Per-process state struct proc { ... // for syscall trace int trace_mask; // save the trace mask for a process }; 那么添加的系统调用功能就是设置进程的trace_mask，在sysproc.c中添加如下系统调用函数如下\n1 2 3 4 5 6 7 8 9 uint64 sys_trace(void) { struct proc *p = myproc(); int mask; argint(0,\u0026amp;mask); // get the mask argment p-\u0026gt;trace_mask = mask; // save the trace mask return 0; } 在syscall.h中添加系统调用号，如下\n1 2 3 4 5 // System call numbers ... // added system call #define SYS_trace 22 接着修改syscall.c中的系统调用表，添加一条如下\n1 2 3 4 5 6 7 8 // added system call extern uint64 sys_trace(void); // declaration static uint64 (*syscalls[])(void) = { ... // added syscall [SYS_trace] sys_trace, // 添加一条系统调用 }; 为了在调用系统调用时输出相关信息，仔细想想，每一个系统调用都要经过syscall，那么可以修改syscall，在系统调用后输出trace的信息，修改该函数如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 记录系统调用名字 static char *syscalls_names[] = { \u0026#34;none\u0026#34;,\u0026#34;fork\u0026#34;,\u0026#34;exit\u0026#34;,\u0026#34;wait\u0026#34;,\u0026#34;pipe\u0026#34;,\u0026#34;read\u0026#34;,\u0026#34;kill\u0026#34;,\u0026#34;exec\u0026#34;,\u0026#34;fstat\u0026#34;,\u0026#34;chdir\u0026#34;,\u0026#34;dup\u0026#34;,\u0026#34;getpid\u0026#34;,\u0026#34;sbrk\u0026#34;, \u0026#34;sleep\u0026#34;,\u0026#34;uptime\u0026#34;,\u0026#34;open\u0026#34;,\u0026#34;write\u0026#34;,\u0026#34;mknod\u0026#34;,\u0026#34;unlink\u0026#34;,\u0026#34;link\u0026#34;,\u0026#34;mkdir\u0026#34;,\u0026#34;close\u0026#34;,\u0026#34;trace\u0026#34;,\u0026#34;sysinfo\u0026#34; }; void syscall(void) { int num; struct proc *p = myproc(); num = p-\u0026gt;trapframe-\u0026gt;a7; if(num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt; NELEM(syscalls) \u0026amp;\u0026amp; syscalls[num]) { p-\u0026gt;trapframe-\u0026gt;a0 = syscalls[num](); // a0 中存着返回值 if((p-\u0026gt;trace_mask \u0026amp; (1 \u0026lt;\u0026lt; num)) != 0){ // it is a traced system call // 如果该系统调用的mask设置过了，则输出信息 printf(\u0026#34;%d: syscall %s -\u0026gt; %d\\n\u0026#34;,p-\u0026gt;pid,syscalls_names[num],p-\u0026gt;trapframe-\u0026gt;a0); } } else { printf(\u0026#34;%d %s: unknown sys call %d\\n\u0026#34;, p-\u0026gt;pid, p-\u0026gt;name, num); p-\u0026gt;trapframe-\u0026gt;a0 = -1; } } 注意按照任务要求，如果一个进程trace某些系统调用，那么该进行fork出来的子进程也要trace这些系统调用，fork系统调用代码如下\n1 2 3 4 5 uint64 sys_fork(void) { return fork(); } 查看这个fork函数代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // Create a new process, copying the parent. // Sets up child kernel stack to return as if from fork() system call. int fork(void) { int i, pid; struct proc *np; struct proc *p = myproc(); // Allocate process. if((np = allocproc()) == 0){ return -1; } // Copy user memory from parent to child. if(uvmcopy(p-\u0026gt;pagetable, np-\u0026gt;pagetable, p-\u0026gt;sz) \u0026lt; 0){ freeproc(np); release(\u0026amp;np-\u0026gt;lock); return -1; } np-\u0026gt;sz = p-\u0026gt;sz; np-\u0026gt;parent = p; // copy saved user registers. *(np-\u0026gt;trapframe) = *(p-\u0026gt;trapframe); // Cause fork to return 0 in the child. np-\u0026gt;trapframe-\u0026gt;a0 = 0; // increment reference counts on open file descriptors. for(i = 0; i \u0026lt; NOFILE; i++) if(p-\u0026gt;ofile[i]) np-\u0026gt;ofile[i] = filedup(p-\u0026gt;ofile[i]); np-\u0026gt;cwd = idup(p-\u0026gt;cwd); safestrcpy(np-\u0026gt;name, p-\u0026gt;name, sizeof(p-\u0026gt;name)); pid = np-\u0026gt;pid; np-\u0026gt;state = RUNNABLE; release(\u0026amp;np-\u0026gt;lock); return pid; } 具体细节不谈，但从上面的代码可以看出，p是当前进程PCB，np是fork出来的，新的进程的PCB，该函数就是在执行复制进程的工作。为了让子进程可以trace和父进程同样的系统调用，需要将父进程的trace_mask也复制一下，添加一行代码如下\n1 2 3 4 5 6 7 8 9 10 11 // Create a new process, copying the parent. // Sets up child kernel stack to return as if from fork() system call. int fork(void) { ... // copy trace mask np-\u0026gt;trace_mask = p-\u0026gt;trace_mask; ... return pid; } 至此完成了添加函数调用的任务，接下来还需要给用户增加接口，故在usys.pl中末尾添加代码如下(作用见 用户态stub 那一小节)\n1 2 3 ... # added system call entry(\u0026#34;trace\u0026#34;); 在头文件user/user.h中添加该系统调用原型如下\n1 2 // added system call int trace(int mask); 一切完成后测试能否通过测试，如下\nsysinfo 第二个添加的系统调用根据实验指导书描述如下\nIn this assignment you will add a system call, sysinfo, that collects information about the running system. The system call takes one argument: a pointer to a struct sysinfo (see kernel/sysinfo.h). The kernel should fill out the fields of this struct: the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED. We provide a test program sysinfotest; you pass this assignment if it prints \u0026ldquo;sysinfotest: OK\u0026rdquo;.\n可以看到，sysinfo系统调用要求给用户返回如下结构\n1 2 3 4 struct sysinfo { uint64 freemem; // amount of free memory (bytes) uint64 nproc; // number of process }; 指导书上比较关键的几句提示如下\nsysinfo needs to copy a struct sysinfo back to user space; see sys_fstat() (kernel/sysfile.c) and filestat() (kernel/file.c) for examples of how to do that using copyout(). To collect the amount of free memory, add a function to kernel/kalloc.c To collect the number of processes, add a function to kernel/proc.c 其中第一点在前文中有所描述。\n但非常羞愧的是，第二第三点，道理我都懂，可是关于xv6我还一无所知，我怎么知道怎么获取系统进程数和空闲内存呀😅，也没有一点提示，还没看到xv6的内存管理和进程调度呢🤡\n无奈稍微在网上查了一下🙃，编写获取空闲内存的代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // kalloc.c struct run { struct run *next; }; struct { struct spinlock lock; struct run *freelist; } kmem; // return number of free bytes uint64 free_bytes(){ struct run *p = kmem.freelist; uint64 num_of_free_page = 0; while(p){ num_of_free_page ++; p = p-\u0026gt;next; } return num_of_free_page * PGSIZE; } 上面代码中的kmem用于管理内存，该结构内有一个lock和freelist，顾名思义freelist应该就是串起空闲页的结构(灰常奇怪，这个链表节点struct run为毛只有一个指针\u0026hellip;)，但总之先这样吧，后面做内存管理时会知道怎么回事的🤣\n上面代码的free_bytes即获取空闲内存字节数的函数。\n接下来再看看怎么获取系统进程数目，代码如下\n1 2 3 4 5 6 7 8 9 10 11 struct proc proc[NPROC]; // get the number of process uint64 num_proc(){ uint64 sum = 0; for(int i = 0;i \u0026lt; NPROC;i ++) if(proc[i].state != UNUSED) sum ++; return sum; } 上面代码中的proc结构体就是存所有进程的状态的，struct proc这个结构体在前文也看到过，再次展示如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 enum procstate { UNUSED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE }; // Per-process state struct proc { struct spinlock lock; // p-\u0026gt;lock must be held when using these: enum procstate state; // Process state struct proc *parent; // Parent process void *chan; // If non-zero, sleeping on chan int killed; // If non-zero, have been killed int xstate; // Exit status to be returned to parent\u0026#39;s wait int pid; // Process ID // these are private to the process, so p-\u0026gt;lock need not be held. uint64 kstack; // Virtual address of kernel stack uint64 sz; // Size of process memory (bytes) pagetable_t pagetable; // User page table struct trapframe *trapframe; // data page for trampoline.S struct context context; // swtch() here to run process struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory char name[16]; // Process name (debugging) // for syscall trace int trace_mask; }; 其中state为进程状态，UNUSED表示proc数组中该项还未被使用，故要得到进程数，只需要遍历proc数组，看看不是UNUSED的有多少个即可，具体代码见上面的num_proc.\n写了num_proc和free_bytes这俩函数后，接着就很容易编写我们的系统调用了，在kernel/sysproc.c添加如下系统调用代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 uint64 sys_sysinfo(void) { uint64 info; // user pointer to struct sysinfo struct sysinfo si; struct proc *p = myproc(); uint64 num_proc(); uint64 free_bytes(); si.freemem = free_bytes(); si.nproc = num_proc(); argaddr(0,\u0026amp;info); // get user\u0026#39;s pointer to struct sysinfo if(copyout(p-\u0026gt;pagetable,info,(char *)\u0026amp;si,sizeof(si)) \u0026lt; 0) // use copyout to copy si to user address space return -1; return 0; } 其他操作在此略过，详见上一小节（如添加系统调用号，修改syscall.c等等）.\n尾声 这个系列可谓是写一篇少一篇啦😆\n可指不准啥时候就“中道崩殂”了，不过不管怎么说，前两个实验做完啦！\n这两个实验都只是摸摸xv6的表面，下一个实验终于正式和操作系统相关啦！进入内存管理阶段！！\n","date":"2023-01-06T22:37:47+08:00","image":"https://XieWeikai.github.io/aniya_blog/p/lab2-system-calls/cover_hu7ace472778f385b50e7c8f287dbb6c46_2544271_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/lab2-system-calls/","title":"lab2: system calls"},{"content":"xv6 util lab 在闲暇之余，抽出了一部分时间看了看MIT 6.S081课程的实验一，这个实验可能也许是最简单的一个实验了吧，完全没有涉及到操作系统内部原理相关的知识，只是用xv6的系统调用编写用户态的程序。我也不知道花了不知道多久，断断续续的把实验一干完了。该实验的实验要求见 https://pdos.csail.mit.edu/6.828/2020/labs/util.html.\n准备 编译并使用qemu模拟启动操作系统方法为\n1 make qemu 打分测试的命令如下\n1 make grade 测试某个具体的用例，如测试sleep，方法有两种\n1 2 ./grade-lab-util sleep # 第一种方法 make GRADEFLAGS=sleep grade # 第二种方法 sleep 该任务非常简单，写一个sleep程序，能通过命令行参数指定sleep的tick数(tick指一个时钟周期)。程序非常简单，在user目录下新建文件sleep.c，编写代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; int main(int argc, char *argv[]) { if(argc \u0026lt;= 1){ write(1,\u0026#34;error: no input from user !\\n\u0026#34;,28); exit(-1); } sleep(atoi(argv[1])); // sleep 为系统调用 参数为tick数，将命令行参数通过atoi转为整数即可 exit(0); } 编写完成后还需要修改Makefile中的UPROGS(这应该是user programs的意思)，添加sleep，如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 U=user # 用户态程序目录 UPROGS=\\ $U/_cat\\ $U/_echo\\ $U/_forktest\\ $U/_grep\\ $U/_init\\ $U/_kill\\ $U/_ln\\ $U/_ls\\ $U/_mkdir\\ $U/_rm\\ $U/_sh\\ $U/_stressfs\\ $U/_usertests\\ $U/_grind\\ $U/_wc\\ $U/_zombie\\ $U/_sleep # 这是添加的一行内容 修改后make qemu进入xv6系统可以看到多出了一个sleep程序。该程序能通过打分程序。\npingpong 这个也很简单，直接贴上user/pingpong.c代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; int main(int argc, char *argv[]) { int p1[2],p2[2]; char byte; // byte // 两条管道 双向通信 pipe(p1); // parent to child pipe(p2); // child to parent if(fork() != 0){ // parent close(p2[1]); close(p1[0]); write(p1[1],\u0026#34;0\u0026#34;,1); // write a byte read(p2[0],\u0026amp;byte,1); // read a byte printf(\u0026#34;%d: received pong\\n\u0026#34;,getpid()); close(p2[0]); close(p1[1]); exit(0); }else{ // child close(p2[0]); close(p1[1]); read(p1[0],\u0026amp;byte,1); // read a byte printf(\u0026#34;%d: received ping\\n\u0026#34;,getpid()); write(p2[1],\u0026amp;byte,1); // write a byte close(p2[1]); close(p1[0]); exit(0); } } primes 该任务需要编写程序输出2~35中的所有质数，比较特殊的要求是使用并发的方式来筛选质数，算法描述见 http://swtch.com/~rsc/thread/\n算法描述 用一张图来描述这个筛选质数的并发算法，如下\n上图中每一个框框为一个独立执行的例程(可以是process、thread或者别的什么比如golang中的goroutine，总之是可以并发执行的一段程序)，每一个例程可以给右边的邻居发送筛选出来的有可能是质数的数，每一个例程都会进行相应的筛选，选出来的数发给右边的邻居。\n其中第一个例程会收到2-MAX所有的数字，收到的第一个数字当做质数输出(显然第一个数是2，是质数)。第一个例程知道2是质数了，那第一个例程接下来收到的所有数字，如果可以被2整除，那一定不是质数，不能被2整除的有可能是质数，将有可能是质数的数发送给右边的邻居，右边的邻居做进一步的筛选。\n接下来看第二个例程，可以确定的是，第二个例程收到的第一个例程的第一个数字一定也是个质数。为什么呢？第二个例程收到的第一个数字(记作p)一定大于2(大于前一个例程认定了是质数的数)，所有小于p的质数(目前来看就是2)都不是p的因子，那p肯定也是质数。所以第二个例程可以将收到的第一个数认定为质数，将其输出。接下来收到的数字，第二个例程将检测是否能被p整除，若不能才可能是质数，第二个例程会将有可能是质数的数发给右边的邻居（即第三个例程）。显然第三个例程收到的数字一定不会被前两个质数整除，那么第三个例程收到的第一个数字也是个质数\u0026hellip;\u0026hellip;\n用数学归纳法可以容易看出，每个例程收到的第一个数都是质数，且每一个例程都会把可能是质数的数发给右邻居进一步筛选，每一个例程行为的伪代码描述为\n1 2 3 4 5 6 p = get a number from left neighbor print p loop: n = get a number from left neighbor if (p does not divide n) send n to right neighbor 算法实现 这个任务就要实现这一个算法。在我的实现中，使用进程作为一个独立的例程，主进程负责发送2-35所有的数字，然后开启第一个进程进行筛选，接着每一个进程根据需要判断是否需要开启右邻居，先看主进程代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main(int argc,char *argv[]){ int p; int to[2]; int status; pipe(to); // to 是主进程发送2~35所有数字给第一个例程所用的管道 if(fork() != 0){ // parent close(to[0]); // do not read 不用的资源尽快close 主进程用该管道不需要读 for(p = 2;p \u0026lt;= 35;p++) write(to[1],\u0026amp;p,sizeof(p)); // 将2~35所有数字写入管道 close(to[1]); }else{ // child worker(to); // 子进程，即上面示意图中的例程，接收父进程发送的数字 exit(0); } wait(\u0026amp;status); // 主进程等待子进程结束 exit(0); } 接着来看看每一个例程的描述函数worker的实现，worker完全按照前文的伪代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void worker(int from[]){ // 参数为接收左邻居数字的管道 int forked = 0; // 标记是否开启过右邻居进程 int to[2]; close(from[1]); // do not write to from 该管道我只使用读端，不使用写端，没用的资源尽快释放 int p; // 接收第一个数字 read(from[0],\u0026amp;p,sizeof(p)); // read first p printf(\u0026#34;prime %d\\n\u0026#34;,p); // 第一个数字一定是质数 int t; // 接收数字 while(read(from[0],\u0026amp;t,sizeof(t) != 0)){ // 该循环里面不断接收数字，挑出可能是质数的数字发给右邻居 if(t % p != 0){ // t有可能是质数 这需要发给右邻居了 if(!forked){ // 还没有右邻居 pipe(to); // 创建和右邻居通信的管道 if(fork() != 0){ // parent close(to[0]);// 本进程关闭管道读端 }else{ // child worker(to); // 子进程从to读取数字 exit(0); } forked = 1; // 标记已经开启过子进程 } write(to[1],\u0026amp;t,sizeof(t)); // 发送t给子进程 } } // 释放资源 close(from[0]); close(to[1]); // 等待右邻居退出 int status; wait(\u0026amp;status); } 以上两段代码实现了该任务。\n另外吐槽一下，经过我的尝试，下面这段代码也是可以通过测试的，看来MIT的测试也不过是验证输出罢了\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int is_prime(int n){ int p = n/2; for(int i = 2; i \u0026lt;= p;i++){ if(n % p == 0) return 0; } return 1; } int main(int argc, char *argv[]) { for(int i =2;i \u0026lt;= 35;i++){ if(is_prime(i)) printf(\u0026#34;prime %d\\n\u0026#34;,i); } exit(0); } find 该任务需要实现一个极简版的find，功能如下所述\n1 find \u0026lt;path\u0026gt; \u0026lt;filename\u0026gt; 在\u0026lt;path\u0026gt;路径中搜索文件名为\u0026lt;filename\u0026gt;的文件，示例如下\n1 2 3 4 5 6 7 8 9 10 $ make qemu ... init: starting sh $ echo \u0026gt; b $ mkdir a $ echo \u0026gt; a/b $ find . b ./b ./a/b $ xv6的目录项 在类unix系统中一般使用基于inode的文件系统(可以参考上交的《现代操作系统:原理与实现》个人感觉挺不错)，在这种文件系统下，inode记录了一个文件的所有内容存在disk的位置，所以知道了inode就知道了某一个文件。在类UNIX系统下目录也是普通的文件，文件内存着一个个目录项，即记录着inode号和其他一些文件信息，在xv6内，目录项如下\n1 2 3 4 5 6 7 8 9 // kernel/fs.h // Directory is a file containing a sequence of dirent structures. #define DIRSIZ 14 struct dirent { ushort inum; // inode number char name[DIRSIZ]; // filename }; fstat和stat xv6中获取文件信息的系统调用为fstat，使用该函数还封装了一个用户态下的工具函数stat，两个函数原型如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // system call int fstat(int fd, struct stat*); // fd 为文件描述符 // ulib.c int stat(const char*, struct stat*); int stat(const char *n, struct stat *st) // 函数定义 { int fd; int r; fd = open(n, O_RDONLY); if(fd \u0026lt; 0) return -1; r = fstat(fd, st); close(fd); return r; } 其中描述文件信息的结构定义如下\n1 2 3 4 5 6 7 8 9 10 11 #define T_DIR 1 // Directory #define T_FILE 2 // File #define T_DEVICE 3 // Device struct stat { int dev; // File system\u0026#39;s disk device uint ino; // Inode number short type; // Type of file short nlink; // Number of links to file uint64 size; // Size of file in bytes }; 实现 有了上面的铺垫，容易编写find代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 void find(char *path,char *filename){ // 该函数在 path 内找 文件名为filename的文件 int fd; struct stat st; struct dirent de; char buff[512]; char *p; strcpy(buff,path); // 路径复制到buff里 p = buff + strlen(buff); *p ++ = \u0026#39;/\u0026#39;; // path 后加一个 / if((fd = open(path,0)) \u0026lt; 0){ // 打开path这个目录文件 fprintf(2,\u0026#34;find: cannot open file:%s\\n\u0026#34;,path); return; } if(fstat(fd,\u0026amp;st) \u0026lt; 0){ // 没能获取文件信息 fprintf(2,\u0026#34;find: cannot stat\\n\u0026#34;); close(fd); return; } if(st.type != T_DIR){ // path 不是目录文件 fprintf(2,\u0026#34;find: path:%s is not a directory\\n\u0026#34;,path); close(fd); return; } while(read(fd,\u0026amp;de,sizeof(de)) == sizeof(de)){ // 遍历每一个目录项 // 无效的inode 或者. 和 ..都不继续搜索 if(de.inum == 0 || strcmp(de.name,\u0026#34;.\u0026#34;) == 0 || strcmp(de.name,\u0026#34;..\u0026#34;) == 0) continue; strcpy(p,de.name); // path/filename stat(buff,\u0026amp;st); // 获取文件信息 switch (st.type) { case T_FILE: // 普通文件 if(strcmp(de.name,filename) == 0) printf(\u0026#34;%s\\n\u0026#34;,buff); break; case T_DIR: // 目录文件则递归搜索 find(buff,filename); // find recursively break; default: break; } } } 主函数编写如下\n1 2 3 4 5 6 7 8 9 int main(int argc,char *argv[]){ if(argc \u0026lt;= 2){ fprintf(2,\u0026#34;find: no enough argument\\n\u0026#34;); exit(-1); } find(argv[1],argv[2]); exit(0); } xargs 该任务要求实现一个极简版的xargs，貌似也没什么好解释的，就是熟悉fork和exec即可，直接粘代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; #include \u0026#34;kernel/fs.h\u0026#34; #include \u0026#34;kernel/param.h\u0026#34; #define EOF -1 int getchar(){ char ch; if(read(0,\u0026amp;ch,sizeof(ch)) \u0026lt;= 0) return EOF; return (int)ch; } int readline(char *buf){ int ch; while((ch = getchar()) != \u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; ch != EOF) *buf++ = ch; *buf = 0; if(ch == EOF) return EOF; return 1; } int main(int argc,char *argv[]){ char buf[512]; if(argc \u0026lt;= 1){ fprintf(2,\u0026#34;xarg: no enough arguments\\n\u0026#34;); exit(-1); } int p = 0,q; char *command = argv[1]; char *args[MAXARG]; args[p++] = command; for(int i = 2;i \u0026lt; argc;i++) args[p++] = argv[i]; // arguments from argv q = p; while(readline(buf) != EOF){ args[q] = malloc(strlen(buf)); strcpy(args[q++],buf); } args[q] = 0; int status; if(fork() == 0){ // child exec(command,args); }else{ // father wait(\u0026amp;status); } for(;p \u0026lt; q;p ++) free(args[p]); exit(0); } 尾声 说实话不知道这个MIT 6.S081还能坚持多久，能坚持一个lab就多坚持一个吧☺️\n代码放到 https://github.com/XieWeikai/xv6_lab 的 lab1分支啦，但目前该仓库还是private的，等到这个课程真的完成的差不多了再准备公开了哈哈哈。\n","date":"2023-01-05T16:44:26+08:00","image":"https://XieWeikai.github.io/aniya_blog/p/os_util_lab/saber2_hu583263cbbee05d2c263b501713a891d4_83776_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/os_util_lab/","title":"OS_util_lab"},{"content":"Xv6 环境配置 假期开始，先试着把xv6的实验环境搭建起来，之后做不做实验等到以后再说\u0026hellip;\u0026hellip;\n根据官方的指导教程，在macOS下配置实验环境需要做如下准备\n安装git 早就安装好了 安装qemu 安装risc-v的工具链 安装risc-v工具链 使用如下命令安装 (见 https://github.com/riscv-software-src/homebrew-riscv)\n1 2 brew tap riscv-software-src/riscv brew install riscv-tools 在实际安装时发现brew经常会在某个地方卡住完全不动了(git下载仓库时)，中断后重试几次都是一样。后来在网上发现别人也碰到了类似的问题(见 https://zhayujie.com/mit6828-env.html)，按照该博主的说法，我们只需要安装riscv-gnu-toolchain即可。但下载好源码编译时出现了各种warning，甚至还有error(但貌似还是可以编译出可执行文件的，可能会少一些东西)，根据官网的描述(见 https://github.com/riscv-collab/riscv-gnu-toolchain)，在OS X上编译需要保证文件系统是大小写敏感的，但很可惜macOS使用的文件系统不是大小写敏感的\u0026hellip;\u0026hellip;\n要解决如上问题可以创建一个大小写敏感的文件系统镜像并挂载到本地的某个目录上，方法见 https://github.com/spryker/spryker-docs/blob/master/docs/scos/dev/tutorials-and-howtos/howtos/howto-handle-case-sensitive-file-system-on-mac-os.md ，将源码放到该目录下再编译即可。\n最后感觉太麻烦了，还是决定试一试brew能否成功，执行如下命令\n1 2 brew tap riscv-software-src/riscv brew install riscv-tools 执行开始后本人就去摆烂了，终于在六个小时(左右)后，安装成功完成了\n至此riscv工具链安装完毕。\n安装qemu 理论上来说非常简单，一条命令搞定\n1 brew install qemu 安装完毕，搞定。\n尝试启动xv6，如下\n1 2 3 4 cd path/to/lab git clone git://g.csail.mit.edu/xv6-labs-2020 git checkout util make qemu 在macOS下编译时编译器会报如下错误\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 riscv64-linux-gnu-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie -c -o user/sh.o user/sh.c user/sh.c: In function \u0026#39;runcmd\u0026#39;: user/sh.c:58:1: error: infinite recursion detected [-Werror=infinite-recursion] 58 | runcmd(struct cmd *cmd) | ^~~~~~ user/sh.c:89:5: note: recursive call 89 | runcmd(rcmd-\u0026gt;cmd); | ^~~~~~~~~~~~~~~~~ user/sh.c:109:7: note: recursive call 109 | runcmd(pcmd-\u0026gt;left); | ^~~~~~~~~~~~~~~~~~ user/sh.c:116:7: note: recursive call 116 | runcmd(pcmd-\u0026gt;right); | ^~~~~~~~~~~~~~~~~~~ user/sh.c:95:7: note: recursive call 95 | runcmd(lcmd-\u0026gt;left); | ^~~~~~~~~~~~~~~~~~ user/sh.c:97:5: note: recursive call 97 | runcmd(lcmd-\u0026gt;right); | ^~~~~~~~~~~~~~~~~~~ user/sh.c:127:7: note: recursive call 127 | runcmd(bcmd-\u0026gt;cmd); | ^~~~~~~~~~~~~~~~~ cc1: all warnings being treated as errors make: *** [\u0026lt;builtin\u0026gt;: user/sh.o] Error 1 将Makefile中CFLAGS的-Werror选项去掉即可。\n但编译完成后悲惨的发现，启动qemu后程序就卡住了，没有任何交互行为。根据官方指导的描述，qemu版本太新可能会出现这个问题。经过查找资料，brew貌似没有办法安装旧版本的qemu，只好在qemu官网上下载qemu 4.2后通过源码来安装qemu了，方法如下\n1 2 3 4 5 6 7 8 cd path/to/lab mkdir qemu-build # 在该目录下下载源码并安装 cd qemu-build wget https://download.qemu.org/qemu-4.2.1.tar.xz # 下载源码压缩包 tar xvJf qemu-4.2.1.tar.xz # 解压 cd qemu-4.2.1 ./configure make # 编译 需要花费几十分钟来完成编译，编译后riscv64-softmmu目录内的qemu-system-riscv64即为需要的可执行文件，做一个软连接如下\n1 2 cd riscv64-softmmu ln -s $(pwd)/qemu-system-riscv64 /usr/local/bin/qemu-system-riscv64 之后重新尝试make qemu，可以正常启动xv6操作系统。\n在docker下配置环境 在docker下拉取ubuntu镜像，以该镜像启动容器\n1 2 3 4 docker run -it --name xv6 \\ -v ...:.../path/to/lab \\ # 挂载本地目录 -p ...:... \\ # 端口映射 ubuntu:latest 接着在该容器内先装些最基本的东西 c/c++的工具链(gcc/c++和各种库、包)、git、cmake、等各种东西。\n安装riscv-tools 根据官方指导，使用如下命令安装\n1 apt-get install gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu 这个安装速度比mac下用brew拉取源码编译快得多了。\n顺带安装一些可能是调试工具的包\n1 apt-get install gdb-multiarch 安装qemu 根据官方指导，使用如下命令安装\n1 apt-get install qemu-system-misc 很遗憾，现在的qemu经过两年的改进，和macOS上一样，新版本的qemu启动后就卡死。按照指导，使用如下命令卸载并安装老版本\n1 2 apt-get remove qemu-system-misc # 卸载 apt-get install qemu-system-misc=1:4.2-3ubuntu6 # 安装老版本 但今非昔比了，上述安装方法会提示找不到该版本的qemu。\n按照指导，也可以进行源码安装\n1 2 3 4 5 6 wget https://download.qemu.org/qemu-5.1.0.tar.xz # 下载源码 qemu 5.1.0 tar xf qemu-5.1.0.tar.xz # 解压 cd qemu-5.1.0 ./configure --disable-kvm --disable-werror --prefix=/usr/local --target-list=\u0026#34;riscv64-softmmu\u0026#34; make make install 在ubuntu环境下make qemu不会报infinite recursion的错误。\n尾声 到此xv6就可以正常启动了，有可能以后还会碰到其他的问题，等到以后再说吧。\n","date":"2023-01-03T21:11:14+08:00","image":"https://XieWeikai.github.io/aniya_blog/p/xv6-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/wallpaper_hu0ff37ebbb98d2b42bafbb67ed8d5243a_153541_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/xv6-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","title":"xv6 环境配置"},{"content":"OS 寒假开始了，如果每天看一点关于操作系统的东西，说不定就可以完成 25%的下个学期的操作系统课程设计呢？\n","date":"2023-01-01T16:38:36+08:00","image":"https://XieWeikai.github.io/aniya_blog/p/os-flag/ostep-fun_hu25d333fcded103db2f52f7476cb1420a_52206_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/os-flag/","title":"OS flag"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://XieWeikai.github.io/aniya_blog/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating. — Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://XieWeikai.github.io/aniya_blog/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nYouTube Privacy Enhanced Shortcode Twitter Simple Shortcode Vimeo Simple Shortcode bilibilibi Shortcode Gist Shortcode Gitlab Snippets Shortcode Quote Shortcode Stack adds a quote shortcode. For example:\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Anonymous book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Some book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Somebody","date":"2019-03-10T00:00:00Z","permalink":"https://XieWeikai.github.io/aniya_blog/p/rich-content/","title":"Rich Content"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://XieWeikai.github.io/aniya_blog/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\ninline math is like this $a^2+b^2=c^2$\n","date":"2019-03-08T00:00:00Z","permalink":"https://XieWeikai.github.io/aniya_blog/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://XieWeikai.github.io/aniya_blog/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"https://XieWeikai.github.io/aniya_blog/p/emoji-support/","title":"Emoji Support"}]