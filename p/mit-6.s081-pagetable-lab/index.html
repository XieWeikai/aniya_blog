<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='MIT 6.S081 第三个实验，pagetable lab的做法记录'><title>MIT 6.S081 pagetable lab</title>
<link rel=canonical href=https://XieWeikai.github.io/aniya_blog/p/mit-6.s081-pagetable-lab/><link rel=stylesheet href=/aniya_blog/scss/style.min.8191399262444ab68b72a18c97392f5349be20a1615d77445be51e974c144cff.css><meta property='og:title' content='MIT 6.S081 pagetable lab'><meta property='og:description' content='MIT 6.S081 第三个实验，pagetable lab的做法记录'><meta property='og:url' content='https://XieWeikai.github.io/aniya_blog/p/mit-6.s081-pagetable-lab/'><meta property='og:site_name' content="Aniya's Blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:published_time' content='2023-01-19T18:27:13+08:00'><meta property='article:modified_time' content='2023-01-19T18:27:13+08:00'><meta property='og:image' content='https://XieWeikai.github.io/aniya_blog/p/mit-6.s081-pagetable-lab/wallpaper.jpg'><meta name=twitter:title content="MIT 6.S081 pagetable lab"><meta name=twitter:description content="MIT 6.S081 第三个实验，pagetable lab的做法记录"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://XieWeikai.github.io/aniya_blog/p/mit-6.s081-pagetable-lab/wallpaper.jpg'><link rel="shortcut icon" href=/aniya_blog/aniya.ico></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/aniya_blog/><img src=/aniya_blog/img/aniya_hu746a8935f3131bdc51d8425bcf15aebb_113600_300x0_resize_q75_box.jpeg width=300 height=188 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🤤</span></figure><div class=site-meta><h1 class=site-name><a href=/aniya_blog>Aniya's Blog</a></h1><h2 class=site-description>Just for fun.</h2></div></header><ol class=social-menu><li><a href=https://github.com/XieWeikai target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter rel=me><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/aniya_blog/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/aniya_blog/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/aniya_blog/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/aniya_blog/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/aniya_blog/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><div class=menu-bottom-section><li id=i18n-switch><svg class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://XieWeikai.github.io/aniya_blog/ selected>中文</option><option value=https://XieWeikai.github.io/aniya_blog/en/>English</option></select></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#print-a-page-table>Print a page table</a><ol><li><a href=#题目描述>题目描述</a></li><li><a href=#做法>做法</a></li></ol></li><li><a href=#a-kernel-page-table-per-process>A kernel page table per process</a><ol><li><a href=#题目描述-1>题目描述</a></li><li><a href=#做法-1>做法</a></li></ol></li><li><a href=#simplify-copyincopyinstr>Simplify <code>copyin/copyinstr</code></a><ol><li><a href=#问题描述>问题描述</a></li><li><a href=#做法-2>做法</a><ol><li><a href=#辅助函数>辅助函数</a></li><li><a href=#userinit>userinit</a></li><li><a href=#fork>fork</a></li><li><a href=#exec>exec</a></li><li><a href=#sbrk>sbrk</a></li><li><a href=#copyincopyinstr><code>copyin/copyinstr</code></a></li></ol></li></ol></li><li><a href=#尾声>尾声</a></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/aniya_blog/p/mit-6.s081-pagetable-lab/><img src=/aniya_blog/p/mit-6.s081-pagetable-lab/wallpaper_huab5b610965824e9998b331044434bd2e_2713187_800x0_resize_q75_box.jpg srcset="/aniya_blog/p/mit-6.s081-pagetable-lab/wallpaper_huab5b610965824e9998b331044434bd2e_2713187_800x0_resize_q75_box.jpg 800w, /aniya_blog/p/mit-6.s081-pagetable-lab/wallpaper_huab5b610965824e9998b331044434bd2e_2713187_1600x0_resize_q75_box.jpg 1600w" width=800 height=533 loading=lazy alt="Featured image of post MIT 6.S081 pagetable lab"></a></div><div class=article-details><header class=article-category><a href=/aniya_blog/categories/os/ style=background-color:#2a9d8f;color:#fff>OS</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/aniya_blog/p/mit-6.s081-pagetable-lab/>MIT 6.S081 pagetable lab</a></h2><h3 class=article-subtitle>MIT 6.S081 第三个实验，pagetable lab的做法记录</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jan 19, 2023</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 17 分钟</time></div></footer></div></header><section class=article-content><h1 id=lab-page-tables>Lab: page tables</h1><p>距离上一次实验的文章发表已经过去了整整13天，快两周了😀，终于在前几天做完了第三个实验。鉴于<a class=link href=../mit-6.s081-page-table-%e4%bb%a3%e7%a0%81%e8%a7%a3%e6%9e%90>前一篇文章</a>写的太长了，已经对相关的我看过的代码进行了*（深入的）*解析&mldr;😤，故这篇文章简单罗列一下我的做法就象征性的结束啦。</p><p>这个实验的官方页面网址为: <a class=link href=https://pdos.csail.mit.edu/6.828/2020/labs/pgtbl.html target=_blank rel=noopener>https://pdos.csail.mit.edu/6.828/2020/labs/pgtbl.html</a></p><h2 id=print-a-page-table>Print a page table</h2><h3 id=题目描述>题目描述</h3><blockquote><p>Define a function called <code>vmprint()</code>. It should take a <code>pagetable_t</code> argument, and print that pagetable in the format described below. Insert <code>if(p->pid==1) vmprint(p->pagetable)</code> in exec.c just before the <code>return argc</code>, to print the first process&rsquo;s page table. You receive full credit for this assignment if you pass the <code>pte printout</code> test of <code>make grade</code>.</p></blockquote><blockquote><p>Now when you start xv6 it should print output like this, describing the page table of the first process at the point when it has just finished <code>exec()</code>ing <code>init</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>page table 0x0000000087f6e000
</span></span><span class=line><span class=cl>..0: pte 0x0000000021fda801 pa 0x0000000087f6a000
</span></span><span class=line><span class=cl>.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000
</span></span><span class=line><span class=cl>.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000
</span></span><span class=line><span class=cl>.. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000
</span></span><span class=line><span class=cl>.. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000
</span></span><span class=line><span class=cl>..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000
</span></span><span class=line><span class=cl>.. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000
</span></span><span class=line><span class=cl>.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000
</span></span><span class=line><span class=cl>.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000
</span></span></code></pre></td></tr></table></div></div></blockquote><blockquote><p>The first line displays the argument to <code>vmprint</code>. After that there is a line for each PTE, including PTEs that refer to page-table pages deeper in the tree. Each PTE line is indented by a number of <code>" .."</code> that indicates its depth in the tree. Each PTE line shows the PTE index in its page-table page, the pte bits, and the physical address extracted from the PTE. Don&rsquo;t print PTEs that are not valid. In the above example, the top-level page-table page has mappings for entries 0 and 255. The next level down for entry 0 has only index 0 mapped, and the bottom-level for that index 0 has entries 0, 1, and 2 mapped.</p></blockquote><h3 id=做法>做法</h3><p>在官网上给出的提示粘贴如下</p><blockquote><p>Some hints:</p><ul><li>You can put <code>vmprint()</code> in <code>kernel/vm.c</code>.</li><li>Use the macros at the end of the file kernel/riscv.h.</li><li>The function <code>freewalk</code> may be inspirational.</li><li>Define the prototype for <code>vmprint</code> in kernel/defs.h so that you can call it from exec.c.</li><li>Use <code>%p</code> in your printf calls to print out full 64-bit hex PTEs and addresses as shown in the example.</li></ul></blockquote><p>这个题，无非用递归的方式打印每一级页表就完事了，话不多说，直接上实现代码，在<code>vm.c</code>中<code>vmprint</code>函数实现如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>* a helper function to print page table recursively
</span></span></span><span class=line><span class=cl><span class=cm>* level is the level of pagetable
</span></span></span><span class=line><span class=cl><span class=cm>* 0 is the highest level
</span></span></span><span class=line><span class=cl><span class=cm>* 2 is the lowest level
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>print_pte</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>pt</span><span class=p>,</span><span class=kt>int</span> <span class=n>level</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>level</span> <span class=o>&gt;</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>pte_t</span> <span class=o>*</span><span class=n>pte</span> <span class=o>=</span> <span class=p>(</span><span class=kt>pte_t</span> <span class=o>*</span><span class=p>)</span><span class=n>pt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span><span class=p>(</span><span class=n>pte</span> <span class=o>-</span> <span class=p>(</span><span class=kt>pte_t</span> <span class=o>*</span><span class=p>)</span><span class=n>pt</span> <span class=o>&lt;</span> <span class=mi>512</span><span class=p>){</span> <span class=c1>// 512 pte in a page
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=o>*</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=n>PTE_V</span><span class=p>){</span> <span class=c1>// available entry
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>level</span><span class=p>;</span><span class=n>i</span> <span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;.. &#34;</span><span class=p>);</span>  <span class=c1>// indent
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>      <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;..%d: pte %p pa %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>pte</span> <span class=o>-</span> <span class=p>(</span><span class=kt>pte_t</span><span class=o>*</span><span class=p>)</span><span class=n>pt</span><span class=p>,</span><span class=o>*</span><span class=n>pte</span><span class=p>,</span><span class=nf>PTE2PA</span><span class=p>(</span><span class=o>*</span><span class=n>pte</span><span class=p>));</span>
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl>      <span class=nf>print_pte</span><span class=p>((</span><span class=kt>pagetable_t</span><span class=p>)</span><span class=nf>PTE2PA</span><span class=p>(</span><span class=o>*</span><span class=n>pte</span><span class=p>),</span><span class=n>level</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>pte</span> <span class=o>++</span><span class=p>;</span> <span class=c1>// next pte
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>* print the content of a pagetable
</span></span></span><span class=line><span class=cl><span class=cm>* this is a task for pagetable lab
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>vmprint</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>pt</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;page table %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>pt</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>print_pte</span><span class=p>(</span><span class=n>pt</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>实现完该函数后，在<code>exec</code>最后，当进程<code>pid</code>为1则打印那个进程的<code>pagetable</code>，在<code>exec</code>函数添加代码如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>exec</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pid</span><span class=o>==</span><span class=mi>1</span><span class=p>)</span> <span class=nf>vmprint</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>);</span> <span class=c1>// this line is for pagetable lab
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=n>argc</span><span class=p>;</span> <span class=c1>// this ends up in a0, the first argument to main(argc, argv)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>至此第一个task圆满完成。</p><hr><h2 id=a-kernel-page-table-per-process>A kernel page table per process</h2><h3 id=题目描述-1>题目描述</h3><p>在xv6原来的代码实现中，内核就使用固定的一个<code>page table</code>，即<a class=link href=../mit-6.s081-page-table-%e4%bb%a3%e7%a0%81%e8%a7%a3%e6%9e%90/#%e5%86%85%e6%a0%b8%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e5%88%9d%e5%a7%8b%e5%8c%96>上一篇文章</a>中讲到的<code>kernel_pagetable</code>，在这个task中需要给每一个进程都使用一个独立的<code>kernel page table</code>，这些<code>page table</code>中的大部分映射均和<code>kernel_pagetable</code>一致，题目描述摘抄如下</p><blockquote><p>Your first job is to modify the kernel so that every process uses its own copy of the kernel page table when executing in the kernel. Modify <code>struct proc</code> to maintain a kernel page table for each process, and modify the scheduler to switch kernel page tables when switching processes. For this step, each per-process kernel page table should be identical to the existing global kernel page table. You pass this part of the lab if <code>usertests</code> runs correctly.</p></blockquote><h3 id=做法-1>做法</h3><p>该task给了一些提示，如下</p><blockquote><p>Some hints:</p><ul><li>Add a field to <code>struct proc</code> for the process&rsquo;s kernel page table.</li><li>A reasonable way to produce a kernel page table for a new process is to implement a modified version of <code>kvminit</code> that makes a new page table instead of modifying <code>kernel_pagetable</code>. You&rsquo;ll want to call this function from <code>allocproc</code>.</li><li>Make sure that each process&rsquo;s kernel page table has a mapping for that process&rsquo;s kernel stack. In unmodified xv6, all the kernel stacks are set up in <code>procinit</code>. You will need to move some or all of this functionality to <code>allocproc</code>.</li><li>Modify <code>scheduler()</code> to load the process&rsquo;s kernel page table into the core&rsquo;s <code>satp</code> register (see <code>kvminithart</code> for inspiration). Don&rsquo;t forget to call <code>sfence_vma()</code> after calling <code>w_satp()</code>.</li><li><code>scheduler()</code> should use <code>kernel_pagetable</code> when no process is running.</li><li>Free a process&rsquo;s kernel page table in <code>freeproc</code>.</li><li>You&rsquo;ll need a way to free a page table without also freeing the leaf physical memory pages.</li><li><code>vmprint</code> may come in handy to debug page tables.</li><li>It&rsquo;s OK to modify xv6 functions or add new functions; you&rsquo;ll probably need to do this in at least <code>kernel/vm.c</code> and <code>kernel/proc.c</code>. (But, don&rsquo;t modify <code>kernel/vmcopyin.c</code>, <code>kernel/stats.c</code>, <code>user/usertests.c</code>, and <code>user/stats.c</code>.)</li><li>A missing page table mapping will likely cause the kernel to encounter a page fault. It will print an error that includes <code>sepc=0x00000000XXXXXXXX</code>. You can find out where the fault occurred by searching for <code>XXXXXXXX</code> in <code>kernel/kernel.asm</code>.</li></ul></blockquote><p>要完成这个任务就跟着提示一步步做基本就行。</p><p>首先在进程结构中添加一项内核页表项，如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Per-process state
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>proc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=c1>// per-process page table
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>pagetable_t</span> <span class=n>kernel_pgtb</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>由于每个进程都要创建一个内核页表，故模仿<code>kvminit</code>函数写一个创建内核页表的函数，如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>* this is a helper function that maps pages.
</span></span></span><span class=line><span class=cl><span class=cm>* a helper function for make_kernel_ptbl
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>map_helper</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>pt</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>va</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>pa</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>sz</span><span class=p>,</span> <span class=kt>int</span> <span class=n>perm</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=nf>mappages</span><span class=p>(</span><span class=n>pt</span><span class=p>,</span> <span class=n>va</span><span class=p>,</span> <span class=n>sz</span><span class=p>,</span> <span class=n>pa</span><span class=p>,</span> <span class=n>perm</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;map_helper&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 
</span></span></span><span class=line><span class=cl><span class=cm>* make a page table that is identical to kernel_pagetable
</span></span></span><span class=line><span class=cl><span class=cm>* this function is used for make a copy of kernel page table
</span></span></span><span class=line><span class=cl><span class=cm>* for each process.
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kt>pagetable_t</span> <span class=nf>make_kernel_ptbl</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>  <span class=kt>pagetable_t</span> <span class=n>pt</span> <span class=o>=</span> <span class=p>(</span><span class=kt>pagetable_t</span><span class=p>)</span> <span class=nf>kalloc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=nf>memset</span><span class=p>(</span><span class=n>pt</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// uart registers
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>map_helper</span><span class=p>(</span><span class=n>pt</span><span class=p>,</span><span class=n>UART0</span><span class=p>,</span> <span class=n>UART0</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// virtio mmio disk interface
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>map_helper</span><span class=p>(</span><span class=n>pt</span><span class=p>,</span><span class=n>VIRTIO0</span><span class=p>,</span> <span class=n>VIRTIO0</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// CLINT
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>map_helper</span><span class=p>(</span><span class=n>pt</span><span class=p>,</span><span class=n>CLINT</span><span class=p>,</span> <span class=n>CLINT</span><span class=p>,</span> <span class=mh>0x10000</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// PLIC
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>map_helper</span><span class=p>(</span><span class=n>pt</span><span class=p>,</span><span class=n>PLIC</span><span class=p>,</span> <span class=n>PLIC</span><span class=p>,</span> <span class=mh>0x400000</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// map kernel text executable and read-only.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>map_helper</span><span class=p>(</span><span class=n>pt</span><span class=p>,</span><span class=n>KERNBASE</span><span class=p>,</span> <span class=n>KERNBASE</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>etext</span><span class=o>-</span><span class=n>KERNBASE</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_X</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// map kernel data and the physical RAM we&#39;ll make use of.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>map_helper</span><span class=p>(</span><span class=n>pt</span><span class=p>,(</span><span class=n>uint64</span><span class=p>)</span><span class=n>etext</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>etext</span><span class=p>,</span> <span class=n>PHYSTOP</span><span class=o>-</span><span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>etext</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// map the trampoline for trap entry/exit to
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// the highest virtual address in the kernel.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>map_helper</span><span class=p>(</span><span class=n>pt</span><span class=p>,</span><span class=n>TRAMPOLINE</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>trampoline</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_X</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>pt</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>该函数基本就是防着<code>kvminit</code>，构造了一份和<code>kernel_pagetable</code>一样的内核页表.</p><p>接着需要在所有创建进程的地方创建一份内核页表存入对应的<code>struct proc</code>结构中，上<a class=link href=../mit-6.s081-page-table-%e4%bb%a3%e7%a0%81%e8%a7%a3%e6%9e%90/#%e5%88%9b%e5%bb%ba%e8%bf%9b%e7%a8%8b>一篇文章</a>提到，类UNIX系统中所有的进程都是通过<code>fork()</code>创建出来的（第一个进程是例外，因为此时还没有进程可以进行<code>fork</code>操作，所以第一个进程在<code>userinit</code>由系统构造），而<code>fork</code>用到了<code>allocproc</code>函数分配一个<code>UNUSED</code>的<code>struct proc</code>并进行了一些初始化，故在<code>allocproc</code>函数中添加创建内核页表相关代码，修改如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Look in the process table for an UNUSED proc.
</span></span></span><span class=line><span class=cl><span class=c1>// If found, initialize state required to run in the kernel,
</span></span></span><span class=line><span class=cl><span class=c1>// and return with p-&gt;lock held.
</span></span></span><span class=line><span class=cl><span class=c1>// If there are no free procs, or a memory allocation fails, return 0.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=k>struct</span> <span class=n>proc</span><span class=o>*</span>
</span></span><span class=line><span class=cl><span class=nf>allocproc</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=n>p</span> <span class=o>=</span> <span class=n>proc</span><span class=p>;</span> <span class=n>p</span> <span class=o>&lt;</span> <span class=o>&amp;</span><span class=n>proc</span><span class=p>[</span><span class=n>NPROC</span><span class=p>];</span> <span class=n>p</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>acquire</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>state</span> <span class=o>==</span> <span class=n>UNUSED</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>goto</span> <span class=n>found</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>found</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>pid</span> <span class=o>=</span> <span class=nf>allocpid</span><span class=p>();</span>  <span class=c1>// next pid not been used
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// Allocate a trapframe page.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>((</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>trapframe</span> <span class=o>*</span><span class=p>)</span><span class=nf>kalloc</span><span class=p>())</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span> <span class=c1>// in kernel space, kalloc returns a physical address. so p-&gt;trapframe is a physical address
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// An empty user page table.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span> <span class=o>=</span> <span class=nf>proc_pagetable</span><span class=p>(</span><span class=n>p</span><span class=p>);</span> <span class=c1>// this return a page table that has trampoline and trapframe pages mapped
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nf>freeproc</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 此处添加一句创建内核页表的代码
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>kernel_pgtb</span> <span class=o>=</span> <span class=nf>make_kernel_ptbl</span><span class=p>();</span> <span class=c1>// a kernel page table per process
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>根据提示，原先的实现中，所有的<code>kernel_stack</code>均在<code>procinit</code>中给所有进程分配好了，相关映射全都放在了全局的那个<code>kernel_pagetable</code>中，作为改进，应该将分配内核栈这一步骤从<code>procinit</code>移出来，放入<code>allocproc</code>中，内核栈的映射应放到每个进程自己的内核页表中，而不是全局的内核页表<code>kernel_pagetable</code>。</p><p>首先修改<code>procinit</code>，如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// initialize the proc table at boot time.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>procinit</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nf>initlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pid_lock</span><span class=p>,</span> <span class=s>&#34;nextpid&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=n>p</span> <span class=o>=</span> <span class=n>proc</span><span class=p>;</span> <span class=n>p</span> <span class=o>&lt;</span> <span class=o>&amp;</span><span class=n>proc</span><span class=p>[</span><span class=n>NPROC</span><span class=p>];</span> <span class=n>p</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>initlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>,</span> <span class=s>&#34;proc&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c1>// // Allocate a page for the process&#39;s kernel stack.
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// // Map it high in memory, followed by an invalid
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// // guard page.
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// char *pa = kalloc();
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// if(pa == 0)
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>//   panic(&#34;kalloc&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// uint64 va = KSTACK((int) (p - proc));
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// p-&gt;kstack = va;
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// above code set up kernel stack
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// in the lab: page table per process, we move this part to allocproc()
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>kvminithart</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>将<code>kstack</code>相关代码全部注释掉，接着在<code>allocproc</code>中添加如下代码</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Look in the process table for an UNUSED proc.
</span></span></span><span class=line><span class=cl><span class=c1>// If found, initialize state required to run in the kernel,
</span></span></span><span class=line><span class=cl><span class=c1>// and return with p-&gt;lock held.
</span></span></span><span class=line><span class=cl><span class=c1>// If there are no free procs, or a memory allocation fails, return 0.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=k>struct</span> <span class=n>proc</span><span class=o>*</span>
</span></span><span class=line><span class=cl><span class=nf>allocproc</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>kernel_pgtb</span> <span class=o>=</span> <span class=nf>make_kernel_ptbl</span><span class=p>();</span> <span class=c1>// a kernel page table per process
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// set up kstack
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>char</span> <span class=o>*</span><span class=n>pa</span> <span class=o>=</span> <span class=nf>kalloc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>pa</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;kalloc&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 一下代码给进程分配内核栈
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uint64</span> <span class=n>va</span> <span class=o>=</span> <span class=nf>KSTACK</span><span class=p>((</span><span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=n>p</span> <span class=o>-</span> <span class=n>proc</span><span class=p>));</span> 
</span></span><span class=line><span class=cl>  <span class=nf>map_helper</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernel_pgtb</span><span class=p>,</span><span class=n>va</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>pa</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>kstack</span> <span class=o>=</span> <span class=n>va</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>至此<code>allocproc</code>修改完毕。</p><hr><p>按照提示，接着就应该修改调度器<code>scheduler</code>了，在将<code>cpu</code>转交给用户进程前先将<code>satp</code>改为对应的用户内核页表，没有进程运行时改回<code>kernel_pagetable</code>，修改<code>scheduler</code>如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Per-CPU process scheduler.
</span></span></span><span class=line><span class=cl><span class=c1>// Each CPU calls scheduler() after setting itself up.
</span></span></span><span class=line><span class=cl><span class=c1>// Scheduler never returns.  It loops, doing:
</span></span></span><span class=line><span class=cl><span class=c1>//  - choose a process to run.
</span></span></span><span class=line><span class=cl><span class=c1>//  - swtch to start running that process.
</span></span></span><span class=line><span class=cl><span class=c1>//  - eventually that process transfers control
</span></span></span><span class=line><span class=cl><span class=c1>//    via swtch back to the scheduler.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>scheduler</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl> 	<span class=c1>// load process&#39;s kernel page table
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// so that when a process trap in the kernel, the loaded page table here
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// will be used (I guess... I haven&#39;t read the code about how process trap in kernel and I don&#39;t know how to return to process from kernel)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>w_satp</span><span class=p>(</span><span class=nf>MAKE_SATP</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernel_pgtb</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=nf>sfence_vma</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=nf>swtch</span><span class=p>(</span><span class=o>&amp;</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>context</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>context</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// back to kernel, should use kernel_pagetable
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>kvminithart</span><span class=p>();</span> 
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>如上，在<code>swtch</code>前后添加代码。</p><hr><p>接着照着提示，在释放一个进程的资源时应当把对应内核页表占用的资源也释放掉，释放进程资源代码见<code>freeprocess</code>，如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// free a proc structure and the data hanging from it,
</span></span></span><span class=line><span class=cl><span class=c1>// including user pages.
</span></span></span><span class=line><span class=cl><span class=c1>// p-&gt;lock must be held.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>freeproc</span><span class=p>(</span><span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>kfree</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>proc_freepagetable</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>pid</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>parent</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>chan</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>killed</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>xstate</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>state</span> <span class=o>=</span> <span class=n>UNUSED</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>添加一个释放内核页表占据空间的函数如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>proc_freekernel_pgtb</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>pagetable</span><span class=p>,</span><span class=kt>int</span> <span class=n>level</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>level</span> <span class=o>&gt;</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// there are 2^9 = 512 PTEs in a page table.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>512</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=kt>pte_t</span> <span class=n>pte</span> <span class=o>=</span> <span class=n>pagetable</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=n>PTE_V</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=c1>// this PTE points to a lower-level page table.
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>uint64</span> <span class=n>child</span> <span class=o>=</span> <span class=nf>PTE2PA</span><span class=p>(</span><span class=n>pte</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=nf>proc_freekernel_pgtb</span><span class=p>((</span><span class=kt>pagetable_t</span><span class=p>)</span><span class=n>child</span><span class=p>,</span><span class=n>level</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>pagetable</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>kfree</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>pagetable</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>该函数递归的释放页表所在页，将其放回<code>freelist</code>中，但注意该函数只释放页表占据的空间，而不会释放页表映射到的物理内存。<em>如果释放了对应物理内存，那直接寄了，映射到的所有物理页都会放一个<code>struct run</code>结构，破坏了原有数据，且所有这些地址都可能会被<code>kalloc</code>分配在别的地方使用，这些地址都放着不应该动的数据或者其他IO设备</em>。</p><p>接着修改<code>freeproc</code>函数如下，最初我修改的版本如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// free a proc structure and the data hanging from it,
</span></span></span><span class=line><span class=cl><span class=c1>// including user pages.
</span></span></span><span class=line><span class=cl><span class=c1>// p-&gt;lock must be held.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>freeproc</span><span class=p>(</span><span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>kfree</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>proc_freepagetable</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernel_pgtb</span><span class=p>)</span> <span class=c1>// 添加的代码
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>proc_freekernel_pgtb</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernel_pgtb</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>但这样修改有一些测试无法通过&mldr;&mldr;后来我在<code>sys_exec</code>中打印空闲物理页数目时发现，我每执行完一个进程，空闲物理页就少一页，说明还少释放了些什么东西😨，回头看<code>allocproc</code>时，记起来我不仅创建了内核页表，同时分配了一页空闲内存作为<code>kstack</code>，而这一页在释放资源时忘记回收了😇</p><p>最终版<code>freeproc</code>如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// free a proc structure and the data hanging from it,
</span></span></span><span class=line><span class=cl><span class=c1>// including user pages.
</span></span></span><span class=line><span class=cl><span class=c1>// p-&gt;lock must be held.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>freeproc</span><span class=p>(</span><span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=nf>uvmunmap</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernel_pgtb</span><span class=p>,</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kstack</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>);</span> <span class=c1>// 用uvmunmap删除kstack的映射，do_free参数为1，同时释放对应物理页
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernel_pgtb</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>proc_freekernel_pgtb</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernel_pgtb</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><p>最后还有一个鬼地方官方提示没有提到的，做了以上的修改后会报一个<code>panic: kvmpa</code>，需要修改<code>kvmpa</code>函数，使用进程的内核页表</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// translate a kernel virtual address to
</span></span></span><span class=line><span class=cl><span class=c1>// a physical address. only needed for
</span></span></span><span class=line><span class=cl><span class=c1>// addresses on the stack.
</span></span></span><span class=line><span class=cl><span class=c1>// assumes va is page aligned.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>uint64</span>
</span></span><span class=line><span class=cl><span class=nf>kvmpa</span><span class=p>(</span><span class=n>uint64</span> <span class=n>va</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>off</span> <span class=o>=</span> <span class=n>va</span> <span class=o>%</span> <span class=n>PGSIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>pte_t</span> <span class=o>*</span><span class=n>pte</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>pa</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span><span class=o>*</span>
</span></span><span class=line><span class=cl>    <span class=nf>myproc</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>pte</span> <span class=o>=</span> <span class=nf>walk</span><span class=p>(</span><span class=nf>myproc</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>kernel_pgtb</span> <span class=p>,</span> <span class=n>va</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>// 这里本来第一个参数为 kernel_pagetable
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>pte</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;kvmpa&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>((</span><span class=o>*</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=n>PTE_V</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;kvmpa&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>pa</span> <span class=o>=</span> <span class=nf>PTE2PA</span><span class=p>(</span><span class=o>*</span><span class=n>pte</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>pa</span><span class=o>+</span><span class=n>off</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>可以肯定在某些地方，用户的内核页表会被修改的，和全局那个不一样(用户的内核页表应该是在用户陷入内核，即做系统调用时使用的)，此处使用用户的内核页表才能正常运行。</p><hr><p>以上步骤均完成后，可以顺利通过该task的测试啦😁。</p><h2 id=simplify-copyincopyinstr>Simplify <code>copyin/copyinstr</code></h2><p>在上一个实验中看到了，由于用户用的页表和内核使用的页表不一样，在做系统调用陷入内核后，内核要拿到用户提供的缓冲区的数据，必须要用<code>copyin</code>拿到用户的数据，<code>copyinstr</code>拿到用户提供的字符串，等等等等。<code>copyin</code>拿到用户数据的方法是:有了用户的<code>pagetable</code>可以使用<code>walk</code>得到用户数据所在的的<code>pa</code>，内核页表基本都是恒等映射，有了物理地址就可以取出用户数据。</p><p>从上面的描述可以看出，用户进行系统调用时，内核和用户交互数据很麻烦，因为使用的页表不一样。在上一个task中，我们给每一个进程都分配了一个内核页表，进程需要使用内核提供的功能时，陷入内核后使用的就是该进程对应的内核页表。那么，为了使内核可以和用户进程更方便的交互数据，其实可以将用户页表中的映射复制到对应的内核页表中，这样内核就可以直接通过用户提供的地址拿到或放入数据了。</p><p>当然在这里吗可能存在问题，通过<a class=link href=../mit-6.s081-page-table-%e4%bb%a3%e7%a0%81%e8%a7%a3%e6%9e%90/>上一篇文章</a>的诸多代码(如<code>userinit</code>创建第一个进程，<code>exec</code>创建新进程等等)都可以看出，用户的地址空间从0增长到<code>p->sz</code>(<code>p</code>为<code>struct proc</code>指针，指向该进程对应的结构体)，如果0~<code>p->sz</code>和内核页表原先映射的空间重叠，那就糟糕了。所幸的是，用户陷入到内核时，内核会使用到的地址空间的范围在<code>PLIC</code>以上，这之下的空间不会用到，故只要用户进程空间增长不超过<code>PLIC</code>，就不会有问题。</p><h3 id=问题描述>问题描述</h3><blockquote><p>The kernel&rsquo;s <code>copyin</code> function reads memory pointed to by user pointers. It does this by translating them to physical addresses, which the kernel can directly dereference. It performs this translation by walking the process page-table in software. Your job in this part of the lab is to add user mappings to each process&rsquo;s kernel page table (created in the previous section) that allow <code>copyin</code> (and the related string function <code>copyinstr</code>) to directly dereference user pointers.</p><blockquote><p>Replace the body of <code>copyin</code> in <code>kernel/vm.c</code> with a call to <code>copyin_new</code> (defined in <code>kernel/vmcopyin.c</code>); do the same for <code>copyinstr</code> and <code>copyinstr_new</code>. Add mappings for user addresses to each process&rsquo;s kernel page table so that <code>copyin_new</code> and <code>copyinstr_new</code> work. You pass this assignment if <code>usertests</code> runs correctly and all the <code>make grade</code> tests pass.</p></blockquote><p>Some hints:</p><ul><li>Replace <code>copyin()</code> with a call to <code>copyin_new</code> first, and make it work, before moving on to <code>copyinstr</code>.</li><li>At each point where the kernel changes a process&rsquo;s user mappings, change the process&rsquo;s kernel page table in the same way. Such points include <code>fork()</code>, <code>exec()</code>, and <code>sbrk()</code>.</li><li>Don&rsquo;t forget that to include the first process&rsquo;s user page table in its kernel page table in <code>userinit</code>.</li><li>What permissions do the PTEs for user addresses need in a process&rsquo;s kernel page table? (A page with <code>PTE_U</code> set cannot be accessed in kernel mode.)</li><li>Don&rsquo;t forget about the above-mentioned PLIC limit.</li></ul></blockquote><h3 id=做法-2>做法</h3><p>按照前面的描述，只需要在用户进程地址空间发生变化，并在用户页表做对应映射时，用户的内核页表也做同样的映射即可。</p><p>首先依据题目，可以知道用户进程的内核页表其实用不到<code>CLINT</code>，故修改<code>make_kernel_ptbl()</code>函数如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* 
</span></span></span><span class=line><span class=cl><span class=cm>* make a page table that is identical to kernel_pagetable
</span></span></span><span class=line><span class=cl><span class=cm>* this function is used for making a copy of kernel page table
</span></span></span><span class=line><span class=cl><span class=cm>* for each process.
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kt>pagetable_t</span> <span class=nf>make_kernel_ptbl</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>  <span class=kt>pagetable_t</span> <span class=n>pt</span> <span class=o>=</span> <span class=p>(</span><span class=kt>pagetable_t</span><span class=p>)</span> <span class=nf>kalloc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=nf>memset</span><span class=p>(</span><span class=n>pt</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// uart registers
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>map_helper</span><span class=p>(</span><span class=n>pt</span><span class=p>,</span><span class=n>UART0</span><span class=p>,</span> <span class=n>UART0</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// virtio mmio disk interface
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>map_helper</span><span class=p>(</span><span class=n>pt</span><span class=p>,</span><span class=n>VIRTIO0</span><span class=p>,</span> <span class=n>VIRTIO0</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// CLINT
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// map_helper(pt,CLINT, CLINT, 0x10000, PTE_R | PTE_W);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// PLIC
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>map_helper</span><span class=p>(</span><span class=n>pt</span><span class=p>,</span><span class=n>PLIC</span><span class=p>,</span> <span class=n>PLIC</span><span class=p>,</span> <span class=mh>0x400000</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// map kernel text executable and read-only.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>map_helper</span><span class=p>(</span><span class=n>pt</span><span class=p>,</span><span class=n>KERNBASE</span><span class=p>,</span> <span class=n>KERNBASE</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>etext</span><span class=o>-</span><span class=n>KERNBASE</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_X</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// map kernel data and the physical RAM we&#39;ll make use of.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>map_helper</span><span class=p>(</span><span class=n>pt</span><span class=p>,(</span><span class=n>uint64</span><span class=p>)</span><span class=n>etext</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>etext</span><span class=p>,</span> <span class=n>PHYSTOP</span><span class=o>-</span><span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>etext</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_W</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// map the trampoline for trap entry/exit to
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// the highest virtual address in the kernel.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>map_helper</span><span class=p>(</span><span class=n>pt</span><span class=p>,</span><span class=n>TRAMPOLINE</span><span class=p>,</span> <span class=p>(</span><span class=n>uint64</span><span class=p>)</span><span class=n>trampoline</span><span class=p>,</span> <span class=n>PGSIZE</span><span class=p>,</span> <span class=n>PTE_R</span> <span class=o>|</span> <span class=n>PTE_X</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>pt</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>如上，将<code>CLINT</code>映射删去。</p><h4 id=辅助函数>辅助函数</h4><p>按照前文所述，需要给内核页表同步做和用户页表一样的映射，故在<code>vm.c</code>中写一个复制两个页表映射的辅助函数如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// copy page table from src to dst
</span></span></span><span class=line><span class=cl><span class=c1>// virtual address from oldsz to newsz
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>copy_pgtb</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>dst</span><span class=p>,</span><span class=kt>pagetable_t</span> <span class=n>src</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>oldsz</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>newsz</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>a</span> <span class=o>=</span> <span class=nf>PGROUNDUP</span><span class=p>(</span><span class=n>oldsz</span><span class=p>);</span> <span class=c1>// oldsz那一页原本已经分配并映射过了，故此处是round up
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uint64</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>pte_t</span> <span class=o>*</span><span class=n>pte</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(;</span> <span class=n>a</span> <span class=o>&lt;</span> <span class=n>newsz</span><span class=p>;</span> <span class=n>a</span> <span class=o>+=</span> <span class=n>PGSIZE</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>a</span> <span class=o>&gt;=</span> <span class=n>PLIC</span><span class=p>)</span>  <span class=c1>// 要超过PLIC了，不允许
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pte</span> <span class=o>=</span> <span class=nf>walk</span><span class=p>(</span><span class=n>src</span><span class=p>,</span><span class=n>a</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>pte</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>addr</span> <span class=o>=</span> <span class=nf>PTE2PA</span><span class=p>(</span><span class=o>*</span><span class=n>pte</span><span class=p>);</span>  <span class=c1>// 拿到映射到的物理地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=nf>mappages</span><span class=p>(</span><span class=n>dst</span><span class=p>,</span><span class=n>a</span><span class=p>,</span><span class=n>PGSIZE</span><span class=p>,</span><span class=n>addr</span><span class=p>,</span><span class=n>PTE_W</span> <span class=o>|</span> <span class=n>PTE_R</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=c1>// 在dst中做同样的映射
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>err</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=nf>uvmunmap</span><span class=p>(</span><span class=n>dst</span><span class=p>,</span><span class=nf>PGROUNDUP</span><span class=p>(</span><span class=n>oldsz</span><span class=p>),(</span><span class=n>a</span> <span class=o>-</span> <span class=nf>PGROUNDUP</span><span class=p>(</span><span class=n>oldsz</span><span class=p>))</span> <span class=o>/</span> <span class=n>PGSIZE</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span> <span class=c1>// 出错，去除已经做了的映射，恢复原样
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>上面这个函数是仿照<code>uvmalloc</code>来写的，作用是从<code>src</code>页表中将虚拟地址<code>oldsz</code>到<code>newsz</code>的映射复制到页表<code>dst</code>中去。上面这个代码是正确可用的，之前我曾写过下面这个版本</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// copy page table from src to dst
</span></span></span><span class=line><span class=cl><span class=c1>// virtual address from oldsz to newsz
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>copy_pgtb</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>dst</span><span class=p>,</span><span class=kt>pagetable_t</span> <span class=n>src</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>oldsz</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>newsz</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>a</span> <span class=o>=</span> <span class=nf>PGROUNDUP</span><span class=p>(</span><span class=n>oldsz</span><span class=p>);</span> <span class=c1>// oldsz那一页原本已经分配并映射过了，故此处是round up
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>uint64</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>pte_t</span> <span class=o>*</span><span class=n>pte</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(;</span> <span class=n>a</span> <span class=o>&lt;</span> <span class=n>newsz</span><span class=p>;</span> <span class=n>a</span> <span class=o>+=</span> <span class=n>PGSIZE</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>a</span> <span class=o>&gt;=</span> <span class=n>PLIC</span><span class=p>)</span>  <span class=c1>// 要超过PLIC了，不允许
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>addr</span> <span class=o>=</span> <span class=nf>walkaddr</span><span class=p>(</span><span class=n>src</span><span class=p>,</span><span class=n>a</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;copy_pgtb: addr in src not available&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=nf>mappages</span><span class=p>(</span><span class=n>dst</span><span class=p>,</span><span class=n>a</span><span class=p>,</span><span class=n>PGSIZE</span><span class=p>,</span><span class=n>addr</span><span class=p>,</span><span class=n>PTE_W</span> <span class=o>|</span> <span class=n>PTE_R</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=c1>// 在dst中做同样的映射
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>err</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=nf>uvmunmap</span><span class=p>(</span><span class=n>dst</span><span class=p>,</span><span class=nf>PGROUNDUP</span><span class=p>(</span><span class=n>oldsz</span><span class=p>),(</span><span class=n>a</span> <span class=o>-</span> <span class=nf>PGROUNDUP</span><span class=p>(</span><span class=n>oldsz</span><span class=p>))</span> <span class=o>/</span> <span class=n>PGSIZE</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span> <span class=c1>// 出错，去除已经做了的映射，恢复原样
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>直接通过<code>walkaddr</code>拿到<code>va</code>对应的<code>pa</code>，但在实际运行时报了<code>panic</code>，<code>walkaddr</code>总是运行不正确，<code>walkaddr</code>代码如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Look up a virtual address, return the physical address,
</span></span></span><span class=line><span class=cl><span class=c1>// or 0 if not mapped.
</span></span></span><span class=line><span class=cl><span class=c1>// Can only be used to look up user pages.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>uint64</span>
</span></span><span class=line><span class=cl><span class=nf>walkaddr</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>pagetable</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>va</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>pte_t</span> <span class=o>*</span><span class=n>pte</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>pa</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>va</span> <span class=o>&gt;=</span> <span class=n>MAXVA</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>pte</span> <span class=o>=</span> <span class=nf>walk</span><span class=p>(</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>va</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>pte</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>((</span><span class=o>*</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=n>PTE_V</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>((</span><span class=o>*</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=n>PTE_U</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>pa</span> <span class=o>=</span> <span class=nf>PTE2PA</span><span class=p>(</span><span class=o>*</span><span class=n>pte</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>pa</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>可以看到<code>walkaddr</code>只查<code>PTE_U</code>的<code>pte</code>，在<a class=link href=../mit-6.s081-page-table-%e4%bb%a3%e7%a0%81%e8%a7%a3%e6%9e%90/#exec>上一篇文章</a>中可以看到，用户栈前一页是<code>guard page</code>，这一页没有设置<code>PTE_U</code>，故在复制映射时走到<code>guard page</code>就会出错了，所以还得是直接用<code>walk</code>。</p><hr><h4 id=userinit>userinit</h4><p>第一个进程在<code>userinit</code>处初始化，在该函数内同时复制用户页表到内核页表如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Set up first user process.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>userinit</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>p</span> <span class=o>=</span> <span class=nf>allocproc</span><span class=p>();</span>  <span class=c1>// set trampoline and trapframe
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>initproc</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=c1>// allocate one user page and copy init&#39;s instructions
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// and data into it.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>uvminit</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>initcode</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>initcode</span><span class=p>));</span>  <span class=c1>// allocate one page and copy data in it
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>copy_pgtb</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernel_pgtb</span><span class=p>,</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=n>PGSIZE</span><span class=p>);</span>    <span class=c1>// &lt;------添加这句话
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span> <span class=o>=</span> <span class=n>PGSIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// prepare for the very first &#34;return&#34; from kernel to user.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>epc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>      <span class=c1>// user program counter
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>sp</span> <span class=o>=</span> <span class=n>PGSIZE</span><span class=p>;</span>  <span class=c1>// user stack pointer
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=nf>safestrcpy</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=s>&#34;initcode&#34;</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>cwd</span> <span class=o>=</span> <span class=nf>namei</span><span class=p>(</span><span class=s>&#34;/&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>state</span> <span class=o>=</span> <span class=n>RUNNABLE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=fork>fork</h4><p>除去第一个进程，其余所有进程都是通过<code>fork</code>创建的，在该处也要同步页表，如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Create a new process, copying the parent.
</span></span></span><span class=line><span class=cl><span class=c1>// Sets up child kernel stack to return as if from fork() system call.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>fork</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>np</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Allocate process.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>((</span><span class=n>np</span> <span class=o>=</span> <span class=nf>allocproc</span><span class=p>())</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>  <span class=c1>// 下面这一条if语句中除了复制父进程内存，同时也将子进程页表同步到子进程内核页表
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// Copy user memory from parent to child.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=nf>uvmcopy</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>np</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=o>!</span><span class=nf>copy_pgtb</span><span class=p>(</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>kernel_pgtb</span><span class=p>,</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span><span class=p>)){</span><span class=c1>//&lt;--- 修改了这一行
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>freeproc</span><span class=p>(</span><span class=n>np</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>np</span><span class=o>-&gt;</span><span class=n>sz</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>np</span><span class=o>-&gt;</span><span class=n>parent</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// copy saved user registers.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=o>*</span><span class=p>(</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=p>)</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Cause fork to return 0 in the child.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>np</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>a0</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// increment reference counts on open file descriptors.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>NOFILE</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>ofile</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>      <span class=n>np</span><span class=o>-&gt;</span><span class=n>ofile</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nf>filedup</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>ofile</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=n>np</span><span class=o>-&gt;</span><span class=n>cwd</span> <span class=o>=</span> <span class=nf>idup</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>cwd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>safestrcpy</span><span class=p>(</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>pid</span> <span class=o>=</span> <span class=n>np</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>np</span><span class=o>-&gt;</span><span class=n>state</span> <span class=o>=</span> <span class=n>RUNNABLE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>release</span><span class=p>(</span><span class=o>&amp;</span><span class=n>np</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=exec>exec</h4><p><code>exec</code>函数通过读取<code>elf</code>文件，重新创建新的内存地址空间，填入新的内容，删除原来的内存地址空间，对该函数做修改如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>exec</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>s</span><span class=p>,</span> <span class=o>*</span><span class=n>last</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>off</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>argc</span><span class=p>,</span> <span class=n>sz</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>sp</span><span class=p>,</span> <span class=n>ustack</span><span class=p>[</span><span class=n>MAXARG</span><span class=o>+</span><span class=mi>1</span><span class=p>],</span> <span class=n>stackbase</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>elfhdr</span> <span class=n>elf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=n>ip</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proghdr</span> <span class=n>ph</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>pagetable_t</span> <span class=n>pagetable</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>oldpagetable</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>...</span> <span class=c1>// 这里在读elf,创建新的页表，填入新的进程的各个段，并初始化命令行参数
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>  <span class=c1>// Commit to the user image.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>oldpagetable</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span> <span class=o>=</span> <span class=n>pagetable</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span> <span class=o>=</span> <span class=n>sz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>epc</span> <span class=o>=</span> <span class=n>elf</span><span class=p>.</span><span class=n>entry</span><span class=p>;</span>  <span class=c1>// initial program counter = main
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>sp</span> <span class=o>=</span> <span class=n>sp</span><span class=p>;</span> <span class=c1>// initial stack pointer
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>uvmunmap</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernel_pgtb</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=nf>PGROUNDUP</span><span class=p>(</span><span class=n>oldsz</span><span class=p>)</span><span class=o>/</span><span class=n>PGSIZE</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span> <span class=c1>// &lt;-------去除原来的映射
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>proc_freepagetable</span><span class=p>(</span><span class=n>oldpagetable</span><span class=p>,</span> <span class=n>oldsz</span><span class=p>);</span> <span class=c1>// 回收原来的空间
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=nf>copy_pgtb</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernel_pgtb</span><span class=p>,</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span><span class=p>))</span>  <span class=c1>// &lt;-----同步内核页表
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>goto</span> <span class=n>bad</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pid</span><span class=o>==</span><span class=mi>1</span><span class=p>)</span> <span class=nf>vmprint</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>);</span> <span class=c1>// this line is for pagetable lab
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=n>argc</span><span class=p>;</span> <span class=c1>// this ends up in a0, the first argument to main(argc, argv)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nl>bad</span><span class=p>:</span>
</span></span><span class=line><span class=cl> <span class=p>...</span> <span class=c1>// 后面在做错误处理
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=sbrk>sbrk</h4><p><code>sbrk</code>系统调用会改变进程可用内存空间大小，可以增加内存也可以减小内存，因此也会改变用户页表，故内核页表也要做对应改变。查看该系统调用代码如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>uint64</span>
</span></span><span class=line><span class=cl><span class=nf>sys_sbrk</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=nf>argint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>n</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>addr</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>sz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=nf>growproc</span><span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>可以看到<code>growproc</code>完成了改变内存大小的工作，修改该函数如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Grow or shrink user memory by n bytes.
</span></span></span><span class=line><span class=cl><span class=c1>// Return 0 on success, -1 on failure.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>growproc</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>sz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>sz</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>n</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>sz</span> <span class=o>=</span> <span class=nf>uvmalloc</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>sz</span><span class=p>,</span> <span class=n>sz</span> <span class=o>+</span> <span class=n>n</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=nf>copy_pgtb</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernel_pgtb</span><span class=p>,</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span><span class=p>,</span><span class=n>sz</span><span class=p>)){</span><span class=c1>// &lt;---同步增长 
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 下面这俩写反了........
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>uvmunmap</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernel_pgtb</span><span class=p>,</span><span class=nf>PGROUNDUP</span><span class=p>(</span><span class=n>sz</span><span class=o>+</span><span class=n>n</span><span class=p>),(</span><span class=nf>PGROUNDUP</span><span class=p>(</span><span class=n>sz</span><span class=p>)</span> <span class=o>-</span> <span class=nf>PGROUNDUP</span><span class=p>(</span><span class=n>sz</span><span class=o>+</span><span class=n>n</span><span class=p>))</span> <span class=o>/</span> <span class=n>PGSIZE</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span> <span class=c1>//&lt;---- 同步减少
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>sz</span> <span class=o>=</span> <span class=nf>uvmdealloc</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>sz</span><span class=p>,</span> <span class=n>sz</span> <span class=o>+</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span> <span class=o>=</span> <span class=n>sz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=插曲>插曲</h5><p>额，之前写上面那个<code>growproc</code>的代码时，<code>uvmunmap</code>和<code>uvmdealloc</code>那两行写反了，导致代码会报<code>panic: not map</code>，查找<code>uvmunmap</code>时发现报<code>panic</code>的代码如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Remove npages of mappings starting from va. va must be
</span></span></span><span class=line><span class=cl><span class=c1>// page-aligned. The mappings must exist.
</span></span></span><span class=line><span class=cl><span class=c1>// Optionally free the physical memory.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>uvmunmap</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>pagetable</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>va</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>npages</span><span class=p>,</span> <span class=kt>int</span> <span class=n>do_free</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>pte_t</span> <span class=o>*</span><span class=n>pte</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>((</span><span class=n>va</span> <span class=o>%</span> <span class=n>PGSIZE</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;uvmunmap: not aligned&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span><span class=p>(</span><span class=n>a</span> <span class=o>=</span> <span class=n>va</span><span class=p>;</span> <span class=n>a</span> <span class=o>&lt;</span> <span class=n>va</span> <span class=o>+</span> <span class=n>npages</span><span class=o>*</span><span class=n>PGSIZE</span><span class=p>;</span> <span class=n>a</span> <span class=o>+=</span> <span class=n>PGSIZE</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>pte</span> <span class=o>=</span> <span class=nf>walk</span><span class=p>(</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;uvmunmap: walk&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=o>*</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=n>PTE_V</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;uvmunmap: not mapped&#34;</span><span class=p>);</span> <span class=c1>// &lt;---- 这里，如果一页映射不存在，就会报这个panic
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=nf>PTE_FLAGS</span><span class=p>(</span><span class=o>*</span><span class=n>pte</span><span class=p>)</span> <span class=o>==</span> <span class=n>PTE_V</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nf>panic</span><span class=p>(</span><span class=s>&#34;uvmunmap: not a leaf&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>do_free</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=n>uint64</span> <span class=n>pa</span> <span class=o>=</span> <span class=nf>PTE2PA</span><span class=p>(</span><span class=o>*</span><span class=n>pte</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=nf>kfree</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>pa</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>pte</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>使用<code>gdb</code>在<code>panic</code>处设置断点，跑到<code>panic</code>了后使用<code>backtrace</code>查看栈帧，发现是在<code>exec</code>中如下代码爆出的错误</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Commit to the user image.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>oldpagetable</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span> <span class=o>=</span> <span class=n>pagetable</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span> <span class=o>=</span> <span class=n>sz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>epc</span> <span class=o>=</span> <span class=n>elf</span><span class=p>.</span><span class=n>entry</span><span class=p>;</span>  <span class=c1>// initial program counter = main
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>trapframe</span><span class=o>-&gt;</span><span class=n>sp</span> <span class=o>=</span> <span class=n>sp</span><span class=p>;</span> <span class=c1>// initial stack pointer
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>uvmunmap</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernel_pgtb</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=nf>PGROUNDUP</span><span class=p>(</span><span class=n>oldsz</span><span class=p>)</span><span class=o>/</span><span class=n>PGSIZE</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span> <span class=c1>// &lt;------- 这一个uvmunmap报了panic
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>proc_freepagetable</span><span class=p>(</span><span class=n>oldpagetable</span><span class=p>,</span> <span class=n>oldsz</span><span class=p>);</span> <span class=c1>// 回收原来的空间
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=nf>copy_pgtb</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernel_pgtb</span><span class=p>,</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span><span class=p>))</span>  <span class=c1>// &lt;-----同步内核页表
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>goto</span> <span class=n>bad</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>感觉在<code>growproc</code>那的两行代码的顺序没问题呀，一个是删除用户的页表中对应地址的映射并释放对应空间，一个是删除内核页表对应地址的映射，好像什么顺序都行呀。</p><p>然后我写了下面的函数来<code>debug</code>，下面的函数用于查看某个页表从0开始映射的有效页数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>num_user_pages</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>pt</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>num</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>uint64</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>pte_t</span> <span class=o>*</span><span class=n>pte</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span><span class=p>(</span><span class=n>a</span> <span class=o>&lt;</span> <span class=n>PLIC</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>pte</span> <span class=o>=</span> <span class=nf>walk</span><span class=p>(</span><span class=n>pt</span><span class=p>,</span><span class=n>a</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>pte</span> <span class=o>||</span> <span class=o>!</span><span class=p>(</span><span class=o>*</span><span class=n>pte</span> <span class=o>&amp;</span> <span class=n>PTE_V</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>num</span> <span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>+=</span> <span class=n>PGSIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>接着修改<code>growproc</code>代码</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>growproc</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>uint</span> <span class=n>sz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>sz</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>n</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>sz</span> <span class=o>=</span> <span class=nf>uvmalloc</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>sz</span><span class=p>,</span> <span class=n>sz</span> <span class=o>+</span> <span class=n>n</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=nf>copy_pgtb</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernel_pgtb</span><span class=p>,</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span><span class=p>,</span><span class=n>sz</span><span class=p>)){</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>sz</span> <span class=o>=</span> <span class=nf>uvmdealloc</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>sz</span><span class=p>,</span> <span class=n>sz</span> <span class=o>+</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;right before uvmunmap in growproc</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>uvmunmap</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernel_pgtb</span><span class=p>,</span><span class=nf>PGROUNDUP</span><span class=p>(</span><span class=n>sz</span><span class=o>+</span><span class=n>n</span><span class=p>),(</span><span class=nf>PGROUNDUP</span><span class=p>(</span><span class=n>sz</span><span class=p>)</span> <span class=o>-</span> <span class=nf>PGROUNDUP</span><span class=p>(</span><span class=n>sz</span><span class=o>+</span><span class=n>n</span><span class=p>))</span> <span class=o>/</span> <span class=n>PGSIZE</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;right after uvmunmap in growproc</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;&gt;&gt;&gt;&gt;growproc done. pid = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;--- user pgtbl:%d</span><span class=se>\n</span><span class=s>--- kernel pgtbl:%d</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,</span><span class=nf>num_user_pages</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>),</span><span class=nf>num_user_pages</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernel_pgtb</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span> <span class=o>=</span> <span class=n>sz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>运行<code>usertests</code>时发现有这样的输出</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>right before uvmunmap in growproc
</span></span><span class=line><span class=cl>right after uvmunmap in growproc
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>&gt;&gt;&gt;&gt;growproc done. pid = 20
</span></span><span class=line><span class=cl>--- user pgtbl:32082
</span></span><span class=line><span class=cl>--- kernel pgtbl:32081
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>right before uvmunmap in growproc
</span></span><span class=line><span class=cl>right after uvmunmap in growproc
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>&gt;&gt;&gt;&gt;growproc done. pid = 20
</span></span><span class=line><span class=cl>--- user pgtbl:32081
</span></span><span class=line><span class=cl>--- kernel pgtbl:32080
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div><p>震惊，在<code>growproc</code>用于减小内存空间时<code>kernel pagetbl</code>少了一页，怎么肥事，再仔细看看</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>sz</span> <span class=o>=</span> <span class=nf>uvmdealloc</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>sz</span><span class=p>,</span> <span class=n>sz</span> <span class=o>+</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>uvmunmap</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>kernel_pgtb</span><span class=p>,</span><span class=nf>PGROUNDUP</span><span class=p>(</span><span class=n>sz</span><span class=o>+</span><span class=n>n</span><span class=p>),(</span><span class=nf>PGROUNDUP</span><span class=p>(</span><span class=n>sz</span><span class=p>)</span> <span class=o>-</span> <span class=nf>PGROUNDUP</span><span class=p>(</span><span class=n>sz</span><span class=o>+</span><span class=n>n</span><span class=p>))</span> <span class=o>/</span> <span class=n>PGSIZE</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>原来前面的<code>sz = uvmdealloc(...)</code>已经改变了<code>sz</code>的大小😇，后面<code>uvmunmap</code>用的<code>sz</code>是错的&mldr;&mldr;</p><p>所以这两句换过来后<code>sz</code>就对了，就能通过所有测试了。</p><hr><h4 id=copyincopyinstr><code>copyin/copyinstr</code></h4><p>修改原来的<code>copyin/copyinstr</code>这两个函数如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Copy a null-terminated string from user to kernel.
</span></span></span><span class=line><span class=cl><span class=c1>// Copy bytes to dst from virtual address srcva in a given page table,
</span></span></span><span class=line><span class=cl><span class=c1>// until a &#39;\0&#39;, or max.
</span></span></span><span class=line><span class=cl><span class=c1>// Return 0 on success, -1 on error.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>copyinstr</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>pagetable</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>dst</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>srcva</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>max</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>copyinstr_new</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>pagetable</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>dst</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>srcva</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>max</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>copyinstr_new</span><span class=p>(</span><span class=n>pagetable</span><span class=p>,</span><span class=n>dst</span><span class=p>,</span><span class=n>srcva</span><span class=p>,</span><span class=n>max</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Copy from user to kernel.
</span></span></span><span class=line><span class=cl><span class=c1>// Copy len bytes to dst from virtual address srcva in a given page table.
</span></span></span><span class=line><span class=cl><span class=c1>// Return 0 on success, -1 on error.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nf>copyin</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>pagetable</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>dst</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>srcva</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>len</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>copyin_new</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>pagetable</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>dst</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>srcva</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>copyin_new</span><span class=p>(</span><span class=n>pagetable</span><span class=p>,</span> <span class=n>dst</span><span class=p>,</span> <span class=n>srcva</span><span class=p>,</span> <span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>其中<code>copyin_new</code>和<code>copyinstr</code>是这个实验本来就已经实现好了的，其实就是简单的直接复制数据，截取<code>copyin_new</code>代码如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span>
</span></span><span class=line><span class=cl><span class=nf>memmove</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>dst</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>src</span><span class=p>,</span> <span class=n>uint</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>s</span> <span class=o>=</span> <span class=n>src</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>d</span> <span class=o>=</span> <span class=n>dst</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>s</span> <span class=o>&lt;</span> <span class=n>d</span> <span class=o>&amp;&amp;</span> <span class=n>s</span> <span class=o>+</span> <span class=n>n</span> <span class=o>&gt;</span> <span class=n>d</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>+=</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>d</span> <span class=o>+=</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>n</span><span class=o>--</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=o>*--</span><span class=n>d</span> <span class=o>=</span> <span class=o>*--</span><span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>n</span><span class=o>--</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=o>*</span><span class=n>d</span><span class=o>++</span> <span class=o>=</span> <span class=o>*</span><span class=n>s</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>dst</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>copyin_new</span><span class=p>(</span><span class=kt>pagetable_t</span> <span class=n>pagetable</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>dst</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>srcva</span><span class=p>,</span> <span class=n>uint64</span> <span class=n>len</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>proc</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>myproc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>srcva</span> <span class=o>&gt;=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span> <span class=o>||</span> <span class=n>srcva</span><span class=o>+</span><span class=n>len</span> <span class=o>&gt;=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>sz</span> <span class=o>||</span> <span class=n>srcva</span><span class=o>+</span><span class=n>len</span> <span class=o>&lt;</span> <span class=n>srcva</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>memmove</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=n>dst</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>srcva</span><span class=p>,</span> <span class=n>len</span><span class=p>);</span> <span class=c1>// 直接复制数据
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>stats</span><span class=p>.</span><span class=n>ncopyin</span><span class=o>++</span><span class=p>;</span>   <span class=c1>// XXX lock  // 这貌似是测试用的代码？
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=尾声>尾声</h2><p>做完上面的所有修改，就可以通过所有的测试啦😋😋</p><p>上个图纪念一下</p><p><img src=/aniya_blog/p/mit-6.s081-pagetable-lab/assets/image-20230120162551565.png width=716 height=698 srcset="/aniya_blog/p/mit-6.s081-pagetable-lab/assets/image-20230120162551565_hub77c20e2cb20bdad2a1a10db0e28550d_98170_480x0_resize_box_3.png 480w, /aniya_blog/p/mit-6.s081-pagetable-lab/assets/image-20230120162551565_hub77c20e2cb20bdad2a1a10db0e28550d_98170_1024x0_resize_box_3.png 1024w" loading=lazy alt=通过所有测试 class=gallery-image data-flex-grow=102 data-flex-basis=246px></p><p>做完这个实验，也算是实际使用过了传说中的页表啦，虽然整体使用页表的方式都比较简单，但毕竟是一个真正的跑在riscv上的东西，和纯理论相比实际多了，还算是有所收获😁。</p></section><footer class=article-footer><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css integrity="sha256-J+iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s=" crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js integrity="sha256-InsNdER1b2xUewP+pKCUJpkhiqwHgqiPXDlIk7GzBu4=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI=" crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/aniya_blog/p/mit-6.s081-page-table-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/><div class=article-image><img src=/aniya_blog/p/mit-6.s081-page-table-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/wallpaper.1a7c164d7588e479a8cd3b0543a28107_hudb94877ecea93d4ab13b1a424f076a8e_2205015_250x150_fill_q75_box_smart1.jpg width=250 height=150 loading=lazy alt="Featured image of post MIT 6.S081 page table 代码解析" data-hash="md5-GnwWTXWI5HmozTsFQ6KBBw=="></div><div class=article-details><h2 class=article-title>MIT 6.S081 page table 代码解析</h2></div></a></article><article class=has-image><a href=/aniya_blog/p/%E9%97%B2%E8%B0%88gdb/><div class=article-image><img src=/aniya_blog/p/%E9%97%B2%E8%B0%88gdb/piano.f90597ada3d1ee9a0f72689877b34d83_hu28da5375bae764b9601c6414097b4ddd_1403895_250x150_fill_q75_box_smart1.jpg width=250 height=150 loading=lazy alt="Featured image of post 闲谈、gdb" data-hash="md5-+QWXraPR7poPcmiYd7NNgw=="></div><div class=article-details><h2 class=article-title>闲谈、gdb</h2></div></a></article><article class=has-image><a href=/aniya_blog/p/lab2-system-calls/><div class=article-image><img src=/aniya_blog/p/lab2-system-calls/cover.1b1c2c8a3a0436f8c683de842e6ad9a0_hu7ace472778f385b50e7c8f287dbb6c46_2544271_250x150_fill_q75_box_smart1.jpg width=250 height=150 loading=lazy alt="Featured image of post lab2: system calls" data-hash="md5-GxwsijoENvjGg96ELmrZoA=="></div><div class=article-details><h2 class=article-title>lab2: system calls</h2></div></a></article><article class=has-image><a href=/aniya_blog/p/os_util_lab/><div class=article-image><img src=/aniya_blog/p/os_util_lab/saber2.d3cf7db7f3e39c28f3c1c04197864dea_hu583263cbbee05d2c263b501713a891d4_83776_250x150_fill_q75_box_smart1.jpg width=250 height=150 loading=lazy alt="Featured image of post OS_util_lab" data-hash="md5-0899t/PjnCjzwcBBl4ZN6g=="></div><div class=article-details><h2 class=article-title>OS_util_lab</h2></div></a></article><article class=has-image><a href=/aniya_blog/p/xv6-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/><div class=article-image><img src=/aniya_blog/p/xv6-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/wallpaper.74540f2c69533900a024c238ae79d45e_hu0ff37ebbb98d2b42bafbb67ed8d5243a_153541_250x150_fill_q75_box_smart1.jpg width=250 height=150 loading=lazy alt="Featured image of post xv6 环境配置" data-hash="md5-dFQPLGlTOQCgJMI4rnnUXg=="></div><div class=article-details><h2 class=article-title>xv6 环境配置</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2020 -
2024 Aniya's Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.16.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/aniya_blog/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>